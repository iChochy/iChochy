[
  {
    "objectID": 20250402,
    "url": "https://ichochy.com/posts/swift/20250402.html",
    "title": "SwiftUI 中的@State、@Bindable和@Binding",
    "summary": "在 SwiftUI 中，@State、@Bindable 和 @Binding 都用于管理和传递状态，但它们适用于不同的使用场景。\n",
    "content": "在 SwiftUI 中，@State、@Bindable 和 @Binding 都用于管理和传递状态，但它们适用于不同的使用场景。\n1. @State（本地状态） @State 用于管理 视图本地的可变状态，该状态只属于当前视图，并且由 SwiftUI 负责存储和更新。\n特点： 只能用于 结构体（struct）视图，因为 SwiftUI 视图是值类型。\n适用于 视图内部的小型状态，如按钮点击状态、输入框文本等。\n只能在 当前视图 中使用，不能直接传递给子视图。\n示例： struct CounterView: View { @State private var count = 0 // 本地状态 var body: some View { VStack { Text(\u0026#34;计数: \\(count)\u0026#34;) Button(\u0026#34;增加\u0026#34;) { count += 1 // 修改 @State 变量，SwiftUI 重新渲染视图 } } } } 2. @Binding（状态绑定） @Binding 用于 子视图获取父视图的状态，它本身不存储数据，而是引用 外部的状态（通常是 @State）。\n特点： @Binding 不拥有数据，而是对外部数据的引用。\n用于 子视图修改父视图的状态，避免数据复制。\n适用于 控制组件、表单、滑块等需要修改外部状态的视图。\n示例： struct ParentView: View { @State private var isOn = false // 本地状态 var body: some View { ToggleView(isOn: $isOn) // 传递 @Binding } } struct ToggleView: View { @Binding var isOn: Bool // 绑定外部的状态 var body: some View { Toggle(\u0026#34;开关状态\u0026#34;, isOn: $isOn) // 直接修改外部状态 } } @Binding 前面要加 $ 取 绑定值，在子视图内部可直接读写该值。\n3. @Bindable（可绑定的对象）【iOS 17+】 @Bindable 用于绑定 Observable 对象（通常是 ObservableObject），让 SwiftUI 视图可以自动响应对象属性的变化。\n特点： 作用类似 @Binding，但适用于 类对象（Observable）。\n依赖 Observable 协议（iOS 17 引入）。\n适用于 需要双向绑定的复杂数据对象。\n示例（结合 Observable） import SwiftUI @Observable class UserSettings { var username: String = \u0026#34;张三\u0026#34; } struct ContentView: View { @State private var settings = UserSettings() // `@State` 管理对象 var body: some View { EditView(settings: $settings) // 传递 `@Bindable` } } struct EditView: View { @Bindable var settings: UserSettings // 绑定 Observable 对象 var body: some View { TextField(\u0026#34;用户名\u0026#34;, text: $settings.username) // 绑定属性 } } 这里 @Bindable var settings: UserSettings 允许 EditView 直接修改 settings.username，并且 SwiftUI 会自动更新 ContentView。\n对比总结 属性修饰符 数据存储 作用范围 适用场景 @State 视图内部 仅当前视图 视图局部状态 @Binding 外部状态（引用） 子视图 子视图修改父视图状态 @Bindable Observable 对象 子视图 绑定 Observable 类属性，适用于复杂数据 使用建议：\n简单数据（计数、布尔值）：用 @State。\n子视图修改父视图的状态：用 @Binding。\n对象（类）状态 且 多个视图共享：用 @Bindable（iOS 17+）。\niOS 16 及以下，用 @ObservedObject 代替 @Bindable（结合 ObservableObject）。\n",
    "pubDate": "2025-04-02T10:22:33+08:00"
  }, 
  {
    "objectID": 20250331,
    "url": "https://ichochy.com/posts/blog/20250331.html",
    "title": "免费的图床服务器-GitHub Pages",
    "summary": "介绍一款免费好用的图床服务器，使用GitHub Pages当我们的图床服务器。并配合免费好用的图床图片工具图传软件,分享管理图库。\n",
    "content": "介绍一款免费好用的图床服务器，使用GitHub Pages当我们的图床服务器。并配合免费好用的图床图片工具图传软件,分享管理图库。\nGitHub 创建仓库 点击添加新仓库（New repository） 设置仓库信息 选择用户（Owner）和仓库名称（Repository name），图传配置图库信息会用到。 仓库选择公共的（Public） 开启 Pages 打开设置（Settings） 在创建的仓库中点击设置（Settings） 在设置（Settings）中选择Pages 设置Pages信息 在GitHub Pages中配置信息\n设置部署的分支（Branch）和目录 自定义域名 开启HTTPS 创建Token 打开用户设置（Settings） 打开用户，选择Settings 再选择打开Developer settings 创建Token 打开Personal access tokens 选择Tokens (classic) 点击Generate new token，选择Generate new token (classic) 设置Token 设置Token的有效期（Expiration） 选择权限范围（Select scopes） 开启权限public_repo 保存Token，以后不可见。图传配置图库信息会用到。\n图库管理-图传 图传软件 图传 是一个免费开源的图床图片上传工具。\n是一款为 macOS 打造的原生软件，使用swiftUI开发，支持系统版本为 14+，现已经支持多个图床上传，后续会慢慢完善软件，追加更多所需的图床上传。\n现已支持 Cloudflare R2、GitHub、还用又拍云\n图传软件： https://ichochy.com/posts/app/20250325.html\n图库配置 在图传的设置界面，添加 GitHub配置\n这里会用到上面配置GitHub中出现在的几个信息\nToken Owner Pepo 添加完成后，设置为默认图库，接着就可以将图片上传到默认图库\n上传图片 在上传图库界面，就可以拖入图片，上传到你配置好的GtiHub仓库中\n管理图片 完成图片上传后，就可以查看文件详情，管理和分享图片。\n",
    "pubDate": "2025-03-31T09:25:45+08:00"
  }, 
  {
    "objectID": 20250330,
    "url": "https://ichochy.com/posts/app/20250330.html",
    "title": "iUploader - A Free Native Image Uploading Tool for macOS",
    "summary": "🚀 iUploader: A Native Image Uploading Tool for macOS iUploader is a native image uploading tool designed exclusively for macOS, built with SwiftUI and compatible with macOS 14+. It offers an efficient and seamless experience for uploading, sharing, and managing images, with support for multiple cloud storage platforms. More image hosting options will be added in the future to meet diverse needs.\n",
    "content": "🚀 iUploader: A Native Image Uploading Tool for macOS iUploader is a native image uploading tool designed exclusively for macOS, built with SwiftUI and compatible with macOS 14+. It offers an efficient and seamless experience for uploading, sharing, and managing images, with support for multiple cloud storage platforms. More image hosting options will be added in the future to meet diverse needs.\nSupported Platforms:\n✅ Cloudflare R2\n✅ GitHub\n✅ UPYUN\n🌟 Key Features Drag-and-Drop Upload: Batch upload images effortlessly Menu Bar Access: Quick uploads from anywhere Real-Time Progress: Track upload status instantly Local Compression: Optimize image size automatically Flexible Sharing: Supports Markdown, HTML, URL, and more Multi-Library Management: Switch between storage spaces with ease Multilingual Support: Designed for global users 🖥️ Interface Preview 📁 Library Settings Configure cloud storage and manage multiple libraries\n🎨 Format Settings Customize compression and sharing formats\n📷 Upload Management Intuitive resource display, drag-and-drop support, and detailed progress tracking\n🛠️ Installation Guide ⚠️ Note: As the app is not signed with a developer account, macOS will display a security warning on first launch.\n📌 Steps to Resolve:\nOpen the app; when prompted, click \u0026ldquo;Done\u0026rdquo;\nGo to System Settings \u0026gt; Privacy \u0026amp; Security, and select \u0026ldquo;Open Anyway\u0026rdquo;\nConfirm \u0026ldquo;Open Anyway\u0026rdquo; to launch the app successfully\n📌 First Use: Open Settings, configure your default library, and start uploading!\n📥 Download 📌 iUploader Download: https://file.ichochy.com/iUploader.zip\nStay tuned for continuous updates and exciting new features! 🎉\n",
    "pubDate": "2025-03-30T10:22:36+08:00"
  }, 
  {
    "objectID": 20250325,
    "url": "https://ichochy.com/posts/blog/20250325.html",
    "title": "免费的图床服务器-Cloudflare-R2",
    "summary": "介绍一款免费好用的图床服务器，每月有10GB的存储额度。并配合免费好用的图床图片工具图传软件,分享管理图库。\n",
    "content": "介绍一款免费好用的图床服务器，每月有10GB的存储额度。并配合免费好用的图床图片工具图传软件,分享管理图库。\nCloudflare-R2 开通 R2 在菜单中找到R2对象存储\n点击打开，第一次开通需要绑卡设置\n开通R2，选择免费套餐，每月10GB存储\n创建桶 开通R2后，开始设置一个桶，点击创建存储桶\n创建存储桶，选择位置和类型\n自定义域名 桶创建完成后，就可以自定义域名，通过域名访问资源\n在桶的详情页面，点击设置，来设置桶的信息\n在桶的设置页面，自定义域，点击连接域 添加自定义域，添加自己要绑定的域名 添加后，点击连接域，将域名和桶连接配对\n这样就完成桶的自定义域设置，等待系统完成配置，完成后就可以通过域名来访问资源 创建API令牌 接下来，给R2，创建S3 API 令牌，配合图传软件来管理资理\n在 R2 界面，点击API，创建API令牌，点击将R2与API配合使用\n在配合界面，可以看到 Account ID，这个配置图传时会用到\n选择API，用S3兼容API，在下面点击创建API令牌\n进入令牌管理页面，点击创建API令牌\n设置令牌的权限和有效期\n这样令牌就创建好了，在令牌详情页面，可能看到AccessKey和SecretAccessKey\n详情页只显示一次，所以需要将这两个复制下来，接下来配置图传时会用到这两个key\n图库管理-图传 图传软件 图传 是一个免费开源的图床图片上传工具。\n是一款为 macOS 打造的原生软件，使用swiftUI开发，支持系统版本为 14+，现已经支持多个图床上传，后续会慢慢完善软件，追加更多所需的图床上传。\n现已支持 Cloudflare R2、GitHub、还用又拍云\n图传软件： https://ichochy.com/posts/app/20250325.html\n图库配置 在图传的设置界面，添加 Cloudflare R2配置\n这里会用到上面配置R2中出现在的三个key\nAccountID AccessKey SecretAccessKey 添加完成后，设置为默认图库，接着就可以将图片上传到默认图库\n上传图片 在上传图库界面，就可以拖入图片，上传到你配置好的R2桶中\n管理图片 完成图片上传后，就可以查看文件详情，管理和分享图片。\n",
    "pubDate": "2025-03-25T14:25:45+08:00"
  }, 
  {
    "objectID": 20250325,
    "url": "https://ichochy.com/posts/app/20250325.html",
    "title": "图传 (iUploader) - macOS 免费原生图床上传利器",
    "summary": "🚀 图传 (iUploader)\n一款专为 macOS 打造的原生图床上传工具，基于 SwiftUI 开发，兼容 macOS 14+。\n它提供高效、便捷的图片上传、分享与管理体验，支持多种主流云存储平台，未来还将持续扩展更多图床支持。\n",
    "content": "🚀 图传 (iUploader)\n一款专为 macOS 打造的原生图床上传工具，基于 SwiftUI 开发，兼容 macOS 14+。\n它提供高效、便捷的图片上传、分享与管理体验，支持多种主流云存储平台，未来还将持续扩展更多图床支持。\n已支持平台：\n✅ Cloudflare R2\n✅ GitHub\n✅ 又拍云\n🌟 核心功能 拖拽上传：支持批量拖拽，快速上传图片 菜单栏快捷导入：随时随地一键上传 实时进度：上传状态一目了然 本地压缩：自动优化图片大小，节省空间 多样化分享：支持 Markdown、HTML、URL 等格式 多图库管理：轻松切换不同存储空间 多语言支持：适配全球用户需求 🖥️ 界面一览 📁 图库设置 灵活配置云存储，管理多个图库\n🎨 格式设置 自定义压缩选项与分享格式\n📷 上传管理 直观展示资源，支持拖拽，进度可视化\n🛠️ 安装指南 ⚠️ 注意：因未使用开发者签名，首次运行会触发 macOS 安全提示。\n📌 解决步骤：\n打开软件，系统提示警告，点击 “完成”\n前往 系统设置 \u0026gt; 隐私与安全性，选择 “仍要打开”\n确认 “仍要打开”，即可正常运行\n📌 首次使用：进入 设置 配置默认图库，即可开始上传。\n📥 下载链接 📌 图传 (iUploader)下载：https://file.ichochy.com/iUploader.zip\n持续迭代，更多功能敬请期待！ 🎉\n",
    "pubDate": "2025-03-25T10:22:36+08:00"
  }, 
  {
    "objectID": 20250320,
    "url": "https://ichochy.com/posts/blog/20250320.html",
    "title": "本地无法加载托管到Cloudflare中的图片等资源，权限错误403",
    "summary": "在本地写博客时，预览查看时，无法加载托管到Cloudflare域名中的图片资源，提示403，困扰了很久。 今天通过分析，查看日志，找到了根本原因所在。 原来是Cloudflare的安全策略禁止了不安全的访问，返回403\n",
    "content": "在本地写博客时，预览查看时，无法加载托管到Cloudflare域名中的图片资源，提示403，困扰了很久。 今天通过分析，查看日志，找到了根本原因所在。 原来是Cloudflare的安全策略禁止了不安全的访问，返回403\n分析 查看日志 在安全性 -\u0026gt; 分析中查看事件日志\n查看阻止的事件日志\n查看详情 查看详情可以发现是Hotlink保护，阻止了请求，而返回的权限错误403\n日志详情中，记录了当前事件的所有信息。\n解决 关闭Hotlink 在Scarape Shield 菜单中内容中，可以找到Hotlink开关 关闭Hotlink功能后，可以再次测试，本地可否访问\n关闭Hotlink功能后，本地加载访问正常后，就可以确定就是Hotlink安全策略的问题\n至此，可以考虑是否关闭Hotlink功能，下面也可以通过规则解决访问问题\n添加规则 在安全性 -\u0026gt; 安全规则中添加跳过规则\n根据日志详情中的信息，添加合适的规则跳过Hotlink安全策略，同样可以解决访问问题\n",
    "pubDate": "2025-03-20T22:25:45+08:00"
  }, 
  {
    "objectID": 20250226,
    "url": "https://ichochy.com/posts/blog/20250226.html",
    "title": "国内、外免费公共的DNS，支持的DoH，防止污染、篡改的问题",
    "summary": "DNS 的全称为 Domain Name System，简称域名服务器，通过域名查询返回服务器的IP。 DNS的速度和安全至关重要，决定我们访问网站的快慢和安全。\n",
    "content": "DNS 的全称为 Domain Name System，简称域名服务器，通过域名查询返回服务器的IP。 DNS的速度和安全至关重要，决定我们访问网站的快慢和安全。\nDNS DNS over UDP 传统的使用用户数据报协议 (UDP) 发送 DNS 查询的方式。\n工作原理：DNS 查询和响应以轻量级、无连接的数据包形式发送，速度快但不保证送达（无错误纠正）。 端口：通常使用 53 端口。 优点：简单、低开销、广泛支持。 缺点：未加密（易被窃听），容易受到伪造或中间人攻击，数据包大小受限（较大响应可能切换到 TCP）。 DNS over TLS (DoT) 使用传输层安全协议 (TLS) 加密 DNS 查询，通过专用的 TCP 连接发送。\n工作原理：将 DNS 流量封装在 TLS 中以确保隐私和完整性，使用 853 端口。 优点：加密（防止窃听），验证服务器身份，防止篡改。 缺点：由于 TLS 握手，延迟稍高，需要 TCP（比 UDP 开销大）。 使用场景：适合注重隐私的应用或网络。 DNS over HTTPS (DoH) 将 DNS 查询封装在 HTTPS 流量中，利用现有的网页加密技术。\n工作原理：通过 443 端口（标准 HTTPS 端口）将 DNS 请求发送到支持 DoH 的解析器，看起来像普通网页流量。 优点：加密，与 HTTPS 流量混合（难以拦截或检测），浏览器支持广泛（如 Firefox、Chrome）。 缺点：集中式解析器（如 Cloudflare、Google）可能引发隐私担忧，开销略高于 UDP。 使用场景：适合绕过审查或在受限网络中使用。 DNS over QUIC (DoQ) 通过 QUIC（基于 UDP 的现代协议）发送加密的 DNS 查询。\n工作原理：结合 UDP 的速度和类似 TLS 的安全性，通常使用 853 端口（实验性实现可能不同）。 优点：加密，比基于 TCP 的方法延迟低（无握手延迟），抗丢包。 缺点：仍在发展中，支持度不如 DoT 或 DoH，需要兼容的客户端和服务器。 使用场景：为未来的 DNS 提供性能与安全性的平衡。 DNS的选择 UDP是传统的默认方式，容易篡改，缺乏安全性。 DoT和DoH是当前隐私保护的主流选择。DoH 因融入 HTTPS 更隐蔽，DoT默认端口853，特征明显。 DoQ是未来趋势，兼顾速度与安全性，但尚未完全普及。 国内公共DNS 腾讯云 DNS Public DNS 凭借 DNSPod 多年的域名解析服务经验开发，并依托于腾讯云强大的资源优势，旨在为用户提供更加快速、准确、稳定的递归解析服务，且我们不会对任何域名进行恶意劫持。\nIPv4：119.29.29.29 IPv6：2402:4e00:: DoH：https://doh.pub/dns-query DoT：tls://dot.pub DoH(国密)：https://sm2.doh.pub/dns-query 服务地址：https://www.dnspod.cn/products/publicdns\n阿里云公共 DNS 阿里云公共DNS提供稳定、安全、精准、快速的公网递归解析服务，支持HTTP/HTTPS（DoH/DoT）等协议。使用阿里云公共DNS后，可替代使用传统LocalDNS解析服务，避免发生 域名被劫持、解析速度慢、解析变更不生效 等问题，\nIPv4：223.5.5.5, 223.6.6.6 IPv6：2400:3200::1, 2400:3200:baba::1 DoH：https://dns.alidns.com/dns-query DoT：tls://dns.alidns.com 服务地址：https://alidns.com/\nOneDNS OneDNS 互联网安全接入服务是北京微步在线科技有限公司提供的具备安全防护能力的 DNS 递归解析服务，该服务可以保护任何一台终端、任何一个办公职场、任何一个家庭均可安全地接 入到互联网，为企业和家庭用户有效防护：恶意软件、勒索病毒、APT 攻击、钓鱼链接、非法站点。并且屏蔽各类广告骚扰和欺诈类网站，净化网络环境，保护数据安全。\n# 纯净版 IPv4：117.50.10.10 / 52.80.52.52 DoH：https://doh-pure.onedns.net/dns-query DoT：tls://dot.onedns.net # 拦截版 IPv4：117.50.11.11 / 52.80.66.66 DoH：https://doh.onedns.net/dns-query DoT：tls://dot.onedns.net # 家庭版 IPv4：117.50.60.30 / 52.80.60.30 服务地址：https://onedns.net/personal\n国外 DNS 服务 Google Google 是最早推出免费DNS服务的平台。谷歌DNS它们易于记忆，并且每个人都可以使用。谷歌DNS的主要优势来自他们作为一家公司的声誉。谷歌每年收入极多，有能力提供最稳定和更有弹性的DNS服务器。这个DNS服务器的唯一问题是它们存储有关您的运营的信息，如果美国政府决定需要这些信息，它们可以与第三方共享，Google通常被认为是最好的DNS服务器。\nIPv4：8.8.8.8,8.8.4.4 IPv6：2001:4860:4860::8888,2001:4860:4860::8844 DoH：https://dns.google/dns-query DoT：tls://dns.google 服务地址：https://dns.google/\nCloudflare 1.1.1.1 是由 Cloudflare 运营的公共 DNS 解析器，它提供了一种快速且私密的方式来浏览互联网。与大多数 DNS 解析器不同，1.1.1.1 不会将用户数据出售给广告商。此外，在经过测量后，1.1.1.1 被认为是可用的最快 DNS 解析器。\nIPv4：1.1.1.1, 1.0.0.1 IPv6：2606:4700:4700::1111, 2606:4700:4700::1001 DoH：https://cloudflare-dns.com/dns-query DoT：tls://cloudflare-dns.com Block malware IPv4：1.1.1.2, 1.0.0.2 IPv6：2606:4700:4700::1112, 2606:4700:4700::1002 DoH：https://security.cloudflare-dns.com/dns-query DoT：tls://security.cloudflare-dns.com Block malware and adult content IPv4：1.1.1.3, 1.0.0.3 IPv6：2606:4700:4700::1113, 2606:4700:4700::1003 DoH：https://family.cloudflare-dns.com/dns-query DoT：tls://family.cloudflare-dns.com 服务地址：https://one.one.one.one/dns/\n什么是 Cloudflare WARP？ WARP 是基于 1.1.1.1 构建的可选应用。WARP 在个人设备（如计算机和智能手机）和您在互联网上访问的服务之间建立安全连接。1.1.1.1 仅保护 DNS 查询，而 WARP 保护来自您设备的所有流量。\nWARP Client：https://one.one.one.one\nQuad9 Quad9 DNS 服务由总部位于瑞士的 Quad9 基金会运营，其使命是为每个人提供更安全、更强大的互联网。\nIPv4：9.9.9.9,149.112.112.112 IPv6：2620:fe::fe,2620:fe::9 DoH：https://dns.quad9.net/dns-query DoT：tls://dns.quad9.net # Unsecured IPv4：9.9.9.10,149.112.112.10 IPv6：2620:fe::10,2620:fe::10 DoH：https://dns10.quad9.net/dns-query DoT：tls://dns10.quad9.net # Secured IPv4：9.9.9.11,149.112.112.11 IPv6：2620:fe::11,2620:fe::11 DoH：https://dns11.quad9.net/dns-query DoT：tls://dns11.quad9.net 服务地址：https://www.quad9.net/\nYandex Yandex DNS 服务器，使您能快速打开网站。提供阻止成人网站和危险网站，服务完全免费。\nIPv4：77.88.8.8,77.88.8.1 IPv6：2a02:6b8::feed:0ff,2a02:6b8:0:1::feed:0ff DoH：https://common.dot.dns.yandex.net/dns-query DoT：tls://common.dot.dns.yandex.net # Safe IPv4：77.88.8.88,77.88.8.2 IPv6：2a02:6b8::feed:bad,2a02:6b8:0:1::feed:bad DoH：https://safe.dot.dns.yandex.net/dns-query DoT：tls://safe.dot.dns.yandex.net # Family IPv4：77.88.8.7,77.88.8.3 IPv6：2a02:6b8::feed:a11,2a02:6b8:0:1::feed:a11 DoH：https://family.dot.dns.yandex.net/dns-query DoT：tls://family.dot.dns.yandex.net 服务地址：https://dns.yandex.com\n总结 国内用户，推荐大家使用腾讯云、阿里云的公共DNS，作为云服务器大厂，公共DNS安全、速度、可用性有保障。\n国际用户，选 Cloudflare 的公共DNS服务，在速度和隐私方面都做的很好。\n有条件还是使用 DoH 的方式，不会有污染、篡改的问题，保障安全和隐私。\n",
    "pubDate": "2025-02-26T19:22:45+08:00"
  }, 
  {
    "objectID": 20250220,
    "url": "https://ichochy.com/posts/mac/20250220.html",
    "title": "macOS 系统下载和安装",
    "summary": "在线下载你想要的系统版本。如果是系统新版本更新，可以直接下载安装更新系统；但是如果是系统旧版本回退或重装，则需创建可引导安装器到U盘，通过引导安装器重装系统。\n",
    "content": "在线下载你想要的系统版本。如果是系统新版本更新，可以直接下载安装更新系统；但是如果是系统旧版本回退或重装，则需创建可引导安装器到U盘，通过引导安装器重装系统。\nmacOS 系统下载 App Store 下载 新版的 macOS 可以直接在 App Store 中下载\nSequoia 15：macappstores://apps.apple.com/cn/app/macos-sequoia/id6596773750?mt=12\nSonoma 14：macappstores://apps.apple.com/cn/app/macos-sonoma/id6450717509?mt=12\nVentura 13：macappstores://apps.apple.com/cn/app/macos-ventura/id1638787999?mt=12\nMonterey 12：macappstores://apps.apple.com/cn/app/macos-monterey/id1576738294?mt=12\nBig Sur 11：macappstores://apps.apple.com/cn/app/macos-big-sur/id1526878132?mt=12\nCatalina 10.15：macappstores://apps.apple.com/cn/app/macos-catalina/id1466841314?mt=12\nMojave 10.14：macappstores://apps.apple.com/cn/app/macos-mojave/id1398502828?mt=12\nHigh Sierra 10.13：macappstores://apps.apple.com/cn/app/macos-high-sierra/id1246284741?mt=12\n网页在线下载 旧版的 macOS 可以直接网页在线下载\nSierra 10.12：http://updates-http.cdn-apple.com/2019/cert/061-39476-20191023-48f365f4-0015-4c41-9f44-39d3d2aca067/InstallOS.dmg\nEl Capitan 10.11：http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg\nYosemite 10.10：http://updates-http.cdn-apple.com/2019/cert/061-41343-20191023-02465f92-3ab5-4c92-bfe2-b725447a070d/InstallMacOSX.dmg\nMountain Lion 10.8：https://updates.cdn-apple.com/2021/macos/031-0627-20210614-90D11F33-1A65-42DD-BBEA-E1D9F43A6B3F/InstallMacOSX.dmg\nLion 10.7：https://updates.cdn-apple.com/2021/macos/041-7683-20210614-E610947E-C7CE-46EB-8860-D26D71F0D3EA/InstallMacOSX.dmg\n创建可引导安装器 准备U盘 准备一个大小在16GB-32GB的空U盘，创建引导安装器会格式掉U盘数据，注意备份。\n加载 macOS 系统文件 双击下载好的 macOS 系统文件，将系统文件加载，做好创建准备。\n使用”终端“创建引导安装器 插入U盘，确认 USB 闪存驱动器名，创建命令时需要替换为自己的驱动器名。 如不知道 USB 闪存驱动器名，可以在“磁盘工具“中查看U盘的挂载点。 不同的版本的系统，创建引导安装器的命令有所不同，注意区分。 注：将命令最后的MyVolume改为自己的 USB 闪存驱动器名\nSequoia\nsudo /Applications/Install\\ macOS\\ Sequoia.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Sonoma\nsudo /Applications/Install\\ macOS\\ Sonoma.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Ventura\nsudo /Applications/Install\\ macOS\\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Monterey\nsudo /Applications/Install\\ macOS\\ Monterey.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Big Sur\nsudo /Applications/Install\\ macOS\\ Big\\ Sur.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Catalina\nsudo /Applications/Install\\ macOS\\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume Mojave\nsudo /Applications/Install\\ macOS\\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume High Sierra\nsudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume El Capitan\nsudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app 例：macOS Ventura 操作如下：\n# 输入命令，注 MyVolume 替换为自己的 USB 闪存驱动器名 iChochy@MacBook-Pro ~ % sudo /Applications/Install\\ macOS\\ Ventura.app/Contents /Resources/createinstallmedia --volume /Volumes/MyVolume # 输入系统密码 Password: Ready to start. # 确认清理U盘，输入 Y To continue we need to erase the volume at /Volumes/MyVolume. If you wish to continue type (Y) then press return: Y # 开始创建，等待进度完成 Erasing disk: 0%... 10%... 20%... 30%... 100% Makingdiskbootable... Copying to disk: 0%... 10%... 20%... 30%... 40%... 50%... 100% Install media now available at \u0026#34;/Volumes/Install macOS Ventura\u0026#34; iChochy@MacBook-Pro ~ % 使用可引导安装器 Intel Mac 搭载 Intel 芯片的 Mac\n开始之前： 这台 Mac 必须与你要安装的 macOS 兼容。如果不兼容，它可能会在启动时显示一个由直线穿过的圆圈。 这台 Mac 必须能够接入互联网。可引导的安装器不会下载 macOS，但它确实需要互联网连接来获取这个 Mac 机型的固件和其他信息。 将 Mac 关机或关闭 Mac 电源。 将U盘可引导的安装器连接到 Mac。 将 Mac 开机，并立即按住 Option (Alt) 键。 当你看到显示可引导宗卷（包含可引导的安装器）的黑屏时，松开 Option 键。 选择可引导的安装器。然后点按屏幕上的箭头或按下 Return 键。 如果你使用的是搭载 Apple T2 安全芯片的 Mac 电脑且你无法从可引导的安装器启动，请确保“启动安全性实用工具”已设为允许从外部或可移动介质启动。 根据提示选取你的语言。 从“实用工具”窗口中选择“安装 macOS”（或“安装 OS X”），然后点按“继续”，并按照屏幕上的说明进行操作。 Apple M Mac 搭载 Apple 芯片的 Mac\n开始之前： 这台 Mac 必须与你要安装的 macOS 兼容。如果不兼容，它可能会在启动时显示一个由直线穿过的圆圈。 这台 Mac 必须能够接入互联网。可引导的安装器不会下载 macOS，但它确实需要互联网连接来获取这个 Mac 机型的固件和其他信息。 将 Mac 关机或关闭 Mac 电源。 将U盘可引导的安装器连接到 Mac。 将 Mac 开机并继续按住电源按钮，直到你看到启动选项窗口，它会显示可引导的宗卷，其中包含可引导的安装器。 选择可引导的安装器，然后点按“继续”。 macOS 安装器打开后，请按照屏幕上的说明操作。 总结 上面提供了官方的系统下载地址，可以方便直接下载到本址备份，使用终端命令创建系统引导盘到U盘。随后可以通过U盘来引导安装新的系统。注意不同版本使用的命令有所不同，构建时要仔细区分。\n引用 https://support.apple.com/zh-cn/102662\n",
    "pubDate": "2025-02-20T10:42:45+08:00"
  }, 
  {
    "objectID": 20241001,
    "url": "https://ichochy.com/posts/shell/20241001.html",
    "title": "使用 CURL 命令调试和诊断网络问题，网站请求测速",
    "summary": "curl 是一个命令行工具，用于在网络上发送和接收数据。它支持多种协议，包括 HTTP、HTTPS、FTP、SFTP 等，广泛应用于 Web 开发、API 测试和网络调试。\n",
    "content": "curl 是一个命令行工具，用于在网络上发送和接收数据。它支持多种协议，包括 HTTP、HTTPS、FTP、SFTP 等，广泛应用于 Web 开发、API 测试和网络调试。\n使用场景 API 测试：可以用于测试 RESTful API 的请求和响应。 文件传输：适合进行文件的下载和上传操作。 网络调试：用于调试和诊断网络问题，查看请求和响应的详细信息。 自动化脚本：可以在脚本中使用，以自动化与服务器的交互。 执行过程： curl https://ichochy.com 创建请求： 使用 curl 命令行工具，指定请求类型（如 GET、POST），URL 和其他必要参数。 DNS 解析： curl 会将 URL 中的域名解析为 IP 地址。 建立连接： 使用 TCP/IP 协议与服务器建立连接。对于 HTTPS 请求，还会进行 SSL/TLS 握手以确保安全。 发送请求： 将构造的请求头和请求体发送到服务器。 等待响应： 服务器处理请求，并返回响应数据。 接收响应： curl 接收响应，包括状态码、响应头和响应体。 显示结果： 默认情况下，curl 会在终端显示响应内容。 可以使用选项将其保存到文件或进行其他处理。 常用选项 -X：指定请求方法（GET、POST、PUT、DELETE 等）。 -H：添加自定义请求头。 -d：发送数据（通常用于 POST 请求）。 -F：以表单格式发送数据（用于文件上传）。 -o：将响应输出到指定文件。 -s：静默模式，不显示进度或错误信息。 -v：详细模式，显示请求和响应的详细信息。 -u：提供基本身份验证的用户名和密码。 \u0026ndash;data-urlencode：对数据进行 URL 编码。 -L：跟随重定向。 \u0026ndash;max-time：设置最大请求时间。 -x：设置代理服务器。 -k：允许不安全的 SSL 连接（跳过证书验证）。 curl -w 支持多种变量，可以用来获取详细的请求信息。\n以下是一些常用的变量：\n时间相关：\n%{time_namelookup}：DNS 查询时间 %{time_connect}：建立 TCP 连接的时间 %{time_appconnect}：SSL/TLS 握手时间 %{time_pretransfer}：准备传输的时间 %{time_starttransfer}：从请求开始到接收到第一个字节的时间 %{time_total}：总时间 传输相关：\n%{size_download}：下载的字节数 %{size_upload}：上传的字节数 %{speed_download}：下载速度（字节/秒） %{speed_upload}：上传速度（字节/秒） 状态和信息：\n%{http_code}：HTTP 状态码 %{url_effective}：实际请求的 URL %{redirect_count}：重定向次数 %{num_connects}：连接次数 连接信息：\n%{remote_ip}：远程服务器的 IP 地址 %{local_ip}：本地 IP 地址 其他：\n%{content_type}：响应内容类型 %{header_size}：响应头大小 示例 curl -o /dev/null -s -w \u0026#34;HTTP Status: %{http_code}\\nTotal Time: %{time_total} seconds\\n\u0026#34; https://ichochy.com 参数说明 -o /dev/null：将响应体输出到 /dev/null，即不显示内容。 -s：静默模式，不显示进度或错误信息。 -w：格式化输出，包括 HTTP 状态码和请求的总时间。 网站请求测速 测速脚本 完整脚本：speedtest.sh\n#! /bin/bash # 网络访问测试 # 通过CURL命令测试网络访问时间 # author: iChochy # site:\thttps://ichochy.com read -p \u0026#34;测速URL（可为空）：\u0026#34; url if [ -z $url ] then url=\u0026#34;https://ichochy.com\u0026#34; fi echo \u0026#34;测速URL：$url\u0026#34; echo \u0026#34;开始测速…………\u0026#34; curl -o /dev/null -s -w time_namelookup:\u0026#34;\\t\u0026#34;%{time_namelookup}\u0026#34;\\n\u0026#34;time_connect:\u0026#34;\\t\\t\u0026#34;%{time_connect}\u0026#34;\\n\u0026#34;time_appconnect:\u0026#34;\\t\u0026#34;%{time_appconnect}\u0026#34;\\n\u0026#34;time_pretransfer:\u0026#34;\\t\u0026#34;%{time_pretransfer}\u0026#34;\\n\u0026#34;time_starttransfer:\u0026#34;\\t\u0026#34;%{time_starttransfer}\u0026#34;\\n\u0026#34;time_total:\u0026#34;\\t\\t\u0026#34;%{time_total}\u0026#34;\\n\u0026#34;time_redirect:\u0026#34;\\t\\t\u0026#34;%{time_redirect}\u0026#34;\\n\u0026#34; $url echo \u0026#34;循环测速…………\u0026#34; i=1 while (($i\u0026lt;=5)) do printf \u0026#34;第\u0026#34;$i\u0026#34;次：\u0026#34; curl -o /dev/null -s -w time_connect:\u0026#34;\\t\u0026#34;%{time_connect}\u0026#34;\\t\u0026#34;time_total:\u0026#34;\\t\u0026#34;%{time_total}\u0026#34;\\n\u0026#34; $url let i++ done echo \u0026#34;####################################\u0026#34; echo \u0026#34;字段说明：\u0026#34; echo \u0026#34;time_namelookup \\t# 从开始计算，域名解析完成的耗时\u0026#34; echo \u0026#34;time_connect \\t\\t# 从开始计算，TCP建立完成的耗时\u0026#34; echo \u0026#34;time_appconnect \\t# 从开始计算，应用层握手完成的耗时\u0026#34; echo \u0026#34;time_pretransfer \\t# 从开始计算，准备传输数据的耗时\u0026#34; echo \u0026#34;time_starttransfer \\t# 从开始计算，开始接收数据的耗时\u0026#34; echo \u0026#34;time_total \\t\\t# 从开始记算，完成接收数据的耗时\u0026#34; echo \u0026#34;time_redirect \\t\\t# 重定向的耗时，没有重定向时间为0\u0026#34; 脚本使用 保存脚本为speedtest.sh 在终端中运行脚本 sh ./speediest.sh 查看运行结果 mleo@Mac[mleo]: sh ./speediest.sh 测速URL（可为空）： 测速URL：https://ichochy.com 开始测速………… time_namelookup:\t0.000695 time_connect:\t0.001227 time_appconnect:\t0.614623 time_pretransfer:\t0.614876 time_starttransfer:\t0.968854 time_total:\t0.970281 time_redirect:\t0.000000 循环测速………… 第1次：time_connect:\t0.000799\ttime_total:\t1.136176 第2次：time_connect:\t0.001501\ttime_total:\t0.806167 第3次：time_connect:\t0.001580\ttime_total:\t0.710288 第4次：time_connect:\t0.001136\ttime_total:\t0.612873 第5次：time_connect:\t0.000909\ttime_total:\t0.768882 #################################### 字段说明： time_namelookup # 从开始计算，域名解析完成的耗时 time_connect # 从开始计算，TCP建立完成的耗时 time_appconnect # 从开始计算，应用层握手完成的耗时 time_pretransfer # 从开始计算，准备传输数据的耗时 time_starttransfer # 从开始计算，开始接收数据的耗时 time_total # 从开始记算，完成接收数据的耗时 time_redirect # 重定向的耗时，没有重定向时间为0 总结 curl 是一个强大的命令行工具，用于在网络上发送和接收数据，支持多种协议如 HTTP、HTTPS、FTP 等。\n它允许用户灵活地执行各种请求，包括 GET、POST 等，并能够自定义请求头和数据。\ncurl 适合进行 API 测试、文件传输和网络调试，支持身份验证和 SSL/TLS 加密，适用于多种操作系统。\n通过简单的命令，用户可以轻松与服务器进行交互并获取详细的请求和响应信息。\n",
    "pubDate": "2024-10-01T12:25:45+08:00"
  }, 
  {
    "objectID": 20240925,
    "url": "https://ichochy.com/posts/mac/20240925.html",
    "title": "WARP Beta for macOS  支持新协议 MASQUE",
    "summary": "WARP 是一款免费的应用程序，让您的互联网更安全。\n",
    "content": "WARP 是一款免费的应用程序，让您的互联网更安全。\n软件介绍 WARP 是一款免费的应用程序，让您的互联网更安全。 WARP 建立在同一个网络上，正是这个网络使 1.1.1.1 成为地球上速度最快的 DNS 解析器之一。\n无论您身在何处，与 WARP 的连接都是快速可靠的。\nWARP WARP：1.1.1.1\nWARP 加密设备访问互联网的数据，防止任何人对您进行窥探。\nWARP beta for macOS 下载(Beta)： https://install.appcenter.ms/orgs/cloudflare/apps/1.1.1.1-macos/distribution_groups/beta\n设置协议 MASQUE 终端命令运行 # 设置为MASQUE协议: warp-cli tunnel protocol set MASQUE # 查看当前设置的协议: warp-cli settings | grep protocol ",
    "pubDate": "2024-09-25T09:52:45+08:00"
  }, 
  {
    "objectID": 20240920,
    "url": "https://ichochy.com/posts/vps/20240920.html",
    "title": "2024年自用国外靠谱的 VPS 服务器推荐",
    "summary": "VPS VPS 服务器可以自主搭建网络服务、个人博客、企业官网、外贸独立站、技术站点等。\n",
    "content": "VPS VPS 服务器可以自主搭建网络服务、个人博客、企业官网、外贸独立站、技术站点等。\nLightNode LightNode 成立于2002年，目前拥有员工500余人。\nLightNode 自主研发并提供计算、存储、网络和安全等企业必需的基础IT架构资源。依托于自主知识产权的管理平台，为客户提供混合云计算服务和云上运维管理服务。\nLightNode 崇尚“技术驱动产品，运维驱动服务”的理念，不断推出适合行业特性的产品和服务。\n目前，LightNode已为大量游戏、电商、金融、泛娱乐、企事业等方向的IT部署服务，提供了解决方案与混合云服务。\n服务商介绍 全球节点 包含20多个全球节点，其中东南亚及中东地区超过15个节点。\n重点部署东南亚地区，包含美国硅谷、美国华盛顿、德国法兰克福、土耳其、沙特阿拉伯、阿联酋、柬埔寨、菲利宾、马来西亚、泰国、越南河内、越南胡志明、中国香港、中国台湾、韩国、日本等节点.\n一键部署 一键安装部署，可自由选择系统、应用镜像或已有的自定义镜像创建主机\n计费粒度小 所有的产品及服务都是按照小时收费，不足$0.012/小时\n完全资源控制 实例权限全放开，端口仅限制 25 端口\n多地区选择，遍布全世界 服务器特点和优势 服务器包含大多数的东南亚国家，原始 IP 在线。\n服务器实例可以随时新建和注销，费用按小时结算，不足$0.012/小时。 服务器费用低廉，低至 $7.71/月 （约 50元/月）。 服务器资源可以根据需求自定义配置，自选系统，支持 Windows 和 Linux。\n服务器网络可以根据实际选择按流量（1000GB）和带宽。 服务器 IP 可以在线免费修改二次，可以重开新实例获得新 IP 的操作。\n服务器网络主要为国际路线，国内访问速度一般，可以通过其它高速的服务器进行中转。\n服务商推荐 通过推荐推荐地址注册会有95优惠，首充赠送礼金\nLightNode: https://www.lightnode.com/\n推荐地址：https://www.lightnode.com/?inviteCode=JJI33F\u0026amp;promoteWay=LINK\nFAQ LightNode首充赠送金是什么？ 首充赠送金是LightNode给予用户的福利，充的越多送的越多，用户最高可获得15美元的赠送金。\nLightNode系统盘需要单独选择吗？ 不需要单独选择，每台VPS主机，LightNode都为你配备了50G的系统盘。\nLightNode有哪些资源节点？ LightNode节点包含美国硅谷、美国华盛顿、德国法兰克福、土耳其、沙特阿拉伯、阿联酋、泰国、柬埔寨、越南河内、越南胡志明、中国香港、中国台湾、韩国、日本等节点，重点部署东南亚地区。\nLightNode支持哪些操作系统？ 系统镜像支持多版本Windows、多种Linux系统（Centos、Ubuntu、Debian等）；应用镜像支持Wordpress等镜像。\nLightNode的计费规则是怎样的？ LightNode目前主机是按量计费的后付费模式，按小时进行出账结算（不满一小时按照一小时计算），每个自然月只计费672小时（即28天），超出672小时，不进行出账。\nMegalayer Megalayer 致力于成为全球电信增值服务提供商，为用户在全球范围内提供优质、稳定的互联网服务，目前已经在香港、新加坡、菲律宾、美国等地区部署节点，并且将继续在东南亚地区进行战略布局，提升资源优势以及市场优势。\n资费 特价 VPS，最低24元/月 VPS 年资费，最低16.5元/月 服务器地区 香港、新加坡、菲律宾、美国等多个地区 服务器特点和优势 服务器可以月付，低至24元/月。\n服务器可以年付199元/年，低至16。5元/月。\n服务器有香港CN2优化线路，低延迟，国内访问首选。\n服务器还支持多种优化线路，极低延迟访问，没有丢包问题。\n服务器系统可以选择 Windows 和 Linux ，可以自定义硬件配置和网络带宽。\n服务器支持银联云闪付等其它多种支付方式购买。\n服务器网络测速 优化带宽: 154.55.128.254\n全向带宽: 154.39.240.254\n国际带宽: 154.39.247.254\n2024 VPS 优惠码 2024 限时半折优惠码 2024 VPS 优惠码：VPS2024-50%OFF\n优惠码使用 服务器推荐 在线推荐有优惠哦\nMegalayer 服务商：https://www.megalayer.net/\n推荐地址：https://account.megalayer.net/aff.php?aff=1678\n购买说明 注：注册登录后可以看到特价VPS\nCloudCone CloudCone 诞生于 Quadcone 的灵感和成功。Quadcone是在2012年推出的。它在四年多的时间里不断发展壮大，赢得了忠实的客户，并改进了最初的云产品。服务器位于美国。\n机型 虚拟主机 - 推荐个人博主使用 可扩主机 - 建议小型企业使用 专业主机 - 专业大型企业使用 每种机型的的性能有所不一样，服务体验也大有区别。可以更根据自己的需求选择，价格也有所差异\n服务器地区 服务商位于美国本土，主营于美国各个州\n服务器特点和优势 服务器可以月付、年付，常年有活动，低于15/月.\n服务器线路优化，低延迟访问，没有丢包问题。\n服务器系统可以选择 Windows 和 Linux ，可以自定义硬件配置和网络带宽。\n服务器支持支付宝、信用卡、Paypal等其它多种方式购买。\n服务器推荐 在线推荐有优惠哦\n服务商推荐地址：https://app.cloudcone.com.cn/\n月付12元推荐地址：https://app.cloudcone.com.cn/compute/1393/create?ref=11052\u0026amp;token=hashtag-2023-sc2-1\n最新活动年付120元推荐地址：https://app.cloudcone.com.cn/vps/241/create?ref=11052\u0026amp;token=easter-24-1 购买说明 优惠机器可能超卖，没有货源。\n登录后可以查看消息，关注最新优惠活动。\n服务商地址：https://app.cloudcone.com.cn/ 注： 请先注册登陆后购买参与优惠活动\n",
    "pubDate": "2024-09-20T16:25:45+08:00"
  }, 
  {
    "objectID": 20240620,
    "url": "https://ichochy.com/posts/mac/20240620.html",
    "title": "使用 OpenCore，让你的旧 Mac 用上最新的 macOS 系统",
    "summary": "今天介绍一款开源软件，可以突破官方的限制，通过打补丁的形式，用上最新的 macOS 系统。\n我大学时的 Macbook Pro 现在还在用，因硬件系统限制，macOS 系统无法更新，有很多的软件都不再支持，没法继续在用下去了。\n现在通过 OpenCore 软件，将旧 Mac 电脑升级新的 macOS 系统。\n",
    "content": "今天介绍一款开源软件，可以突破官方的限制，通过打补丁的形式，用上最新的 macOS 系统。\n我大学时的 Macbook Pro 现在还在用，因硬件系统限制，macOS 系统无法更新，有很多的软件都不再支持，没法继续在用下去了。\n现在通过 OpenCore 软件，将旧 Mac 电脑升级新的 macOS 系统。\n软件介绍 OpenCore OpenCore 是一个“引导加载程序”，使其 X86 硬件模拟 Mac 环境来安装 macOS 系统。为 macOS 注入数据和驱动引导，例如 SMBIOS、ACPI 表和 kext等。设计考虑安全性和质量，使我们能够使用真实 Mac 上的许多安全功能，例如系统完整性保护和 FileVault等。\nOpenCore Legacy Patcher OpenCore Legacy Patcher 是一个用于旧版 Mac 电脑的补丁程序，让你的旧 Mac 电脑像以前一样体验新的 macOS 系统。\nOpenCore Legacy Patcher是一个复杂的引导加载程序，用于在内存中而不是磁盘上注入和修补数据。这意味着我们能够在许多不受支持的 Mac 上实现近乎原生的体验。\nOpenCore Legacy Patcher 下载 OpenCore Legacy Patcher GitHub： https://github.com/dortania/OpenCore-Legacy-Patcher/\nOpenCore Legacy Patcher 最新版本：https://github.com/dortania/OpenCore-Legacy-Patcher/releases\nOpenCore Patcher(1.5.0)：https://github.com/dortania/OpenCore-Legacy-Patcher/releases/download/1.5.0/OpenCore-Patcher.pkg\n安装 OpenCore Patcher 将OpenCore Patcher下载到本地后，直接打开进行安装，按照提示步完成安装，跟常用软件安装一样简单。\n新 macOS 系统安装 创建系统镜像 打开OpenCore Patcher\n使用OpenCore Patcher，安装 macOS 系统\n点击 Create macOS installer按钮\n选择安装macOS系统的来源，在线下载或使用本地\n系统写入到 U 盘 macOS 系统写入到 U 盘\n选择安装的系统\n选择写入U盘\n系统写入U盘中……\n引导写入到 U 盘 将 OpenCore 引导写入到 U 盘\n点击Build and Install OpenCore按钮\nOpenCore 写入到 U 盘，请选择 U 盘 OpenCore 写入中……\n安装 macOS 系统 重启电脑，选择 OpenCore 引导\n安装 macOS 系统。\n经历几次重启后，直接进入新系统的设置引导界面，完成初始化设置。\n注:跟全新安装系统一样，没有过多的额外操作。\n重装 OpenCore Patcher 安装 OpenCore Patcher 进入新系统后，重新安装 OpenCore Patcher。\n安装驱动补丁包。 使用 OpenCore Patcher 安装驱动补丁包。\n点击Post-Install Root Patch按钮\n安装补丁包，安装缺损的驱动补丁包，让系统完美运行 引导写入到本地硬盘 OpenCore 引导写入到本地硬盘（脱离 U 盘启动系统）\n点击Build and Install OpenCore按钮\nOpenCore 写入到本地硬盘，请选择本地硬盘 OpenCore 写入中……\n重启电脑，结束系统安装，现在可以享用你的新的 macOS 系统。\n总结：可以看到，使用OpenCore Patcher，突破原有的官方限制，可以轻松的在旧 Mac 电脑上用新的 macOS 系统。\n但其中也有一些问题，比如系统没有以前流畅，有个别硬件不兼容或无法适配，少数功能无法正常使用。\n需要一些取舍和付出，看自己如何抉择。\n",
    "pubDate": "2024-06-20T18:52:45+08:00"
  }, 
  {
    "objectID": 20240520,
    "url": "https://ichochy.com/posts/mac/20240520.html",
    "title": "给 Terminal 终端添加不一样的色彩，安装插件实现自动补全、高亮显示",
    "summary": "给我们的 Terminal 终端添加不一样的色彩，高亮显示，让其直观、简洁显示不同的文件类型、常用的命令\n",
    "content": "给我们的 Terminal 终端添加不一样的色彩，高亮显示，让其直观、简洁显示不同的文件类型、常用的命令\n文件目录自动补全 很多时候会遇到因大小字母文件目录的问题无法自动补全，通过简单的配置，实现不区分大小写，自动补全\nvi修改.zshrc配置文件\nvi .zshrc 添加下面的内容\nautoload -Uz compinit \u0026amp;\u0026amp; compinit zstyle \u0026#39;:completion:*\u0026#39; matcher-list \u0026#39;m:{a-z}={A-Z}\u0026#39; 重新加载.zshrc配置文件\nzsh 没有错误信息，则加载成功\n则开启忽略大小限制，直接TAB自动补全\n高亮显示 ls 颜色高亮显示 —G 通过查看帮助可知，参数—G以颜色显示输入\nls -G drwxr-xr-x 6 MLeo staff 192 5 24 11:47 .zsh-users -rw-r--r-- 1 MLeo staff 635 5 24 12:27 .zshrc drwx------@ 7 MLeo staff 224 12 1 08:22 Applications drwxr-xr-x 12 MLeo staff 384 4 4 08:37 Code drwx------@ 5 MLeo staff 160 5 24 12:36 Desktop 添加别名 在zsh中不添加别名，快捷方便使用\nvi修改.zshrc配置文件\nvi .zshrc 添加别名 alisa\nalias ls=\u0026#39;ls -G\u0026#39; 退出编辑后，再次运行 zsh使其重载生效\n再次运行ls，可以看到不同的文件类型显示不同的颜色\n命令颜色高亮显示 手动安装zsh-syntax-highlighting 实现命令颜色高亮\n在用户目录下创建插件安装目录，并进入\n//进入个人用户目录 cd ~ //创建插件安装目录 mkdir .zsh-users //进入插件安装目录 cd .zsh-users git 下载zsh-syntax-highlighting插件\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git 启用插件\necho \u0026#34;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; \u0026gt;\u0026gt; ${ZDOTDIR:-$HOME}/.zshrc 将插件添加到.zshrc文件中\nsource ~/.zsh-users/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 重新加载.zshrc配置文件\nzsh 没有错误信息，则加载成功\n现在运行常用命令就会高亮显示，通常正确的命令会有绿色显示，错误的命令则是红色显示\n命令补全 通过不同的插件实现不同的命令补全功能\n历史命令搜索补全 手动安装zsh-history-substring-search 实现上翻命令获取命令历史补全\n同上\n在用户目录下创建插件安装目录，并进入，如果已经进入无需重复操作\n//进入个人用户目录 cd ~ //创建插件安装目录 mkdir .zsh-users //进入插件安装目录 cd .zsh-users git 下载zsh-history-substring-search插件\ngit clone https://github.com/zsh-users/zsh-history-substring-search.git 启用插件\necho \u0026#34;source ${(q-)PWD}/zsh-history-substring-search/zsh-history-substring-search.zsh\u0026#34; \u0026gt;\u0026gt; ${ZDOTDIR:-$HOME}/.zshrc 将插件添加到.zshrc文件中\nsource ~/.zsh-users/zsh-history-substring-search/zsh-history-substring-search.zsh 重新加载.zshrc配置文件\nzsh 没有错误信息，则加载成功\n实现上下历史记录搜索\n历史命令自动补全 手动安装zsh-autosuggestions 实现历史命令历史自动补全\n同上\n在用户目录下创建插件安装目录，并进入，如果已经进入无需重复操作\n//进入个人用户目录 cd ~ //创建插件安装目录 mkdir .zsh-users //进入插件安装目录 cd .zsh-users git 下载zsh-autosuggestions插件\ngit clone https://github.com/zsh-users/zsh-autosuggestions.git 启用插件\necho \u0026#34;source ${(q-)PWD}/zsh-autosuggestions/zsh-autosuggestions.zsh\u0026#34; \u0026gt;\u0026gt; ${ZDOTDIR:-$HOME}/.zshrc 将插件添加到.zshrc文件中\nsource ~/.zsh-users/zsh-autosuggestions/zsh-autosuggestions.zsh 重新加载.zshrc配置文件\nzsh 没有错误信息，则加载成功\n通过历史记录自动补全命令\n命令参数补全 手动安装zsh-completions 实现命令参数自动补全\n同上\n在用户目录下创建插件安装目录，并进入，如果已经进入无需重复操作\n//进入个人用户目录 cd ~ //创建插件安装目录 mkdir .zsh-users //进入插件安装目录 cd .zsh-users git 下载zsh-completions插件\ngit clone https://github.com/zsh-users/zsh-completions.git 启用插件，将插件添加到.zshrc文件中\nfpath=(path/to/zsh-completions/src $fpath) 强制重建 zcompdump\nrm -f ~/.zcompdump; compinit 没有错误信息，则加载成功\n通过TAB快速查看具体的参数信息\n",
    "pubDate": "2024-05-20T15:22:45+08:00"
  }, 
  {
    "objectID": 20240403,
    "url": "https://ichochy.com/posts/mac/20240403.html",
    "title": "玩转 Mac 截图，分享原生截图工具技巧，自定义截图名称和类型",
    "summary": "Mac 自带的截图工具功能强大，易于使用。不用下载第三方截图工具，特意运行截图软件来截图，自带截图工具随实待命，可以截图标记，裁剪修改。\n",
    "content": "Mac 自带的截图工具功能强大，易于使用。不用下载第三方截图工具，特意运行截图软件来截图，自带截图工具随实待命，可以截图标记，裁剪修改。\n优势： 多种截图模式: 全屏截图：截取整个屏幕的画面。 窗口截图：截取当前活动窗口的画面。 选取截图：自由选择要截取的画面区域。 部分截图：截取屏幕的一部分，并提供多种形状选择。 触控栏截图：使用触控栏截取屏幕画面。 便捷的操作: 使用快捷键快速截取屏幕：\n全屏截图：⌘+Shift+3 选取截图：⌘+Shift+4 窗口截图：⌘+Shift+4 随后按住空格键选择窗口截图 要从截屏中去除窗口的阴影，请在点按时按住 Option 键。 自定义截图：⌘+Shift+5 使用菜单栏选择截图模式，设置截图的选项，截图后，右下角会显示截图，点击可以直接编辑、标记、保存或分享。 强大的编辑功能: 内置图像编辑工具，可以进行裁剪、旋转、调整大小、添加标注等操作。\n可以将截图保存为多种格式，包括 PNG、JPEG、TIFF 等。\n可以直接将截图分享到社交媒体或其他应用。\n与其他应用的整合: 可以将截图直接粘贴到其他应用中，例如 Pages、Keynote、Numbers 等。\n可以将截图作为附件发送电子邮件或消息。\n自定义 自定义保存格式 默认格式为PNG。\n如果希望修改保存格式，可以通过如下命令修改。\n//自定义不同的格式：PNG、JPEG、TIFF defaults write com.apple.screencapture type jpg 自定义保存名称 默认情况下会将截图保存为“截图+日期+时间“格式的名称。 如果希望自定义保存图片名称，可以按照以下步骤操作：\n修改截图名称的名字 打开“终端”应用。\n输入以下命令：\ndefaults write com.apple.screencapture name \u0026#34;自定义名称\u0026#34; 将“自定义名称”替换想要使用的名称。\n例如：改为iChochy\n// 名称为空 defaults write com.apple.screencapture name \u0026#34;\u0026#34; // 名称为：iChochy defaults write com.apple.screencapture name \u0026#34;iChochy\u0026#34; 去掉名称中的日期+时间 //关闭 defaults write com.appe.screencapture \u0026#34;include-date\u0026#34; 0 //开启 defaults write com.appe.screencapture \u0026#34;include-date\u0026#34; 1 现在截图名称就修改成为了：iChochy.png 多张截图，系统会自动为截图名称添加上数字序号\n截图名称将如下所显：\niChochy.png iChochy 1.png iChochy 2.png iChochy 3.png ... iChochy n.png 读取截图工具的相关参数 使用defaults read命令，读取截图工具设置的相关参数\n打开“终端”应用。\n输入以下命令：\n//读取截图所有设置的参数 defaults read com.apple.screencapture //读取截图名称 defaults read com.apple.screencapture name 删除截图工具的相关参数 使用defaults delete命令，删除截图工具设置的相关参数\n打开“终端”应用。\n输入以下命令：\n//删除截图所有的参数 defaults delete com.apple.screencapture //删除截图的参数 name defaults delete com.apple.screencapture name 截图技巧 以下是一些使用 Mac 自带截图工具的技巧：\n按住 Shift 键可以选取截图时保持矩形形状。 按住 Option 键可以选取截图时从中心开始。 按住 Control 键完成截图，可以将截图复制到剪粘板。 使用 ⌘+Shift+5 可以快速调出截图菜单，并选择所需的截图模式。 总体而言，Mac 自带的截图工具是一款功能强大、易于使用且高效的工具，可以满足您的各种截图需求。\n",
    "pubDate": "2024-04-03T15:22:45+08:00"
  }, 
  {
    "objectID": 20240403,
    "url": "https://ichochy.com/posts/vps/20240403.html",
    "title": "美国 VPS 服务器，最低月费只要12元，优惠推荐",
    "summary": "CloudCone 诞生于 Quadcone 的灵感和成功。Quadcone是在2012年推出的。它在四年多的时间里不断发展壮大，赢得了忠实的客户，并改进了最初的云产品。\n",
    "content": "CloudCone 诞生于 Quadcone 的灵感和成功。Quadcone是在2012年推出的。它在四年多的时间里不断发展壮大，赢得了忠实的客户，并改进了最初的云产品。\n机型 虚拟主机 - 推荐个人博主使用 可扩主机 - 建议小型企业使用 专业主机 - 专业大型企业使用 每种机型的的性能有所不一样，服务体验也大有区别。可以更根据自己的需求选择，价格也有所差异\n服务器特点和优势 服务器可以月付，低至12元/月。\n服务器可以年付，低至120元/年。 服务器线路优化，低延迟访问，没有丢包问题。\n服务器系统可以选择 Windows 和 Linux ，可以自定义硬件配置和网络带宽。\n服务器支持支付宝、信用卡、Paypal等其它多种方式购买。\n服务器推荐 在线推荐有优惠哦\n服务商推荐地址：https://app.cloudcone.com.cn/\n月付12元推荐地址：https://app.cloudcone.com.cn/compute/1393/create?ref=11052\u0026amp;token=hashtag-2023-sc2-1\n最新活动年付120元推荐地址：https://app.cloudcone.com.cn/vps/241/create?ref=11052\u0026amp;token=easter-24-1 说明 优惠机器可能超卖，没有货源。\n登录后可以查看消息，关注最新优惠活动。\n服务商地址：https://app.cloudcone.com.cn/ 注： 请先注册登陆后购买参与优惠活动\n",
    "pubDate": "2024-04-02T13:25:45+08:00"
  }, 
  {
    "objectID": 20240402,
    "url": "https://ichochy.com/posts/software/20240402.html",
    "title": "更新 idea 后不能打开文件夹文件，一直加载卡住假死状态",
    "summary": "在 IDEA 中操作打开文件和访问系统文件时，就会出现卡住，一直加载假死状态中，IDEA 界面无法进行任何操作，只能强制退出\n",
    "content": "在 IDEA 中操作打开文件和访问系统文件时，就会出现卡住，一直加载假死状态中，IDEA 界面无法进行任何操作，只能强制退出\n问题 在 IDEA 中打开操作，对系统文件进行访问读取时，卡死假死加载中，不法进行其它的什么任何。\n解决 软件更新，删除重启软件，重启系统，都没有得到解决，貌似前几天都是可以的，怎么就不能操作，软件卡死不可用的状态。 在我无尽的查询中，终于找到了好得解决方案，不知道是软件 Bug，还是系统问题。很多人都遇到了同样的问题。\n方案 下面说说具体操作，完美解决打开系统文件卡死的办法\n找到菜单 帮助 -\u0026gt; 编辑自定义虚拟机选项 添加信息 不使用原生的文件选择界面\n-Dide.mac.file.chooser.native=false 注：\n//macOS -Dide.mac.file.chooser.native=false //Windows -Dide.win.file.chooser.native=false 完美解决 保存退出并重启 IDEA ，完美打开 IDEA 打开系统文件假死的问题\n",
    "pubDate": "2024-04-02T12:22:45+08:00"
  }, 
  {
    "objectID": 20240110,
    "url": "https://ichochy.com/posts/blog/20240110.html",
    "title": "使用 certbot 申请 Let's Encrypt 免费证书，部署到 nginx 中，开启 https",
    "summary": "使用 certbot 可以很方便、快捷的通过 Let\u0026rsquo;s Encrypt 申请免费的证书，并部署到 nginx 中，开启 HTTP。\n",
    "content": "使用 certbot 可以很方便、快捷的通过 Let\u0026rsquo;s Encrypt 申请免费的证书，并部署到 nginx 中，开启 HTTP。\n在 Linux 通过命令安装 安装 Nginx sudo apt install nginx 安装 certbot 先安装 snap sudo apt install snap 再通过 snap 安装 certbot sudo snap install --classic certbot sudo ln -s /snap/bin/certbot /usr/bin/certbot 运行 certbot 给 Nginx 安装证书 sudo certbot --nginx 设置邮箱，输入自己的邮箱 Enter email address (used for urgent renewal and security notices) (Enter \u0026#39;c\u0026#39; to cancel): me@ichochy.com 确认条款 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf. You must agree in order to register with the ACME server. Do you agree? - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (Y)es/(N)o: y 订阅邮件 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Would you be willing, once your first certificate is successfully issued, to share your email address with the Electronic Frontier Foundation, a founding partner of the Let\u0026#39;s Encrypt project and the non-profit organization that develops Certbot? We\u0026#39;d like to send you email about our work encrypting the web, EFF news, campaigns, and ways to support digital freedom. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (Y)es/(N)o: y 签发域名，输入自己的域名 Account registered. Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter \u0026#39;c\u0026#39; to cancel): ichochy.com 证书部署成功 Successfully received certificate. …… Deploying certificate Successfully deployed certificate for ichochy.com to /etc/nginx/sites-enabled/default Congratulations! You have successfully enabled HTTPS on https://ichochy.com 检测 Nginx 证书部署 访问 https://ichochy.com，已经自动跳转到 HTPPS，证书已经成功部署到 Nginx 中，并成功配置并重启成功\nNginx 配置文件 /etc/nginx/sites-enabled/default\n",
    "pubDate": "2024-01-10T14:11:45+08:00"
  }, 
  {
    "objectID": 20240105,
    "url": "https://ichochy.com/posts/vps/20240105.html",
    "title": "菲律宾 VPS 服务器，月均只要16.5元/月，优惠推荐",
    "summary": "Megalayer 致力于成为全球电信增值服务提供商，为用户在全球范围内提供优质、稳定的互联网服务，目前已经在香港、新加坡、菲律宾、美国等地区部署节点，并且将继续在东南亚地区进行战略布局，提升资源优势以及市场优势。\n",
    "content": "Megalayer 致力于成为全球电信增值服务提供商，为用户在全球范围内提供优质、稳定的互联网服务，目前已经在香港、新加坡、菲律宾、美国等地区部署节点，并且将继续在东南亚地区进行战略布局，提升资源优势以及市场优势。\n资费 月资费 特价 VPS VPS 年资费，最低16.5元/月 服务器地区 香港、新加坡、菲律宾、美国 服务器特点和优势 服务器可以月付，低至24元/月。\n服务器可以年付199元/年，低至16。5元/月。\n服务器有香港CN2优化线路，低延迟，国内访问首选。 服务器还支持多种优化线路，极低延迟访问，没有丢包问题。\n服务器系统可以选择 Windows 和 Linux ，可以自定义硬件配置和网络带宽。\n服务器支持银联云闪付等其它多种支付方式购买。\n服务器网络测速 优化带宽: 154.55.128.254\n全向带宽: 154.39.240.254\n国际带宽: 154.39.247.254\n2024 VPS 优惠码 2024 限时半折优惠码 2024 VPS 优惠码：VPS2024-50%OFF\n优惠码使用 服务器推荐 在线推荐有优惠哦\nMegalayer 服务商：https://www.megalayer.net/\n推荐地址：https://account.megalayer.net/aff.php?aff=1678\n说明 注：注册登录后可以看到特价VPS\n",
    "pubDate": "2024-01-05T21:25:45+08:00"
  }, 
  {
    "objectID": 20231128,
    "url": "https://ichochy.com/posts/mac/20231128.html",
    "title": "Mac launchctl 自定义服务启动",
    "summary": "launchd launchd – 系统范围内的守护进程（LaunchDaemons）/代理程序（LaunchAgents）的主程序\n在启动过程中，内核调用 launchd 作为第一个进程运行，并进一步引导系统的其余部分。\n",
    "content": "launchd launchd – 系统范围内的守护进程（LaunchDaemons）/代理程序（LaunchAgents）的主程序\n在启动过程中，内核调用 launchd 作为第一个进程运行，并进一步引导系统的其余部分。\n守护进程和服务启动图例 根据定义，守护进程是系统范围的服务，其中所有客户端都有一个实例。 代理是一种服务，以每个用户为基础运行。\n守护进程不应尝试显示 UI 或直接与用户的登录会话交互。 所有涉及与用户交互地应通过代理服务完成，如：运行程序，显示 UI。\n路径说明 路径 加载 说明 /System/Library/LaunchDaemons 系统启动 提供系统范围的守护进程（Apple） /System/Library/LaunchAgents 系统启动 提供系统范围的用户代理（Apple） /Library/LaunchDaemons 用户登录 提供所有用户的守护进程 /Library/LaunchAgents 用户登录 提供所有用户的代理进程 ~/Library/LaunchAgents 用户登录 提供当前用户的代理进程 更多具体信息查看系统帮助文档：launchd\nlaunchd.plist launchd.plist – 系统范围内的守护进程（LaunchDaemons）/代理程序（LaunchAgents）的配置文件\n可以使用 launchctl 加载到 launchd 的列表，并根据配置文件的具体参数属性进行配置加载运行。\n配置文件的命名 文件命名为 \u0026lt;Label\u0026gt;.plist。 因此，如果您的工作标签（Label）是 com.ichochy.test，您的 plist 文件应命名为：com.ichochy.test.plist\n参数属性 Label 作业进程的唯一标识，是必要参数 Program 作业执行的命令 ProgramArguments 作业执行的参数 第一个参数为作业执行的命令，Program存在时，将由Program替代 从第二个参数开始为执行的参数 KeepAlive 作业进程是否保留运行 false为默认值，停止后不再保留运行 true，停止后再次启动运行 SuccessfulExit NetworkState PathState Crashed RunAtLoad false为默认值，启动加载时不启动运行 true，启动加载时启动运行 WorkingDirectory 工作目录 EnvironmentVariables 配置环境变量 TimeOut 启动超时时间 ExitTimeOut 退出超时时间 ThrottleInterval 间歇时间 StartInterval 间隔启动时间，单位为秒 StartCalendarInterval 间隔启动时间，单位可以指定日期 Minute 分钟 0-59 Hour 小时 0-23 Day 天 1-31 Weekday 工作日 0-7 Month 月 1-12 StandardInPath stdin 输入信息的日志路径 StandardOutPath stdout 输出信息的日志路径 StandardErrorPath stderr 错误输出信息的日志路径 ProcessType 进程类型，根据作业类型限制应用资源 Background Standard Adaptive Interactive plist 实例 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple Computer//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.example\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Program\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/path/tp/example\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;example\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;argv1\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;argv2\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;MachServices\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;com.ichochy.example\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; “Hello World!” launchd Job \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.hello\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;hello\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;world\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Debugging launchd Jobs \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.sleep\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;sleep\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;100\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;StandardOutPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/var/log/myjob.log\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;StandardErrorPath\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;/var/log/myjob.log\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Debug\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;SoftResourceLimits\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Core\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;9223372036854775807\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;HardResourceLimits\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Core\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;9223372036854775807\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Running a Job Periodically \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.touchsomefile\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;touch\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;/tmp/helloworld\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;StartInterval\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;300\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.touchsomefile\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;touch\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;/tmp/helloworld\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;StartCalendarInterval\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Minute\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;45\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;Hour\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;13\u0026lt;/integer\u0026gt; \u0026lt;key\u0026gt;Day\u0026lt;/key\u0026gt; \u0026lt;integer\u0026gt;7\u0026lt;/integer\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Monitoring a Directory \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.watchhostconfig\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;syslog\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-s\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-l\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;notice\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;somebody touched /etc/hostconfig\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;WatchPaths\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/etc/hostconfig\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.ichochy.mailpush\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;my_custom_mail_push_tool\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;QueueDirectories\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/var/spool/mymailqdir\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 更多具体信息查看系统帮助文档：launchd.plist\nlaunchctl launchctl – launchd 的管理工具\n通过 launchctl 交互来管理和检查 launchd 守护进程、代理进程和 XPC 服务。\n命令执行 launchctl subcommand [arguments ...] 显示加载列表 launchctl list 基本操作 # enable | disable launchctl enable com.ichochy.example.plist #启用 plist launchctl disable com.ichochy.example.plist #禁用 plist # load | unload launchctl load com.ichochy.example.plist #加载 plist launchctl unload com.ichochy.example.plist #卸载 plist #加载/卸载 plist， # 参数 w 覆盖操作 # 参数 F 强制操作 launchctl load/unload [-wF] plist # start ｜ stop ｜ remove launchctl start com.ichochy.example #启动 plist launchctl stop com.ichochy.example #停止 plist launchctl remove com.ichochy.example #删除 plist 更多具体信息查看系统帮助文档：launchctl\n查看日志 launchctl操作时，出现错误后，可以查看launchd日志，了解具体的错误信息\n命令查看launchd日志 tail -f /private/var/log/com.apple.xpc.launchd/launchd.log 控制台应用查看launchd日志 在应用程序中的实用工具中找到控制台，并打开 切换到日志报告，找到launchd.log，并打开，就可以查看launchd日志 参考引用 launchd\nlaunchd.plist\nlaunchctl\nhttps://developer.apple.com/\nhttps://www.launchd.info/\n",
    "pubDate": "2023-11-28T16:55:45+08:00"
  }, 
  {
    "objectID": 20231125,
    "url": "https://ichochy.com/posts/mac/20231125.html",
    "title": "Mac 终端设置代理，设置一键开启和取消",
    "summary": "终端配置代理 这里以macOS为例，使用的是zsh，对应的用户配置文件就是~/.zshrc。\n",
    "content": "终端配置代理 这里以macOS为例，使用的是zsh，对应的用户配置文件就是~/.zshrc。\n导入环境变量 将下面信息写入到~/.zshrc文件中\n分别导入 http_proxy、https_proxy、sockes_proxy 三个环竟变量\nexport http_proxy=\u0026#34;http://127.0.0.1/8888\u0026#34; export https_proxy=\u0026#34;http://127.0.0.1/8888\u0026#34; export socks_proxy=\u0026#34;socks://127.0.0.1/8885\u0026#34; 注：根据自己的代理地址配置\n加载配置文件 在终端中运行 source ~/.zshrc，加载配置文件，让其配置生效\n引起注意，说三遍…… 运行 `source` 加载配置文件 运行 `source` 加载配置文件 运行 `source` 加载配置文件 …… 查看环境变量 在终端中运行 env ，查看导入的环境变量是否生效\nTERM_PROGRAM=Apple_Terminal SHELL=/bin/zsh USER=iChochy HOME=/Users/iChochy http_proxy=http://127.0.0.1/8888 https_proxy=http://127.0.0.1/8888 socks_proxy=socks://127.0.0.1/8885 …… 可以看到 http_proxy、https_proxy、sockes_proxy 已经生效了。\n测试 通过 curl 来作测，查看网络访问的情况\ncurl -vI https://ichochy.com * Uses proxy env variable HTTP_PROXY == \u0026#39;http://127.0.0.1:8888\u0026#39; * Trying 127.0.0.1:8888... * Connected to 127.0.0.1 (127.0.0.1) port 8888 (#0) \u0026gt; HEAD http://ichochy.com/ HTTP/1.1 \u0026gt; Host: ichochy.com \u0026gt; User-Agent: curl/8.1.2 \u0026gt; Accept: */* \u0026gt; Proxy-Connection: Keep-Alive …… 可以看到 Trying 127.0.0.1:8888... 通过代理访问网络\n注：curl 参数 v 显示请求详情，I 只显示请求头信息\n通过命令添加、删除代理 在 ~/.zshrc 中设置别名命令\n# 通过 alias 定义别名命令 alias add_proxy=\u0026#39;export ALL_PROXY=http://127.0.0.1:8888\u0026#39; alias un_proxy=\u0026#39;unset ALL_PROXY\u0026#39; 运行 source ~/.zshrc 加载配置文件\n执行 add_proxy 命令添加代理\n执行 un_proxy 命令删除代理\n引起注意，说三遍…… 运行 `source` 加载配置文件 运行 `source` 加载配置文件 运行 `source` 加载配置文件 …… 注：ALL_PROXY 所有网络代理\n通过 ip 来查看当前的外网 IP 在 ~/.zshrc 中通过 alias 定义命令 ip\n# 通过 alias 定义命令 `ip` alias ip=\u0026#34;curl ipinfo.io\u0026#34; 运行 source ~/.zshrc 加载配置文件\n执行 ip 命令查询外网 IP\n# ip { \u0026#34;ip\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;sh\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;sh\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;CN\u0026#34;, \u0026#34;loc\u0026#34;: \u0026#34;88,55\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;CHINANET\u0026#34;, \u0026#34;timezone\u0026#34;: \u0026#34;Asia/Shanghai\u0026#34;, \u0026#34;readme\u0026#34;: \u0026#34;https://ipinfo.io/missingauth\u0026#34; }% 查询IP信息的网站 https://bgp.he.net\nhttps://ipinfo.io\nhttps://ip-api.com\nhttps://whoer.net\n",
    "pubDate": "2023-11-25T11:35:45+08:00"
  }, 
  {
    "objectID": 20231125,
    "url": "https://ichochy.com/posts/software/20231125.html",
    "title": "Nginx 配置(Config)中遇到的错误(Error)",
    "summary": "nginx location 正则错误写法 location 正则的错误的写法 匹配请求目录地址 /555\n",
    "content": "nginx location 正则错误写法 location 正则的错误的写法 匹配请求目录地址 /555\nserver { location ~ ^/\\d{2,3}$ { …… } } 注： 上面的会出现错误 pcre_compile() failed: missing 正则解析失败，正则表达式正常是没有问题的，让人很误解\n但在nginx中不能这样写，需要加上双引号（\u0026quot;\u0026quot;）\nlocation 正则的正确写法，加上双引号 location ~ \u0026#34;^/\\d{2,3}$\u0026#34; 分析正则 location ~ \u0026quot;^/\\d{2,3}$\u0026quot;\n~ 为开启正则匹配，这个不能少 ^ 为字符的开始匹配，字符以后面的规则开始 / 为第一个匹配字符 / \\d 匹配数字 {2,3} 限定数字的个数 2-3 个 $ 为字符的结束匹配，字符以前面的规则结束 注意：中/英文输入法，需要英文符号的双引号（\u0026quot;\u0026quot;）\nnginx 反向代理不能使用变量 server { location ~ \u0026#34;^/(\\d{2,3})$\u0026#34; { proxy_pass https://$1.ichochy.com …… } } 问题来了 上面的配置没有生效，总是报错\nWeb 访问出现 502 Bad Gateway 错误，nginx 报错\n当 proxy_pass 使用变量时会出现没有解析器解析域名的错误\n日志出现如下的错误: no resolver defined to resolve ichochy.com 修正错误 没有解析器就给它指定一个\nresolver 8.8.8.8; 完整的配置信息 server{ location ~ \u0026#34;^/(\\d{2,3})$\u0026#34; { resolver 8.8.8.8; proxy_pass https://$1.ichochy.com …… } } 例： 请求地址https://ichocy.com/555\nlocation匹配到 /555，而$1代表的就是555，所以https://$1.ichochy.com就动态代表https://555.ichochy.com\n这样，请求地址 https://ichocy.com/555 ，就被反向代理到 https://555.ichochy.com\n注：\n$1 代表正则第一个小括号()中匹配的信息\n$2 代表正则第二个小括号()中匹配的信息\n以此类推 $3 ……\n修改配置文件 # nginx 配置文件 vi /etc/nginx/nginx.conf # 网站配置文件 vi /etc/nginx/sites-available/default 查看日志 # 错误日志 tail -f /var/log/nginx/error.log # 请求日志 tail -f /var/log/nginx/access.log 正则规则 ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 ^~ 表示普通字符匹配，不使用正则匹配，一般用来匹配目录 = 进行普通字符精确匹配 @ \u0026#34;@\u0026#34; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files !~ 表示正则不匹配，排除正则的匹配，区分大小写 !~* 表示正则不匹配，排除正则的匹配，不区分大小写 . 匹配除换行符以外的任意字符 ? 重复0次或1次 + 重复1次或更多次 * 重复0次或更多次 \\d 匹配数字 ^ 匹配字符串的开始 $ 匹配字符串的结束 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n-m次 [a] 匹配单个字符a [a-z] 匹配a-z小写字母的任意一个 ",
    "pubDate": "2023-11-25T08:22:45+08:00"
  }, 
  {
    "objectID": 20231120,
    "url": "https://ichochy.com/posts/vps/20231120.html",
    "title": "香港 CN2 优化线路带宽低延迟 VPS 服务器推荐",
    "summary": "CN2 CN2，中国电信下一代承载网（ChinaNetNextCarryingNetwork）。CN2是一个多业务的承载网络，它能够支持数据、语音、视频多种业务融合的应用，为中国电信今后开展NGN业务打下了良好的基础。中国电信构建的CN2网络，力图奠定未来10-20年里中国电信顶级运营商的基础。中国电信CN2网络一期工程由骨干网络和精品业务网络组成，尤其是承载网对新业务的支持能力，是中国电信骨干网络和其商业客户之间的重要纽带，将直接决定中国电信提供的质量和灵活性。\n",
    "content": "CN2 CN2，中国电信下一代承载网（ChinaNetNextCarryingNetwork）。CN2是一个多业务的承载网络，它能够支持数据、语音、视频多种业务融合的应用，为中国电信今后开展NGN业务打下了良好的基础。中国电信构建的CN2网络，力图奠定未来10-20年里中国电信顶级运营商的基础。中国电信CN2网络一期工程由骨干网络和精品业务网络组成，尤其是承载网对新业务的支持能力，是中国电信骨干网络和其商业客户之间的重要纽带，将直接决定中国电信提供的质量和灵活性。\n服务商 Megalayer Megalayer 致力于成为全球电信增值服务提供商，为用户在全球范围内提供优质、稳定的互联网服务、IDC服务、服务器租赁、裸金属云、DDOS清洗、SD-WAN以及专线等服务。Megalayer 团队都具有丰富的行业经验，分别来自蓝汛、世纪互联、IBM等企业，公司发展迅速，目前已经在香港、日本、美国等地区部署节点，并且将继续在东南亚地区进行战略布局，提升资源优势以及市场优势。Megalayer 先后与中国电信国际公司、中国移动国际公司、PCCW、Telia等知名运营商达成合作，同时依托于自身的全球网络资源及计算能力优势，运用自主研发的智能网络安全平台，抵御网络攻击保护数据安全。我们坚持以最友好的服务，最优质的资源以及具有竞争力的价格为用户提供优质的服务。\n服务器特点和优势 服务器可以按月/年支付，低至24元/月，年付199年/月，支持云闪付付款。\n服务器支持多种优化线路，访问延迟极低，并有CN2国内高速线路可供选择。\n服务器香港CN2优化线路带宽低至49.5元/月，低延迟，国内访问首选。\n服务器系统可以选择 Windows 和 Linux ，可以自定义硬件配置和网络带宽。\n服务器网络测速 优化带宽: 154.55.128.254\n全向带宽: 154.39.240.254\n国际带宽: 154.39.247.254\n服务器地区 香港、新加坡、菲律宾、美国 2024 VPS 优惠码 2024 限时半折优惠码 2024 VPS 优惠码：VPS2024-50%OFF\n优惠码使用 服务器推荐 在线推荐有优惠哦 Megalayer：https://account.megalayer.net/\n推荐地址：https://account.megalayer.net/aff.php?aff=1678\n说明 注：注册登录后可以看到特价VPS\n",
    "pubDate": "2023-11-20T08:25:45+08:00"
  }, 
  {
    "objectID": 20231022,
    "url": "https://ichochy.com/posts/vps/20231022.html",
    "title": "菲律宾、马来西亚、泰国等多图 VPS 服务器便宜推荐",
    "summary": "供应商 LightNode LightNode成立于2002年，目前拥有员工500余人。\nLightNode自主研发并提供计算、存储、网络和安全等企业必需的基础IT架构资源。依托于自主知识产权的管理平台，为客户提供混合云计算服务和云上运维管理服务。\nLightNode崇尚“技术驱动产品，运维驱动服务”的理念，不断推出适合行业特性的产品和服务。\n目前，LightNode已为大量游戏、电商、金融、泛娱乐、企事业等方向的IT部署服务，提供了解决方案与混合云服务。\n",
    "content": "供应商 LightNode LightNode成立于2002年，目前拥有员工500余人。\nLightNode自主研发并提供计算、存储、网络和安全等企业必需的基础IT架构资源。依托于自主知识产权的管理平台，为客户提供混合云计算服务和云上运维管理服务。\nLightNode崇尚“技术驱动产品，运维驱动服务”的理念，不断推出适合行业特性的产品和服务。\n目前，LightNode已为大量游戏、电商、金融、泛娱乐、企事业等方向的IT部署服务，提供了解决方案与混合云服务。\n优势介绍资源 全球节点 包含20多个全球节点，其中东南亚及中东地区超过15个节点\n一键部署 一键安装部署，可自由选择系统、应用镜像或已有的自定义镜像创建主机\n计费粒度小 所有的产品及服务都是按照小时收费\n完全资源控制 实例权限全放开，端口仅限制 25 端口\n多地区选择，遍布全世界 菲律宾 VPS 服务器便宜推荐 服务器包含大多数的东南亚国家，原始 IP 在线。\n服务器实例可以随时新建和注销，费用按小时结算，避免费用浪费。\n服务器费用低廉，低至 $7.71/月 （约 50元/月）。\n服务器资源可以根据需求自定义配置，自选系统，支持 Windows 和 Linux。\n服务器网络可以根据实际选择按流量（1000GB）和带宽\n服务器 IP 可以在线免费修改二次，可以重开新实例获得新 IP 的操作。\n服务器网络主要为国际路线，对国内访问速度不太用好，可以通过其它快速的服务器进行中转。\n推荐 通过推荐推荐地址注册会有95优惠\nLightNode: https://www.lightnode.com/\n推荐地址：https://www.lightnode.com/?inviteCode=JJI33F\u0026amp;promoteWay=LINK\nFAQ LightNode首充赠送金是什么？ 首充赠送金是LightNode给予用户的福利，充的越多送的越多，用户最高可获得15美元的赠送金。\nLightNode系统盘需要单独选择吗？ 不需要单独选择，每台VPS主机，LightNode都为你配备了50G的系统盘。\nLightNode有哪些资源节点？ LightNode节点包含美国硅谷、美国华盛顿、德国法兰克福、土耳其、沙特阿拉伯、阿联酋、泰国、柬埔寨、越南河内、越南胡志明、中国香港、中国台湾、韩国、日本等节点，重点部署东南亚地区。\nLightNode支持哪些操作系统？ 系统镜像支持多版本Windows、多种Linux系统（Centos、Ubuntu、Debian等）；应用镜像支持Wordpress等镜像。\nLightNode的计费规则是怎样的？ LightNode目前主机是按量计费的后付费模式，按小时进行出账结算（不满一小时按照一小时计算），每个自然月只计费672小时（即28天），超出672小时，不进行出账。\n",
    "pubDate": "2023-10-22T11:25:45+08:00"
  }, 
  {
    "objectID": 20230131,
    "url": "https://ichochy.com/posts/aml/20230131.html",
    "title": "抗白之路-肺部感染发烧住院两个多月",
    "summary": "说说两个月住院的情况，住院是肺部感染发烧引起的。\n",
    "content": "说说两个月住院的情况，住院是肺部感染发烧引起的。\n发烧的症状是刚开始怕冷，冷的发抖，打寒颤，一两个小时后开始发热，体温高达39-40度，持续性发烧。\n当天晚上凌晨就急匆匆的入院，入院后就开始检查病因。\n做了很多相关血液检查，查看是不是病毒感染引起的发烧，一顿查下来也没有找到病因。\n几天后全身 CT，查看到说肺部有病灶，接下来就针对肺部疾病进行治疗。\n可是半个月过去了，几万的进口抗生素都用上了，可发烧的症状还是没有得到遏制。\n该排查的都排查了，排异也基本排除掉了，就剩肺部感染，医生也没有办法了，建议我们转至专科医院治疗。\n本来移植完不久，免疫力低下，就不敢外出，还要跨城就医，搞得人更加害怕。还在发烧的我多次感到无比的绝望。\n当时还正是新冠高发期，人员限制流动，没办法跨城就医。没有好的办法，只能强求呆在医院。\n再后来就找人代看，安排线上会诊。在几次交流下来，确实目标，统一意见，加激素，早晚加。就这样，不烧了。\n准备出院了，可是的可是，出现了意外，涨红疹子了，几天下来，全身涨满了红疹，奇痒无比。\n主任说，出排异了，提高环孢素的浓度，上抗排异的药。\n就这样在医院渡过了2023的新年，身上的红疹也慢慢消退，等着主任上班就可以出院了。\n病情得到了有效的控制，择良日出院了。\n入院二个多月，总算出院了。只因持续性发烧、感染肺炎、浑身红症，一个个接踵而至，在绝望中期盼着希望。\n只要信心还在，就没有不能闯的关，在经历重重难关后，总会见到雨后彩虹。\n只要抱着心中的火不熄灭，就会有希望。\n",
    "pubDate": "2023-01-31T13:25:45+08:00"
  }, 
  {
    "objectID": 20221108,
    "url": "https://ichochy.com/posts/shell/20221108.html",
    "title": "12 个对新手最重要的 Linux 命令",
    "summary": " 我向所有的 Linux 初学者推荐以下这些命令。\n",
    "content": " 我向所有的 Linux 初学者推荐以下这些命令。\n在使用 Linux 命令行时，很容易就会迷失方向，这可能会导致灾难性的后果：我有一次使用删除命令 rm 删除文件，然而删除之后我才意识到我刚刚是删除了计算机的引导目录。后来，我学会了使用 pwd 命令，来知道当前在文件系统的哪个目录下；并且我使用了 trashy 和 trash-cli 这一命令行回收站工具（LCTT 译注：在删除文件时 trash-cli 会充当中间人，将文件先“删除”到桌面上的垃圾箱中，能够通过垃圾箱或通过终端的 trash 命令，来恢复垃圾箱中已删除的文件。）\n当我刚开始使用 Linux 时，我有一个放在桌子上的“速查表”，它就是《101 条你应该知道的 Linux 命令》，我在管理 Linux 服务器时能参考速查表上面的这些命令。随着我越来越熟悉这些命令，我越来越精通服务器管理了。\n以下是我认为最有用的 12 个 Linux 命令。\n1、打印工作目录（pwd） pwd 命令会打印出你的工作目录。换句话来说，它输出你当前所在目录的路径。pwd 命令有两种选项：-L 或 --logical（即逻辑路径）用来打印当前的目录路径（不解析符号链接），-P 或 --physial（即物理路径）会打印出解析符号链接后的物理目录。（LCTT 译注：你可以进一步阅读我们翻译的 另一篇文章。）\n2、创建目录（mkdir） 使用 mkdir 命令来创建一个新目录，是非常容易的。以下命令，创建了一个名为 example 目录（若 example 已存在，则无法创建）：\n$ mkdir example 你也可以在嵌套地创建目录及其子目录：\n$ mkdir -p example/one/two 如果目录 example 和目录 one 都已存在，则仅会创建目录 two。如果上述目录都不存在，则会创建这三个嵌套的目录。\n3、列出文件（ls） 我最早使用的是 MS-DOS（微软磁盘操作系统），因此我习惯于使用 dir 命令，来列出文件。我不记得当时是否能在 Linux 上使用 dir 命令，但是如今 dir 命令已经包含在 GNU 核心实用程序包GNU Core Utilities package 中了。大多数人会使用 ls 命令，来显示目录中的文件及其所有的属性。ls 命令有许多选项，包括 -l 查看文件的长列表，显示文件所有者和权限等信息。\n4、更改当前工作目录（cd） 在 Linux 中经常要更改当前工作目录，这就是 cd 命令的功能。例如，以下的示例将让你从 主目录home 进入 Documents 目录：\n$ cd Documents 你可以使用 cd ~ 或者 cd，来快速转换到你的主目录。你可以使用 cd .. 来返回到上一级目录。\n5、删除文件（rm） 删除文件是很危险的，因为在 Linux 终端上用 rm 命令会彻底地删除文件，并没有像桌面的垃圾桶那样依旧保存着删除的文件。许多终端用户有一个坏习惯，他们会永久地删除他们认为不再需要的文件。然而，因为没有“取消删除”命令，这个坏习惯可能会导致严重的问题：你会不小心删除了包含重要数据的目录。\nLinux 系统为文件删除提供了 rm 和 shred 命令。要删除文件 example.txt，请输入以下内容：\n$ rm example.txt 然而，使用 trash 命令要安全得多，例如 trashy 或者 trash-cli，它会将文件先“删除”到桌面上的垃圾箱中：\n$ trash example.txt 6、复制文件（cp） 使用 cp 命令，来复制文件。cp 的语法是从_旧文件_复制到_新文件_。这里有一个例子：\n$ cp file1.txt newfile1.txt 你也可以复制整个目录：\n$ cp -r dir1 newdirectory 7、移动并重命名文件（mv） 重命名和移动文件在功能上是相同的过程。当你移动文件时，从一个目录中取出一个文件，并将其放入一个新目录中；当你重命名文件时，将一个目录中的文件更改为新名称，并放回到同一目录或另一个目录下。无论是重命名还是移动文件，你都可以使用 mv 命令：\n$ mv file1.txt file_001.txt 8、创建一个空文件（touch） 使用 touch 命令可以简单地创建一个空文件：\n$ touch one.txt $ touch two.txt $ touch three.md 9、更改权限（chmod） 使用 chmod 命令，来更改文件的权限。chmod 最常见的用途是让文件能够执行：\n$ chmod +x myfile 以下的示例展示了如何用 chmod 命令给文件赋予权限，这对于脚本来说特别方便。尝试一下这个简单的练习吧：\n$ echo \u0026#39;echo Hello $USER\u0026#39; \u0026gt; hello.sh $ chmod +x hello.sh $ ./hello.sh Hello, Don 10、提升为 root 权限（sudo） 在管理自己的 Linux 系统时，可能需要提升为超级用户（也称为 root），这就是 sudo（即 以超级用户做super user do）命令的来源。假设你想要做一些只有管理员（或 root 用户）才能做的事情，只需在命令前加一个 sudo 即可：\n$ touch /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;Success\u0026#34; touch: cannot touch \u0026#39;/etc/os-release\u0026#39;: Permission denied $ sudo touch /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;Success\u0026#34; Success 11、关机（poweroff） poweroff 命令的功能和它的字面意思一样：把你的计算机关机。需要在 poweroff 前面加一个 sudo 才能成功关机。\n实际上，还有很多方法可以关闭你的计算机，这些方法有略微的不同。例如，shutdown 命令会在指定的时间（例如 60 秒）后关闭计算机：\n$ sudo shutdown -h 60 或者立即关闭计算机：\n$ sudo shutdown -h now 你也可以用 sudo shutdown -r now 或者 reboot 来重启计算机。\n12、阅读手册（man） man 命令可能是 Linux 中最重要的命令了，你可以通过 man 命令查看 Linux 系统上每个命令的官方文档。例如，要阅读更多有关 mkdir 的信息，可以输入：\n$ man mkdir 一个与 man 相关的命令是 info 命令，它提供了一组不同的手册，它通常会提供比简洁的 man 页面更详细一点的内容。\n本文转自 https://linux.cn/，如有侵权，请联系删除。\n",
    "pubDate": "2022-11-08T08:22:45+08:00"
  }, 
  {
    "objectID": 20221107,
    "url": "https://ichochy.com/posts/blog/20221107.html",
    "title": "第一次通过 SSH key 免密连接 GitHub 的完整过程",
    "summary": "通过密码连接GitHub总是要输入密码，麻烦，现在使用 SSH key 可以轻松实现免密验证.\n",
    "content": "通过密码连接GitHub总是要输入密码，麻烦，现在使用 SSH key 可以轻松实现免密验证.\n创建 SSH key 使用 ssh-keygen 命令 打开终端输入命令 ssh-keygen 创建 key ssh-keygen -t ed25519 -C \u0026#34;ichochy@outlook.com\u0026#34; 注意：将ichochy@outlook.com换成自己的邮箱。\n命令构建ed25519 key，并自动保存到.ssh目录 Generating public/private ed25519 key pair. Enter file in which to save the key (/Users/mleo/.ssh/id_ed25519): Created directory \u0026#39;/Users/mleo/.ssh\u0026#39;. 提示输入key的密码 Enter passphrase (empty for no passphrase): Enter same passphrase again: 注意：可以输入空和密码\n提示key创建成功，并保存在.ssh目录 Your identification has been saved in /Users/mleo/.ssh/id_ed25519 Your public key has been saved in /Users/mleo/.ssh/id_ed25519.pub 配置 SSH key 创建配置文件 touch ~/.ssh/config 配置文件写入GitHub主机信息 Host github.com # 别名 Hostname github.com # GitHub 主机地址 Port 22 # GitHub 主机端口 User git # GitHub 主机用户 Identityfile ~/.ssh/id_ed25519 # ssh-key GitHub帐号中添加公钥key iChochy(用户) =\u0026gt; Settings =\u0026gt; SSH and GPG keys =\u0026gt; new SSH key 测试 SSH key 测试 GitHub SSH 连接 ssh -T git@github.com 确认是否连接 The authenticity of host \u0026#39;github.com (20.205.243.166)\u0026#39; can\u0026#39;t be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入 yes确认连接 Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added \u0026#39;github.com\u0026#39; (ED25519) to the list of known hosts. 成功连接信息 Hi iChochy! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 使用 SSH key 通过 SSH 地址克隆远程仓库 git clone git@github.com:iChochy/iChochy.git # 克隆远程仓库 通过 SSH 免密提交代码 Enumerating objects: 405, done. Counting objects: 100% (405/405), done. Delta compression using up to 8 threads Compressing objects: 100% (205/205), done. Writing objects: 100% (206/206), 27.81 KiB | 6.95 MiB/s, done. Total 206 (delta 199), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (199/199), completed with 194 local objects. To github.com:iChochy/iChochy.git 1d44cdb..bde62c3 master -\u0026gt; master ",
    "pubDate": "2022-11-07T11:22:45+08:00"
  }, 
  {
    "objectID": 20220902,
    "url": "https://ichochy.com/posts/software/20220902.html",
    "title": "5 款适用于 Linux 的笔记应用",
    "summary": " 使用这些开源工具来记笔记。\n",
    "content": " 使用这些开源工具来记笔记。\n笔记是任何作者生活的一部分。我的大部分文章都是从笔记应用开始的，这对我来说通常是 Joplin。有大量适用于 Linux 的笔记应用，你可能使用的不是我最喜欢的应用。最近的一篇博客文章让我想起了其中的六个，所以我整理了一份我最喜欢的列表。\nJoplin Joplin\nJoplin 适用于 Linux、Windows、macOS、Android 和 iOS。我喜欢 Joplin，因为它会自动保存你添加的任何内容。笔记可以上传到 NextCloud、OwnCloud、Joplin Cloud，甚至是 OneDrive、Dropbox 或任何 WebDav 应用等闭源服务。Joplin 还支持加密。\n以各种格式导出笔记也很容易。它带有八个不同的主题，可让你定制其外观。\nJoplin 采用 MIT 许可证。最初于 2017 年发布，Joplin 正在与大量贡献者社区一起持续开发。\nXournal Xournal\nXournal 适用于 Linux、Windows、macOS 和 Android。它的目的是让你创建包含几乎任何你可以想象的媒体类型的笔记。它支持压敏手写笔和绘图板，因此你可以创建 涂鸦笔记。你可以在里面打字、绘制简单的矢量、导入图形、录制音频等等。你还可以使用 Xournal 来注释 PDF，这就是我使用它的方式。它以 GPLv2 许可证发布，你可以以多种格式导出笔记。\nTrillium Trillium\nTrillium 是一个层级笔记应用，专注于知识构建库。它具有丰富的所见即所得编辑功能，支持表格、图像和 Markdown。它支持使用语法高亮编辑源代码中的注释。它是在 AGPL 许可证下发布的。\nTrilium 可用作 Linux 和 Windows 的桌面应用，以及你可以在自己的 Linux 服务器上托管的 Web 应用。\nGnote Gnote\nGnote 是一个为 Linux 编写的开源笔记应用。它是由 Hubert Figuière 从一个名为 Tomboy 的项目中克隆出来的。与 Tomboy 一样，Gnote 使用类似 Wiki 的链接系统来允许你将笔记链接在一起。\nGNote 的源代码可在 GitLab 上找到。该软件是 GPLv3 许可。\nCherryTree CherryTree\nCherryTree 支持层级笔记。在 CherryTree 中，所有东西都是一个节点。节点可以是纯文本、富文本、各种编程语言的语法高亮。每个节点可以有子节点，每个子节点有不同的格式。\nCherryTree 具有富文本和语法高亮的特点，并可以将数据存储在一个 XML 或 SQLite 文件中。CherryTree 可以从各种格式导入，包括 Markdown、HTML、纯文本、Gnote、Tomboy 和其他格式。它可以将文件导出为 PDF、HTML、纯文本和它自己的 CherryTree 格式。\nCherryTree 使用 GPLv3 许可，可以安装在 Linux、Windows 和 macOS 上。\n本文转自：https://linux.cn/，如有侵权，请联系删除。\n",
    "pubDate": "2022-09-02T08:22:45+08:00"
  }, 
  {
    "objectID": 20220822,
    "url": "https://ichochy.com/posts/blog/20220822.html",
    "title": "国内外免费公共 DNS 服务推荐",
    "summary": "我们都知道想要能上网，就必须要使用DNS。DNS一般都是你的运营商提供给你的，也可以是一些其它组织提供的，比如我们熟知的谷歌的DNS 8.8.8.8， 国内114dns的114.114.114.114 。这些由大的厂商和机构提供的公开解析服务，叫做公共DNS。\n",
    "content": "我们都知道想要能上网，就必须要使用DNS。DNS一般都是你的运营商提供给你的，也可以是一些其它组织提供的，比如我们熟知的谷歌的DNS 8.8.8.8， 国内114dns的114.114.114.114 。这些由大的厂商和机构提供的公开解析服务，叫做公共DNS。\n不过首先要明白，公共DNS不是：不是根服务器\n不是权威dns托管商，不提供域名注册等服务，比如万网和DNSpod\n不是权威dns，不针对个别域名进行解析\n公共DNS服务的特点就是服务的域名数量巨大，用户数多，同时要求具有安全性和抗攻击性，低延迟（响应快），无拦截（无广告）以及对解析成功率要求非常的高。并在一定程度上提高网页的链接速度，因此选择使用一个优秀的DNS，可以显著的提高网络冲浪体验。\n下面就介绍一些国内外优秀的公共DNS供大家选用。\n国内公共DNS 腾讯云 DNS Public DNS+ 是 DNSPod 推出的公共域名解析服务，DNSPod 曾是中国第一大DNS解析服务提供商，现在 DNSPod 已经被腾讯云收购，因此也叫做腾讯公共 DNS 服务。腾讯 DNS 可以为用户提供更加快速、准确、稳定的递归解析服务，且不会对任何域名进行恶意劫持。\nIPv4 DNS 地址：119.29.29.29 服务地址：https://www.dnspod.cn/Products/Public.DNS\n阿里云公共 DNS 由阿里云提供的公共DNS服务。阿里云拥有全球数百台服务器组成的集群，具有充足的带宽资源；其自研高性能DNS系统和清洗中心，保障系统稳定和安全。BGP anycast技术，让您访问最近的DNS集群；动态缓存技术，加速解析响应。阿里云公共 DNS具有稳定，快速，智能的优势。\nIPv4 DNS 地址：223.5.5.5 / 223.6.6.6 IPv6 DNS 地址：2400:3200::1 / 2400:3200:baba::1 服务地址：https://alidns.com/\n百度公共 DNS 由百度推出的公共DNS的服务，依托百度强大技术，具有云防护，无劫持，更精准三大优势。\n云防护：病毒、木马、钓鱼网站一网拦截，百度云防护实时守护您的访问安全\n无劫持：无恶意跳转，无强制广告，百度公共DNS让您的每一次访问都畅通无阻\n更精准：遍布全国的递归出口、智能解析，所有的努力只为让CDN定位更精准，让您的每一次访问都更高效\nIPv4 DNS 地址：180.76.76.76 IPv6 DNS 地址：2400:da00::6666 服务地址：https://dudns.baidu.com/intro/publicdns\n114 DNS 114 DNS 源自南京信风 2010 年为中国电信及中国联通两个大省约 2000 万宽带用户提供备份服务的超大型 DNS 系统，同时提供公众 DNS 解析服务及权威 DNS 解析备份服务，114DNS 将为中国的互联网及电子商务提供可靠的基础安全保障。114DNS 为国内云安全DNS服务先行者，114DNS 平台由多个基础电信运营商与南京信风共建共享，但由南京信风提供技术支持以确保服务的优质高效。\nIPv4 DNS 地址：114.114.114.114 / 114.114.115.115 OneDNS OneDNS是北京微步在线科技有限公司旗下产品，为防止DNS解析服务被滥用，OneDNS个人版对来自每个IP地址的解析请求量做了限制，其解析服务分为拦截版，纯净版，家庭版三种。拦截版含有恶意网站拦截、广告过滤等功能；纯净版则不对访问网站进行任何过滤拦截，直接返回其真实的响应结果。\n拦截版 IPv4 DNS 地址：117.50.11.11 / 52.80.66.66 纯净版 IPv4 DNS 地址：117.50.10.10 / 52.80.52.52 家庭版 IPv4 DNS 地址：117.50.60.30 / 52.80.60.30 服务地址：https://www.onedns.net\n国外DNS 服务 谷歌公共 DNS 谷是最早推出免费DNS服务的平台。谷歌DNS它们易于记忆，并且每个人都可以使用。谷歌DNS的主要优势来自他们作为一家公司的声誉。谷歌每年收入极多，有能力提供最稳定和更有弹性的DNS服务器。这个DNS服务器的唯一问题是它们存储有关您的运营的信息，如果美国政府决定需要这些信息，它们可以与第三方共享，Google通常被认为是最好的DNS服务器。\nIPv4 DNS 地址：8.8.8.8 / 8.8.4.4 服务地址：https://developers.google.com/speed/public-dns\nCloudflare DNS cloudflare 是一家国外的 CDN 加速服务商。2018 年的 4 月 1 日愚人节，Cloudflare 宣布推出 1.1.1.1 公共 DNS 服务。如今两年过去了，其已经成为了仅次于 Google 的全球第二大公共 DNS 解析器。cloudflare DNS目标互联网上速度最快且高度关注隐私保护的消费级 DNS 服务\nIPv4 DNS 地址：1.1.1.1 / 1.0.0.1 IPv6 DNS 地址：2606:4700:4700::1111 / 2606:4700:4700::1001 服务地址：https://cloudflare-dns.com\nOpenDNS OpenDNS 是一个免费的域名解析服务提供商（DNS），并具备反钓鱼、内容控制软件等功能。2015年6月30日，思科系统公司宣布收购OpenDNS。OpenDNS为个人和商业提供DNS方案，用户可以自行选择使用OpenDNS的服务或者使用当地ISP提供的DNS服务。\nIPv4 DNS 地址：208.67.222.222 / 208.67.220.220 IPv4 DNS 地址：208.67.222.220 / 208.67.220.222 IPv6 DNS 地址：2620:119:35::35 / 2620:119:53::53 服务地址：https://www.opendns.com/\n总结：对于国内用户推荐大家使用腾讯云 阿里云的公共 DNS，作为云服务器大厂，公共DNS算是基础服务，势必有不错的保证。国外用户选Cloudflare的公共DNS服务，在速度和隐私方面都做的很好。\n",
    "pubDate": "2022-08-22T19:22:45+08:00"
  }, 
  {
    "objectID": 20220810,
    "url": "https://ichochy.com/posts/software/20220810.html",
    "title": "微软为 VS Code 推出 Markdown 语言服务器",
    "summary": "微软近日发布官方博客表示，他们经过半年时间的努力为 VS Code 带来了 Markdown 语言服务器（Markdown Language Server），团队认为 Markdown 语言服务器是可以推动 VS Code 中的 Markdown 工具进一步发展的项目，有了这个语言服务器，微软将把 VS Code 内置的大部分 Markdown 语言工具（如：文档大纲、智能折叠、路径补全等）提供给其他编辑器和工具。目标是推动 Markdown 工具的发展，并使其具有一些与其他编程语言工具类似的智能功能。\n",
    "content": "微软近日发布官方博客表示，他们经过半年时间的努力为 VS Code 带来了 Markdown 语言服务器（Markdown Language Server），团队认为 Markdown 语言服务器是可以推动 VS Code 中的 Markdown 工具进一步发展的项目，有了这个语言服务器，微软将把 VS Code 内置的大部分 Markdown 语言工具（如：文档大纲、智能折叠、路径补全等）提供给其他编辑器和工具。目标是推动 Markdown 工具的发展，并使其具有一些与其他编程语言工具类似的智能功能。\nMarkdown 语言服务器的工作将由以下两个新的开源库负责（两个库名字十分接近）：\nMarkdown 语言服务（Markdown Language Service）：一个 TypeScript 库，提供处理 Markdown 的工具； Markdown 语言服务器（Markdown Language Server）：一个使用语言服务构建的 Markdown 语言服务器 上述这两个库现在还处于早期阶段，但它们已经被 VS Code 1.70+ 使用了。此次转变还可以将 Markdown 工具转移到一个单独的进程中，这样它就不会阻碍其他扩展。\n目前这个 Markdown 语言服务器的功能包括：\n文档大纲 文档链接 智能折叠 智能选择 自动补全 重命名 查找所有引用 转到定义 损坏链接的诊断 在文件移动/重命名时，自动更新链接 参与此次开发的开发者 Matt Bierner 表示：\n一个开源的 Markdown 语言服务器可以帮助其他的编辑器，反过来也会吸引更多开发者参与贡献，最终反哺 VS Code。Markdown 语言服务器可以把开发人员聚集在一起，在一个更大的项目上工作，最终将使所有人受益，而不是让每个编辑器/工具都在重复实现他们自己的 Markdown 支持。\nMatt Bierner 也分享了促成此次开发的心路历程：\n多年来，我一直使用 VS Code 相对简单的 Markdown 编辑器。我对语法高亮和内置的 Markdown 预览功能感到满意，而文档大纲和可点击的编辑器链接则是锦上添花的功能。我已经习惯了用手打出链接。我已经接受了这样的事实：如果我改变了一个标题的名称，我就需要做一个文本搜索来更新所有指向该标题的链接。因为我认为 Markdown 只不过是花哨的纯文本。\n但是有一天，当我第 100 次输入错误的图片路径后，我终于意识到：这一点都不好玩！我为什么要把我的生命浪费在手动输入图片上？我为什么要浪费我的生命去手动输入和验证这些链接？这就是工具应该发挥的作用。\n如果你也想为此做出一些贡献，那么可以点击访问这两个新项目的 GitHub 仓库，提交错误报告、功能请求，甚至是 PR。\n本文转自 https://www.oschina.net/，如有侵权，请联系删除。\n",
    "pubDate": "2022-08-10T15:25:45+08:00"
  }, 
  {
    "objectID": 20220705,
    "url": "https://ichochy.com/posts/aml/20220705.html",
    "title": "抗白之路-每天在马桶上渡过，急性肠排……",
    "summary": "在出舱住院二周后准备出院，突然出现不明原因发烧，各种检查，没有明显的异常，医生说是免疫性发烧，有点小排异，过了十来天才好点。\n",
    "content": "在出舱住院二周后准备出院，突然出现不明原因发烧，各种检查，没有明显的异常，医生说是免疫性发烧，有点小排异，过了十来天才好点。\n可是命运不太好，刚开始进食就拉肚子了，一天比一天拉的次数多，开始肠排了……\n这一发不可收拾，拉的次数越来越多，每天不停的拉黑稀水，一天十多回。\n开始上单抗，一支八千多，每天都坚熬着，医生说肠排需要一个过程，还没有到谷底，需要等等，坚持坚持。\n现在二十来天，应该要转折了，这期间瘦了二十多斤，现在只有40kg，已经皮包骨了。\n七夕，我老婆为我求来了平安福，希望我能快点好起来。\n感谢家人为我的付出和关心！\n希望快点好起来，加油……\n",
    "pubDate": "2022-07-05T11:22:45+08:00"
  }, 
  {
    "objectID": 20220622,
    "url": "https://ichochy.com/posts/aml/20220622.html",
    "title": "抗白之路-舱内日常",
    "summary": "一、舱内设施 舱内主要就是生活的必要设施和消毒药水，主要包括坐便椅、尿壶来安排你的三急，都需要打包称重。然后就是水壶，每天喝水就靠它了，所有的水都必须要烧开后才能饮用。电视机可以供你娱乐，观看国家大事。床边桌，是用来吃饭的主要用具。最后最重要的就是一张床，这张舒适的床，让你在这一个多月里躺的舒适，注意：上床后一定要拉上护栏，防止跌落。\n",
    "content": "一、舱内设施 舱内主要就是生活的必要设施和消毒药水，主要包括坐便椅、尿壶来安排你的三急，都需要打包称重。然后就是水壶，每天喝水就靠它了，所有的水都必须要烧开后才能饮用。电视机可以供你娱乐，观看国家大事。床边桌，是用来吃饭的主要用具。最后最重要的就是一张床，这张舒适的床，让你在这一个多月里躺的舒适，注意：上床后一定要拉上护栏，防止跌落。\n其他的就是洗漱盆、碘伏、纸巾啥的，生活用品，还有就是大量的漱口水，保持口腔清洁，预防溃疡的发生。\n二、舱内日常 每天五点会有护士过来通管、采血啥的，七点过后会送早餐过来，接着就是做口腔护理，用棉球沾漱口水擦拭整个口腔，开始吃早餐，还有吃药。接下来阿姨会过来消毒打扫卫生，会灌装饮用水并烧开。接着护士就会过来查房，询问病人情况，顺便给你输上液，并测量血压和血氧饱和度，毕竟进来一次不容易。\n接着会有医生过来查房，询问病人情况，说说用药，讲讲用药后的不良反应，注意事项，调整用药等。主要就是些有没有发烧、有没有哪里不舒服、有没有起疹子什么，一般也没有太大的问题。\n然后就是无穷无尽的输液，两根 picc 管齐头并进，就没有停息过，每天上厕所、吃饭、睡觉都是带着管子，刚开始还不习惯，进来几天也就慢慢习惯了，有时一般要到早上才封管吃个早餐\n",
    "pubDate": "2022-06-22T09:22:45+08:00"
  }, 
  {
    "objectID": 20220615,
    "url": "https://ichochy.com/posts/aml/20220615.html",
    "title": "抗白之路-移植用药",
    "summary": "阿扎胞苷 阿扎胞苷为胞嘧啶核苷类似物，其抗肿瘤功能目前有两种的作用机制：1. 通过与DNA或RNA结合，产生细胞毒性并且特异性抑制细胞周期；2. 通过与DNA甲基化酶结合，降低DNA甲基化，从而恢复造血干细胞的正常分化和造血功能。\n",
    "content": "阿扎胞苷 阿扎胞苷为胞嘧啶核苷类似物，其抗肿瘤功能目前有两种的作用机制：1. 通过与DNA或RNA结合，产生细胞毒性并且特异性抑制细胞周期；2. 通过与DNA甲基化酶结合，降低DNA甲基化，从而恢复造血干细胞的正常分化和造血功能。\n注意事项： 可引起胃肠道反应，白细胞减少，引起肝损害。每天静脉输入此药266mg/平方米，可发生中枢神经毒性作用，表现为肌痛及压痛、失眠、无力，严重的肌痛持续到疗程完了后7天。它对肾脏也有毒性作用，影响肾曲管功能而发生多尿、糖尿或暂时性血清中重碳酸盐或磷酸盐改变。有报告发生预料不到的酸碱平衡及电解质紊乱，甚至有死亡者。\n阿糖胞苷 阿糖胞苷是一种抗代谢性抗肿瘤药物。尽管作用机制尚未完全阐明，但阿糖胞苷似通过抑制DNA 多聚酶而起作用，可能通过抑制细胞DNA的合成而干扰细胞的增殖，进而发挥抗肿瘤作用。\n注意事项： 阿糖胞苷可能会有一些由于药物引起的副作用。主要是胃肠道反应如恶心、呕吐，但请您不要紧张，把心情放轻松。在输注之前医生会给您用止吐药物以减少药物的副作用。如果您出现恶心的症状，可以做深呼吸来缓解恶心的程度。在静点时要多饮水，有利于药物代谢物的排泄。饮食要清淡易消化，减少胃肠道的刺激。如果出现腹泻或发热时，您也不要紧张，这些都是药物的副作用，医生都会为您解决这些问题。此外在输注阿糖胞苷时要增加妥布霉素地塞米松滴眼，每日4-6次，以防由于输注阿糖胞苷引起的结膜炎。若您有不适，及时通知护士。\n白舒菲（白消安） 白舒菲（白消安）属于双功能团烷化剂，为强效的细胞毒性药物，大部分的细胞毒性作用是由DNA损伤引起的，可引起深度骨髓抑制。\n注意事项： 输注白舒菲，每天分四次静点，每次在输注之前半小时护士会为您发放一粒口服药物(苯妥英钠片)。白舒菲的副作用主要是恶心、呕吐以及手足震颤，您不要紧张，在输注前有止吐和镇静的药物。\n依托泊苷 依托泊苷是一种鬼臼毒素衍生物，属于细胞周期特异性抗肿瘤药物。主要作用于细胞DNA，阻碍DAN修复，从而发挥抗肿瘤作用。\n注意事项： 输注依托泊苷，大概一个小时就可以输注完毕，应用依托泊苷会导致白细胞和血小板减少，贫血，此为剂量限制性毒性。会有胃肠道反应:如恶心、呕吐、食欲不振，口腔炎，腹泻；偶有腹痛，便秘。还可能会有过敏反应；有时可出现皮疹、红斑、瘙痒等过敏症。会有皮肤反应，脱发较明显，有时发展至全秃，但具可逆性。会有神经毒性、手足麻木、头痛等。还有其他反应：发热、心电图异常、低血压、静脉炎等。所以用药期间，我会随时巡视病房，用药前给病人剔除头发，保证清洁。\n环磷酰胺 环磷酰胺是进入人体内被肝脏或肿瘤内存在的过量的磷酰胺酶或磷酸酶水解，变为活化作用型的磷酰胺氮芥而起作用的氮芥类衍生物。抗瘤谱广，是第一个所谓“潜伏化”广谱抗肿瘤药，对白血病和实体瘤都有效。\n注意事项： 输注环磷酰胺，一般输注两天。在输注环磷酰胺过程中，如果出现食欲减退、恶心呕吐时做深呼吸运动可缓解恶心的症状。可吃清淡、少油腻、易消化的食物。其次环磷酰胺代谢产物主要刺激膀胱可能会导致出血性膀胱炎，表现为尿频、尿急、尿痛、少尿或肉眼血尿，为减少此类副作用发生，医生会加大输液量，24小时不间断输液，同时尽量多喝水，成人每天至少3000以上，儿童需遵医嘱执行，也可饮用适合自己口味的苹果水、梨水等，这样有利于代谢产物的排出。同时医生还会采取药物预防(如:美司钠、前列腺素)膀胱炎的发生。在此期间您会有多尿的现象，是因为使用利尿剂和水化的原因，这属于正常现象。另外少数患者还会出现头痛、头晕症状，您一定要卧床休息，减少下床活动，以防晕倒；还有些患者会有牙龈痛/口角麻木等现象，可用冰盐水含漱以缓解症状。\nATG 主要可能通过去除抑制性T淋巴细胞对骨髓造血的抑制，也有认为尚有免疫刺激作用，通过产生较多造血调节因子促进干细胞增殖，此外可能对造血干细胞本身还有直接刺激作用。 因为ATG可以抑制经抗原识别后的淋巴细胞激活过程，特异性的破坏淋巴细胞也就相当于而破坏人体的T细胞的免疫，所以能够达到抗排斥反应的作用。在使用ATG的过程当中，ATG可能会出现过敏性休克的反应，所以要注意监测\n注意事项： 在某些预处理方案中要输注ATG，一般静点四天此药是为了抑制免疫力。最常见的不良反应是发热、寒颜、全身乏力、皮疹，不过请您不要紧张，在输入之前医生会给您用抗过敏的药物，一般在停药后此类副作用会逐渐消失。如出现皮疹而引起全身皮肤瘙痒，请不要用手抓挠皮肤，以免引起感染。\n司莫司汀 本品为细胞周期非特异性药物，对处于G1-S边界，或S早期的细胞最敏感，对G2期也有抑制作用。本品进入体内后其分子从氨甲酰胺键处断裂为两部分，一为氯乙胺部分，将氯解离形成乙烯碳正离子，发挥烃化作用，使DNA链断裂，RNA及蛋白质受到烃化，这与抗肿瘤作用有关；另一部分为氨甲酰基部分变为异氰酸酯，或再转化为氨甲酸，以发挥氨甲酰化作用，主要与蛋白质特别是其中的赖氨酸末端的氨基等反应，这主要与骨髓毒性作用有关，氨甲酰化还破坏一些酶蛋白使DNA被破坏后难以修复，这有助于抗癌作用\n注意事项： 口服司莫司汀，司莫司汀为胶囊制剂，一般在夜间八点口服。此药会有恶心呕吐等不适症状，在口服之前医生会给您用止吐药减少您的不适感。出现呕吐需及时补药，保证药物剂量准确，达到有效治疗。\n美法仑/马法兰/美法兰 适用于多发性骨髓瘤患者造血干细胞移植前的高剂量预处理治疗；最常见的不良反应是骨髓抑制，可导致白细胞和血小板减少；多发性骨髓瘤患者的姑息治疗。\n注意事项： 由于美法仑是骨髓抑制剂，因此必须在整个治疗期间监测血象(血细胞计数)，以避免过度的骨髓抑制和不可逆的骨髓再生。 使用常规剂量美法仑罕见胃炎发生，高剂量使用美法仑后，出现胃肠道不适，包括恶心和呕吐，而接受高剂量静注美法仑有增加腹泻、呕吐和胃炎发生的可能。使用美法仑后，出现肺纤维化和出血性贫血，有脱发的情况\n",
    "pubDate": "2022-06-15T15:45:45+08:00"
  }, 
  {
    "objectID": 20220601,
    "url": "https://ichochy.com/posts/aml/20220601.html",
    "title": "抗白之路-入舱",
    "summary": "一、术前检查 患者查体 在医院住院后就开始了无穷尽的检查，血是不知道抽了多少管，然后就是我害怕的骨穿了，因为之前做骨穿都晕过去了，这次还好，医生很专业，让我放松，不用紧张，几分钟就过去。具体如何操作的我也不知道，就知道趴在床上，两个医生按着就做完了，有麻药的作用，不痛，但还是有点害怕。后面就是各种 CT 、X光、心电图，肺部 CT、耳鼻喉检查，反正就是来了一套大全套的查体。\n",
    "content": "一、术前检查 患者查体 在医院住院后就开始了无穷尽的检查，血是不知道抽了多少管，然后就是我害怕的骨穿了，因为之前做骨穿都晕过去了，这次还好，医生很专业，让我放松，不用紧张，几分钟就过去。具体如何操作的我也不知道，就知道趴在床上，两个医生按着就做完了，有麻药的作用，不痛，但还是有点害怕。后面就是各种 CT 、X光、心电图，肺部 CT、耳鼻喉检查，反正就是来了一套大全套的查体。\n应为我贫血严重，当天就安排了输血，每天输2个单位，一共输了三天才到安全值，人也轻松了很多，精神状态好了不少，走路也不喘了。\n供者查体 我的供者是我的姐，这也是我唯一的希望，应为骨髓库没有合适的配型，只能用我姐来做供者，我姐年纪比较大，45岁、生过多个小孩，还是半相合，没有退路直接上。查体也是一全套的大检查，采血、骨穿、CT、X光全用上。然后就是等待结果。\n二、预处理-化疗 入舱准备 查体后，结果需要等待一段时间，一周后就有了初步结果，最终结果要十到十五天。有个好的结果，告诉我的白血病还在慢性期（cmml-1），我姐的查体也合格，可以作为供者。就这样我再次入院，提前做好术前准备，医生找来我老婆进行谈话，谈话的内容就是骨髓移植的方案，当中会用到什么药，是做什么用的，会有哪些不良反应和风险，然后就是一堆的文件签署。\n置管-PICC 置管，又一个让我害怕的项目，后面在舱里的输液、抽血都靠它了。当时护士通知我置管时，我的心是忐忑不安的，没有经历过，还是很害怕，需要将一米多长的管子植入到血管中，直达心脏口。\n洗好胳膊，到达手术室，去掉上衣，躺在床上开干，一个护士长就轻松地搞定了，前期要用大量的酒精消毒胳膊，擦了一遍又一遍，整个胳膊都火辣辣的，我的心里还是很紧张和害怕的，插管时会先上点麻药，没几分钟，就告诉我管置好，还需拍个X光确认下位置就行了。\n化疗 化疗也是预处理的一部分吧，给我来了轻微的化疗，一周的药量，主要是阿扎胞苷，打了七天，一天打两小针在胳膊上，护士告诉我打针的位置会红肿胀疼，需要冰敷下，用到冰片➕芒硝一比三混合服帖就好，可是我感觉就没啥效果，胳膊还是有点肿疼的，打完阿扎胞苷，身体感觉就开始乏力了，没有之前有精神，后来血项又掉过安全值，只能再次输血，平稳度过。\n三、入舱 稳定下来就安排入舱了，入舱前需要提前准备舱里需用的必须物资如：衣服、水杯、纸巾、盆子、被子、体温计、水壶，送到物料科进行消毒处理再送到舱里。我就在护士的指引下，老婆推着我来到移植舱，电子设备可以一同带来，护士可以安排消毒一同进入舱里。进入舱里需要先淋浴消毒，换上提前准备的衣服，正式进入舱里。舱里就是一个在病房中的层流房间里，有对流的空气过滤，五星级房间的床费，哈哈！\n以后就要在这个小房间里面度过我的重生之路了，房间里就只有一些简单的设施，马桶椅、尿壶、电视、时钟、餐板、床头柜、水壶，生活必须的设施。\n",
    "pubDate": "2022-06-01T11:22:45+08:00"
  }, 
  {
    "objectID": 20220505,
    "url": "https://ichochy.com/posts/software/20220505.html",
    "title": "强！腾讯推出开源免费老照片修复工具！",
    "summary": "对于多数人的回忆可能会通过旧照片或者老视频来获得，可是当旧照片因不可抗力因素保管或者出现损坏时怎么办？修复照片肯定是很多人的想法，可是对于不会专业图像处理的用户来说想要校正一些旧照片还是有些困难的。\n",
    "content": "对于多数人的回忆可能会通过旧照片或者老视频来获得，可是当旧照片因不可抗力因素保管或者出现损坏时怎么办？修复照片肯定是很多人的想法，可是对于不会专业图像处理的用户来说想要校正一些旧照片还是有些困难的。\n通常情况下，旧照片一般都是黑白或者已经泛黄的照片，而多数旧照片因为环境问题可能会出现照片损坏导致残缺的问题。对于不会使用专业 Photoshop 来处理照片的用户而言，想要修复非常困难。\n由腾讯开发人员开发的在线 GFP-GAN（生成面部先验生成对抗网络）程序很早已发布在开源社区 ，该程序使用具有人工智能元素的算法。它旨在提高质量，平滑和消除旧照片中的损坏。该在线程序使用两种 IT 模型，只需几秒钟即可补充照片的稀缺元素，提供高精度和非常好的质量以帮助恢复图像。\n通常，此类项目只是现有 AI 模型的一组精细设置，该模型由人工图像和真实图像之间的差异进行训练。但腾讯开发人员强调，这种做法往往会导致效果不佳。他们开发了一个替代选项，在其中，他们通过经历几个创建图像的标准阶段来训练 NVIDIA StyleGAN-2 模型。通过这种方式，保留了原始照片中特定人物的身份，IT 算法专注于人脸的主要特征 - 眼睛，嘴巴等等。\n该项目的创建者将他们的程序作为免费的在线服务提供，您可以通过以下的地址进行快速访问。\nGFP-GAN 修复照片网站（第三方）\nhttps://app.baseten.co/apps/QPp4nPE/operator_views/RqgOnqV\n使用 GFP-GAN 修复照片网站上提供的仅为英文界面，不过对于现在的用户来说操作上也没有太大难题。一般情况下是我们需要先选择需要修复的照片，再点击进行修复即可得到修复后的对比照片，然后再下载我们修复后的照片即可。\n使用 GFP-GAN 修复照片步骤：\n大眼仔拿了一张自己 2009 年 19 岁时的照片测试。当时的照片是使用 Nokia 6120C 拍摄，手机后置相机是 200 万相素。而且照片并不是原始照片，是几经保存截图后的图片（737x561 像素）。\n1、点击 ① 方框空白处进行选择需要修复的照片。\n2、点击 ② 指示的按钮进行照片智能修复。\n3、点击 ③ 指示的按钮下载并查看修复的旧照片。\n修复后的照片效果还是非常不错的，其实在截图中就可以很清晰的看到当前的修复质量，无论是清晰度还是细节纹理上都有了质的提升。\n我拉入到 Photoshop 中进行对比。其中清晰度、纹理以及图像尺寸都进行了调整，图像尺寸增加了一倍大小（1474x1122 像素）。GFP-GAN 还支持对黑白照片进行色彩修复哦。\n当然，这款在线处理工具也在 GitHub 上提供了源代码，其中上传了有关在本地计算机上安装和使用此神经网络的详细说明。\nhttps://github.com/TencentARC/GFPGAN\nGFP-GAN 代码在 Apache 许可证版本 2.0 许可证下发布，允许用户修改和完善此软件工具。\n目前市面上也有不少智能 AI 修复照片的软件，但是相对来说软件体积都非常大，如果您需要修复的旧照片并不多，那么 GFP-GAN 可以很轻松的帮助你修复一些对于您有意义的照片。\n每个人都有自己的青春也都有自己想要保留的人或记忆，错过的东西永远都会被时间定格且无法找回。\n本文转自 https://mp.weixin.qq.com/，如有侵权，请联系删除。\n",
    "pubDate": "2022-05-05T11:15:45+08:00"
  }, 
  {
    "objectID": 20220310,
    "url": "https://ichochy.com/posts/aml/20220310.html",
    "title": "抗白之路-确诊",
    "summary": "一、起因 2020年春天，去了一家新公司，开始赶项目模式，为加快项目的发布，不得不疯狂的加班，996开始了，当时加上新冠疫情，工作也不好找，每天不得不拖着疲惫的身体工作着，只觉得一天比一天累，可是又有什么办法，为了生活，为了美好的明天，每个人都在努力的疯狂工作。\n",
    "content": "一、起因 2020年春天，去了一家新公司，开始赶项目模式，为加快项目的发布，不得不疯狂的加班，996开始了，当时加上新冠疫情，工作也不好找，每天不得不拖着疲惫的身体工作着，只觉得一天比一天累，可是又有什么办法，为了生活，为了美好的明天，每个人都在努力的疯狂工作。\n二、检查 总有扛不住的一天，在医院做了检查，血项不太好，三血减少，医生建议做骨穿，之后预约骨穿，做完骨穿人就晕倒了，可能是当时太害怕➕紧张，后面就是等待结果，结果总算出来，可是有看不明白，当时就看到诊断写着cmml-1，到网上查才知道是白血病-慢粒单核细胞白血病，这段时间每天都在网上查资料，说慢粒可以吃靶向药，希望总是那么残酷，我的是慢粒单，不是慢粒。\n三、就医 挂专家号，医生说慢粒单没有啥特效药，做骨髓移植是最后的出路，后来就住院做了再次确认，骨髓中含有恶性肿瘤细胞，逃不掉的命运开始了，前期也很难接受，每天都是在无眠中渡过，就这样煎熬着。\n开始基因检测，骨髓配型，查询骨髓库配型，可是都不是很理想，没有合适的供者，日子一天天的消沉下来，西医没啥方案只能看看中医，在中医的调理和医生的疏导下，慢慢心情平淡了很多，加上老婆的开导，就不再去自我的折磨，不去想病情，怎样都是一天天的过，缓和心态，一直坚持着。\n四、恶化 来年初，天气变冷，太大意了，没有保护好自己，得了一次重感冒，因自身原因抗病毒能力太差，一直咳嗽不止，在医院检查发现血项更差了，已经达到高危的标准，只能住院输血治疗。当时已经走路都喘气，一步三喘，马上快晕倒了，可是现在只正是疫情严重时期，哪也去不了，只能输点血，血成了我的生命之源\n",
    "pubDate": "2022-03-10T15:22:45+08:00"
  }, 
  {
    "objectID": 20211125,
    "url": "https://ichochy.com/posts/software/20211125.html",
    "title": "RIME 鼠须管输入法使用，免费开源还可以自定义词库",
    "summary": "RIME 想你所想，成为一款高度自字义的输入法，本地程序，没有网络传输，文件配置界面，自定义词库，一法多用，可以拼音、五笔、混拼……\n",
    "content": "RIME 想你所想，成为一款高度自字义的输入法，本地程序，没有网络传输，文件配置界面，自定义词库，一法多用，可以拼音、五笔、混拼……\nRIME 安装 Window(小狼毫 Weasel):https://github.com/rime/weasel/releases/latest MacOS(鼠须管 Squirrel):https://github.com/rime/squirrel/releases/latest Linux 看官网，有多个发行版本 官网下载: https://rime.im/download/ RIME 使用 切换到RIME输入法后，可以按下组合键 Ctrl+` 或 F4 键唤出输入方案选单，切换输入方案，可以有拼音、五笔、混拼……\nRIME 五笔 下载 五笔86 https://github.com/rime/rime-wubi 袖珍简化字拼音 https://github.com/rime/rime-pinyin-simp 反查和混拼需要袖珍简化字拼音\n安装 RIME菜单 =\u0026gt; 用户设定 =\u0026gt; 打开设定目录\n将下载字库放入用户设定目录~/Library/Rime\nRIME菜单 =\u0026gt; 重新部署 =\u0026gt; 部署完成\n注：也可以有通过東風破 /plum/安装 bash rime-install wubi pinyin-simp\n配置 用户设定目录~/Library/Rime创建自定义配置文件default.custom.yaml\n配置输入方案列表\n# default.custom.yaml patch: schema_list: - schema: wubi86 #五笔86 - schema: pinyin_simp #拼音 - schema: wubi_pinyin #混拼 也可以增加其它的输入方式，完成后重新部置就可以生效使用了，按下组合键 Ctrl+` 或 F4 键唤出输入方案选单，选择自己想用的输入方案\n样式 用户设定目录~/Library/Rime创建 RIME 配置文件squirrel.custom.yaml\n配置样式或主题\n# squirrel.custom.yaml patch: style: font_point: 18 #字号 horizontal: true #横栏显示 font_face: melo #字体 color_scheme: native #样式，内置多个样式，可以在squirrel.yaml查看 完成后需要再次重新部置生效使用\nstyle - apathy - aqua - azure - clean_white - dark_temple - dust - google - ink - lost_temple - luna - mojave_dark - psionics - purity_of_essence - purity_of_form - solarized_dark - solarized_light - solarized_rock - starcraft 其它设置 中英文切换 MAC 上用Caps Lock键切换中英文输入习惯了，RIME 默认是大写切换，自定义修改下配置\npatch: ascii_composer: good_old_caps_lock: false/true # `true` 大写、`false` 小写 Caps Lock 切换到西文模式，默认大小修改， true 大写、false 小写\nswitch_key 可选切换策略：\ninline_ascii 在输入法的临时西文编辑区内输入字母、数字、符号、空格等，回车上屏后自动复位到中文 commit_text 已输入的候选文字上屏并切换至西文输入模式 commit_code 已输入的编码字符上屏并切换至西文输入模式 设为noop，屏蔽该切换键 # default.custom.yaml patch: ascii_composer: good_old_caps_lock: false # true 大写 、false 小写 switch_key: Caps_Lock: commit_code # 编码字符上屏 Shift_L: noop # 屏蔽 Shift_R: noop Control_L: noop Control_R: noop 符号配置 修改引入方案\n修改输入方案的配置文件，如：wubi_pinyin.schema.yaml\n# wubi_pinyin.schema.yaml # 修改自己想修改的输入方案配置文件(xxx.schema.yaml) punctuator: import_preset: default # default/symbols 自定义全/半角符号输出\n# default.custom.yaml patch: punctuator: full_shape: #全角符号 \u0026#34; \u0026#34;: {commit: \u0026#34;　\u0026#34;} \u0026#34;!\u0026#34;: {commit: \u0026#34;！\u0026#34;} \u0026#34;\\\u0026#34;\u0026#34;: {pair: [\u0026#34;“\u0026#34;, \u0026#34;”\u0026#34;]} \u0026#34;#\u0026#34;: [\u0026#34;＃\u0026#34;, \u0026#34;⌘\u0026#34;] \u0026#34;$\u0026#34;: [\u0026#34;￥\u0026#34;, \u0026#34;$\u0026#34;, \u0026#34;€\u0026#34;, \u0026#34;£\u0026#34;, \u0026#34;¥\u0026#34;, \u0026#34;¢\u0026#34;, \u0026#34;¤\u0026#34;, \u0026#34;₩\u0026#34;] \u0026#34;%\u0026#34;: [\u0026#34;％\u0026#34;, \u0026#34;°\u0026#34;, \u0026#34;℃\u0026#34;] \u0026#34;\u0026amp;\u0026#34;: \u0026#34;＆\u0026#34; \u0026#34;\u0026#39;\u0026#34;: {pair: [\u0026#34;‘\u0026#34;, \u0026#34;’\u0026#34;]} \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34; \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34; \u0026#34;*\u0026#34;: [\u0026#34;＊\u0026#34;, \u0026#34;·\u0026#34;, \u0026#34;・\u0026#34;, \u0026#34;×\u0026#34;, \u0026#34;※\u0026#34;, \u0026#34;❂\u0026#34;] \u0026#34;+\u0026#34;: \u0026#34;＋\u0026#34; \u0026#34;,\u0026#34;: {commit: \u0026#34;，\u0026#34;} \u0026#34;-\u0026#34;: \u0026#34;－\u0026#34; .: {commit: \u0026#34;。\u0026#34;} \u0026#34;/\u0026#34;: [\u0026#34;／\u0026#34;, \u0026#34;÷\u0026#34;] \u0026#34;:\u0026#34;: {commit: \u0026#34;：\u0026#34;} \u0026#34;;\u0026#34;: {commit: \u0026#34;；\u0026#34;} \u0026#34;\u0026lt;\u0026#34;: [\u0026#34;《\u0026#34;, \u0026#34;〈\u0026#34;, \u0026#34;«\u0026#34;, \u0026#34;‹\u0026#34;] \u0026#34;=\u0026#34;: [\u0026#34;＝\u0026#34;, \u0026#34;々\u0026#34;, \u0026#34;〃\u0026#34;] \u0026#34;\u0026gt;\u0026#34;: [\u0026#34;》\u0026#34;, \u0026#34;〉\u0026#34;, \u0026#34;»\u0026#34;, \u0026#34;›\u0026#34;] \u0026#34;?\u0026#34;: {commit: \u0026#34;？\u0026#34;} \u0026#34;@\u0026#34;: [\u0026#34;＠\u0026#34;, \u0026#34;☯\u0026#34;] \u0026#34;[\u0026#34;: [\u0026#34;「\u0026#34;, \u0026#34;【\u0026#34;, \u0026#34;〔\u0026#34;, \u0026#34;［\u0026#34;, \u0026#34;〚\u0026#34;, \u0026#34;〘\u0026#34;] \u0026#34;\\\\\u0026#34;: [\u0026#34;、\u0026#34;, \u0026#34;＼\u0026#34;] \u0026#34;]\u0026#34;: [\u0026#34;」\u0026#34;, \u0026#34;】\u0026#34;, \u0026#34;〕\u0026#34;, \u0026#34;］\u0026#34;, \u0026#34;〛\u0026#34;, \u0026#34;〙\u0026#34;] \u0026#34;^\u0026#34;: {commit: \u0026#34;……\u0026#34;} _: \u0026#34;——\u0026#34; \u0026#34;`\u0026#34;: \u0026#34;｀\u0026#34; \u0026#34;{\u0026#34;: [\u0026#34;『\u0026#34;, \u0026#34;〖\u0026#34;, \u0026#34;｛\u0026#34;] \u0026#34;|\u0026#34;: [\u0026#34;·\u0026#34;, \u0026#34;｜\u0026#34;, \u0026#34;§\u0026#34;, \u0026#34;¦\u0026#34;] \u0026#34;}\u0026#34;: [\u0026#34;』\u0026#34;, \u0026#34;〗\u0026#34;, \u0026#34;｝\u0026#34;] \u0026#34;~\u0026#34;: \u0026#34;～\u0026#34; half_shape: #半角符号 \u0026#34;!\u0026#34;: {commit: \u0026#34;！\u0026#34;} \u0026#34;\\\u0026#34;\u0026#34;: {pair: [\u0026#34;“\u0026#34;, \u0026#34;”\u0026#34;]} # \u0026#34;#\u0026#34;: [\u0026#34;#\u0026#34;, \u0026#34;№\u0026#34;] \u0026#34;$\u0026#34;: [\u0026#34;￥\u0026#34;, \u0026#34;$\u0026#34;, \u0026#34;€\u0026#34;, \u0026#34;£\u0026#34;, \u0026#34;¥\u0026#34;, \u0026#34;¢\u0026#34;, \u0026#34;¤\u0026#34;, \u0026#34;₩\u0026#34;] \u0026#34;%\u0026#34;: [\u0026#34;%\u0026#34;, \u0026#34;％\u0026#34;, \u0026#34;°\u0026#34;, \u0026#34;℃\u0026#34;, \u0026#34;‰\u0026#34;, \u0026#34;‱\u0026#34;, \u0026#34;℉\u0026#34;, \u0026#34;℅\u0026#34;, \u0026#34;℆\u0026#34;, \u0026#34;℀\u0026#34;, \u0026#34;℁\u0026#34;, \u0026#34;⅍\u0026#34;] \u0026#34;\u0026amp;\u0026#34;: \u0026#34;\u0026amp;\u0026#34; \u0026#34;\u0026#39;\u0026#34;: {pair: [\u0026#34;‘\u0026#34;, \u0026#34;’\u0026#34;]} # \u0026#34;(\u0026#34;: \u0026#34;（\u0026#34; # \u0026#34;)\u0026#34;: \u0026#34;）\u0026#34; # \u0026#34;*\u0026#34;: [\u0026#34;*\u0026#34;, \u0026#34;＊\u0026#34;, \u0026#34;·\u0026#34;, \u0026#34;・\u0026#34;, \u0026#34;×\u0026#34;, \u0026#34;※\u0026#34;, \u0026#34;❂\u0026#34;, \u0026#34;⁂\u0026#34;, \u0026#34;☮\u0026#34;, \u0026#34;☯\u0026#34;, \u0026#34;☣\u0026#34;] \u0026#34;+\u0026#34;: \u0026#34;+\u0026#34; \u0026#34;,\u0026#34;: {commit: \u0026#34;，\u0026#34;} \u0026#34;-\u0026#34;: \u0026#34;-\u0026#34; .: {commit: \u0026#34;。\u0026#34;} \u0026#34;/\u0026#34;: [\u0026#34;、\u0026#34;, \u0026#34;､\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;／\u0026#34;, \u0026#34;÷\u0026#34;] \u0026#34;:\u0026#34;: {commit: \u0026#34;：\u0026#34;} \u0026#34;;\u0026#34;: {commit: \u0026#34;；\u0026#34;} \u0026#34;\u0026lt;\u0026#34;: [\u0026#34;《\u0026#34;, \u0026#34;〈\u0026#34;, \u0026#34;«\u0026#34;, \u0026#34;‹\u0026#34;, \u0026#34;˂\u0026#34;, \u0026#34;˱\u0026#34;] \u0026#34;=\u0026#34;: [\u0026#34;=\u0026#34;, \u0026#34;々\u0026#34;, \u0026#34;〃\u0026#34;] \u0026#34;\u0026gt;\u0026#34;: [\u0026#34;》\u0026#34;, \u0026#34;〉\u0026#34;, \u0026#34;»\u0026#34;, \u0026#34;›\u0026#34;, \u0026#34;˃\u0026#34;, \u0026#34;˲\u0026#34;] \u0026#34;?\u0026#34;: {commit: \u0026#34;？\u0026#34;} \u0026#34;@\u0026#34;: [\u0026#34;@\u0026#34;, \u0026#34;©\u0026#34;, \u0026#34;®\u0026#34;, \u0026#34;℗\u0026#34;] # \u0026#34;[\u0026#34;: [\u0026#34;「\u0026#34;, \u0026#34;【\u0026#34;, \u0026#34;〔\u0026#34;, \u0026#34;［\u0026#34;, \u0026#34;〚\u0026#34;, \u0026#34;〘\u0026#34;] # \u0026#34;]\u0026#34;: [\u0026#34;」\u0026#34;, \u0026#34;】\u0026#34;, \u0026#34;〕\u0026#34;, \u0026#34;］\u0026#34;, \u0026#34;〛\u0026#34;, \u0026#34;〙\u0026#34;] \u0026#34;\\\\\u0026#34;: [\u0026#34;、\u0026#34;, \u0026#34;\\\\\u0026#34;, \u0026#34;＼\u0026#34;] \u0026#34;^\u0026#34;: {commit: \u0026#34;……\u0026#34;} _: \u0026#34;——\u0026#34; # \u0026#34;`\u0026#34;: [\u0026#34;`\u0026#34;, \u0026#34;‵\u0026#34;, \u0026#34;‶\u0026#34;, \u0026#34;‷\u0026#34;, \u0026#34;′\u0026#34;, \u0026#34;″\u0026#34;, \u0026#34;‴\u0026#34;, \u0026#34;⁗\u0026#34;] \u0026#34;{\u0026#34;: [\u0026#34;『\u0026#34;, \u0026#34;〖\u0026#34;, \u0026#34;｛\u0026#34;] \u0026#34;}\u0026#34;: [\u0026#34;』\u0026#34;, \u0026#34;〗\u0026#34;, \u0026#34;｝\u0026#34;] \u0026#34;|\u0026#34;: [\u0026#34;·\u0026#34;, \u0026#34;・\u0026#34;, \u0026#34;|\u0026#34;, \u0026#34;｜\u0026#34;, \u0026#34;§\u0026#34;, \u0026#34;¦\u0026#34;, \u0026#34;‖\u0026#34;, \u0026#34;︴\u0026#34;] \u0026#34;~\u0026#34;: [\u0026#34;~\u0026#34;, \u0026#34;～\u0026#34;, \u0026#34;˜\u0026#34;, \u0026#34;˷\u0026#34;, \u0026#34;ⸯ\u0026#34;, \u0026#34;≈\u0026#34;, \u0026#34;≋\u0026#34;, \u0026#34;≃\u0026#34;, \u0026#34;≅\u0026#34;, \u0026#34;≇\u0026#34;, \u0026#34;∽\u0026#34;, \u0026#34;⋍\u0026#34;, \u0026#34;≌\u0026#34;, \u0026#34;﹏\u0026#34;, \u0026#34;﹋\u0026#34;, \u0026#34;﹌\u0026#34;, \u0026#34;︴\u0026#34;] 注释掉Markdown常用的符号，写Markdown时就不用切换输入方案，特殊符号直接上屏\n总结 RIME 还有很多自定义功能需要慢慢的去发掘，这里只是个入门。\n引用 RIME https://rime.im/\n",
    "pubDate": "2021-11-25T11:25:45+08:00"
  }, 
  {
    "objectID": 20211122,
    "url": "https://ichochy.com/posts/software/20211122.html",
    "title": "VIM 入门，学会必备的操作命令，模式选择、文本编辑",
    "summary": "VIM 是一个命令文本编辑工具，熟练后可以方便、快捷的完成文体操作，快、快、快、没有更快\n",
    "content": "VIM 是一个命令文本编辑工具，熟练后可以方便、快捷的完成文体操作，快、快、快、没有更快\nVIM 使用 vim filename……打开文本进入VIM正常模式，可以移动光标查看文本，按i进入插入模式，编写文本，完成编写后按ESC 回到正常模式，按:进入命令模式，输入命令wq保存退出\nVIM 模式 正常模式 (Normal-mode) 插入模式 (Insert-mode) 命令模式 (Command-mode) 可视模式 (Visual-mode) 正常模式 vim filename……打开文本进入VIM正常模式，可以移动光标查看文本，ESC 可以从其它模式撤回到正常模式，\n插入模式 正常模式下按i，可以进输入模式，进行文本输入，按ESC进入正常模式\ni 光标处输入 I 光标行头处输入 a 光标下一个字符处输入 A 光标行尾处输入 o 光标向下新建行处输入 O 光标向上新建行处输入 r 光标处替换输入 R 光标处替换输入，直到按ESC进入正常模式 命令模式 正常模式下输入:，可以运行命令，如：:w保存文件；输入:!可以运行系统命令，如：:!ls显示目录文件信息\n:w 保存文本 :w! 强制保存文本 :q 退出文本 :q！ 强制退出文本 :qw 保存并退出文本 可视模式 正常模式下按v，可以进选择模式，选中文本后可以按y复制、按d剪贴、按p粘贴，按ESC进入正常模式\nv 字符选择 V 行选择 Ctrl+v 块选择 VIM 文本编辑 Vim 对于复制，剪切，粘贴有它自己的一套术语。复制被叫做 yank(y),剪切被叫做 delete(d)，以及粘贴被叫做 put(p)。正常模式按下命令完成文本编辑\n复制 yy 复制光标所在行 nyy n 为数字，复制光标所在行向下 n 行，例如 20yy 则是复制 20 行 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标处到该行行首的所有数据 y$ 复制光标处到该行行尾的所有数据 剪切 x 剪切光标后一个字符 X 剪切光标前一个字符 nx n 为数字，连续向后剪切 n 个字符，如10x 连续剪切 10 个字符 dd 剪切光标所在行 ndd n 为数字，剪切光标所在行向下 n 行，如 20dd 剪切 20 行 d1G 剪切光标所在行到第一行的所有数据 dG 剪切光标所在行到最后一行的所有数据 d$ 剪切光标所在处，到该行的最后一个字符 d0 剪切光标所在处，到该行的最前面一个字符 粘贴 p 光标下一行贴出 P 光标上一行贴出 替换 s 单行、%s 全文 g 替换 c 确认 :%s/#/$/gc 如：#替换为$ 魔法 J 向下合并行，合并多行为单行 u 撤消操作 Ctrl+r 恢复操作 . 重复上一动作 总结 VIM 在命令模式下方便、快捷文本编辑工具，相比桌面工具上手会难一点，需要点学习成本，但命令下就是生产力\n引用 VIM https://www.vim.org/\n",
    "pubDate": "2021-11-22T19:25:45+08:00"
  }, 
  {
    "objectID": 20211120,
    "url": "https://ichochy.com/posts/spring/20211120.html",
    "title": "Spring Security 快速创建登录权限，安全管理资源权限",
    "summary": "使用 Spring Security 合理配置页面权限，管理用户登录权限，实现页面安全\n",
    "content": "使用 Spring Security 合理配置页面权限，管理用户登录权限，实现页面安全\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5.2 创建项目 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加 Spring Web 依赖，finish 创建项目 pom.xml 添加依赖 添加 Spring Security 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写项目 创建登录页面 templates/login.html\n\u0026lt;!-- ~ Copyright (c) 2021 iChochy ~ URL:https://ichochy.com ~ Date:2021/06/10 19:44:10 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Login\u0026lt;/h1\u0026gt; \u0026lt;div th:if=\u0026#34;${param.error}\u0026#34;\u0026gt; Invalid username and password. \u0026lt;/div\u0026gt; \u0026lt;div th:if=\u0026#34;${param.logout}\u0026#34;\u0026gt; You have been logged out. \u0026lt;/div\u0026gt; \u0026lt;form th:action=\u0026#34;@{/login}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label\u0026gt; User Name : \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;/label\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label\u0026gt; Password: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/label\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Sign In\u0026#34;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 创建form表单，登录地址/login，方法为post\n创建登出按钮 templates/index.html\n\u0026lt;h1 th:inline=\u0026#34;text\u0026#34;\u0026gt;Hello [[${#httpServletRequest.remoteUser}]]!\u0026lt;/h1\u0026gt; \u0026lt;form th:action=\u0026#34;@{/logout}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Sign Out\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; httpServletRequest.remoteUser获取当前登录用户\n登出地址/logout，方法为post\n配置 MvcConfig 创建com/ichochy/example/MvcConfig.java\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/11/22 19:24:22 */ package com.ichochy.example; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MvcConfig implements WebMvcConfigurer { public void addViewControllers(ViewControllerRegistry registry){ registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login\u0026#34;); } } 添加登录页面控制器，指定地址/login\n登录安全权限配置 创建 WebSecurityConfig，继承 WebSecurityConfigurerAdapter\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/11/22 20:06:22 */ package com.ichochy.example.login; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.factory.PasswordEncoderFactories; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.provisioning.InMemoryUserDetailsManager; @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\u0026#34;/login\u0026#34;).permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(\u0026#34;/login\u0026#34;).permitAll() .and() .logout() .permitAll(); } @Bean @Override public UserDetailsService userDetailsService(){ PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder(); UserDetails userDetails = User.builder() .passwordEncoder(encoder::encode) .username(\u0026#34;MLeo\u0026#34;) .password(\u0026#34;iChochy\u0026#34;) .roles(\u0026#34;iChochy\u0026#34;) .build(); return new InMemoryUserDetailsManager(userDetails); } } 重写configure，配置登录权限，配置非认证（permitAll）地址和认证（authenticated）地址，loginPage自定义登录页面和权限，logout自定义登出页面和权限\nuserDetailsService方法设置用户登录信息存入内存，校验用户登录信息\npasswordEncoder指定密码加密编码 username指定用户为：MLeo password指定密码为：iChochy roles指定角色为：iChochy 项目目录 ├── pom.xml └── src └── main ├── java │ └── com │ └── ichochy │ └── example │ ├── ExampleApplication.java │ ├── MvcConfig.java │ └── login │ └── WebSecurityConfig.java.java └── resources ├── application.properties ├── static └── templates ├── index.html └── login.html 运行项目 启动器 ExampleApplication /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } Dubug 运行项目，启动成功后可以看到默认端口号为8080 浏览器访问 http://localhost:8080，自动302重定向到登录页面 登录成功页面 总结 使用 Spring Security 管理登录权限，实现项目权限安全\nGitHub https://github.com/iChochy/Example\n引用 Securing a Web Application：https://spring.io/guides/gs/securing-web/ ",
    "pubDate": "2021-11-20T18:25:45+08:00"
  }, 
  {
    "objectID": 20211105,
    "url": "https://ichochy.com/posts/spring/20211105.html",
    "title": "Spring 表单验证 Validating Form Input",
    "summary": "表单接交数据并完成数据验证，约束用户数据的接交，已解决数据的正确性和完整性，达到系统的可用性。\n",
    "content": "表单接交数据并完成数据验证，约束用户数据的接交，已解决数据的正确性和完整性，达到系统的可用性。\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5.2 创建项目 参照《Spring 表单提交，Form Submission》 https://ichochy.com/posts/20210530.html\n项目目录 ├── pom.xml └──src └── main ├── java │ └── com │ └── ichochy │ └── example │ ├── ExampleApplication.java │ └── form │ ├── Form.java │ └── FormController.java └── resources ├── application.properties ├── static └── templates ├── form.html └── result.html 表单验证 修改 pom.xml 添加验证库\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改类 Form 添加验证注解\nForm.java\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/10 19:36:10 */ package com.ichochy.example.form; import javax.validation.constraints.NotBlank; import javax.validation.constraints.NotNull; import javax.validation.constraints.Pattern; /** * 表单信息 */ public class Form { @NotNull private long id; @NotBlank private String title; @Pattern(regexp = \u0026#34;https://\\\\w+.com\u0026#34;) private String url; @NotBlank private String content; //get set .... } @NotNull 数字不为空 @NotBlank 字符串不为空 @Pattern 正则表达式 修改控制器 添加 @Valid\npublic String submitForm(@Valid Form form, BindingResult bindingResult, Model model) { model.addAttribute(\u0026#34;form\u0026#34;, form); if(bindingResult.hasErrors()){ return \u0026#34;form\u0026#34;; } return \u0026#34;result\u0026#34;; } @Valid 验证表单对象 BindingResult 验证结果对象 修改页面 form 添加错误提示信息\n\u0026lt;p\u0026gt;Title:\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; th:field=\u0026#34;*{title}\u0026#34;/\u0026gt; \u0026lt;span th:if=\u0026#34;${#fields.hasErrors(\u0026#39;title\u0026#39;)}\u0026#34; th:errors=\u0026#34;*{title}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; fields.hasErrors 验证结果 th:errors 错误信息 运行项目 Dubug 运行项目 main 方法启动项目\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } 服务默认端口号为8080\n浏览器访问 直接访问：http://localhost:8080/form 验证提交信息 提交信息不能通过验证，页面会提示错误信息\n查看表单信息 Submit 提交表单后可以查看到表单提交的信息 总结 添加 @Valid 注解完成表单的后端验证，快速、便捷、安全。\nGitHub https://github.com/iChochy/Example\n引用 Spring 表单提交：https://ichochy.com/posts/20210530.html Validating Form Input：https://spring.io/guides/gs/validating-form-input/ ",
    "pubDate": "2021-11-05T09:12:45+08:00"
  }, 
  {
    "objectID": 20210715,
    "url": "https://ichochy.com/posts/spring/20210715.html",
    "title": "Spring 为 RESTful Web 服务启用跨域请求",
    "summary": "为服务指定 origins 配置，在响应中包含跨域资源共享 (CORS) 标头， 启用跨域请求\n",
    "content": "为服务指定 origins 配置，在响应中包含跨域资源共享 (CORS) 标头， 启用跨域请求\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 参照《Spring 构建 RESTful Web 服务 Hello World》 https://ichochy.com/posts/20210615.html\n项目目录 ├── pom.xml └── src └── main └── java └── com └── ichochy └── example ├── ExampleApplication.java └── restful ├── Greeting.java ├── RequsetService.java └── RESTFulController.java 启用 CORS 您可以从单个控制器或全局启用跨域资源共享 (CORS)：\n控制器配置 CORS 全局配置 CORS 控制器中配置 CORS 为了使 RESTful Web 服务在其响应中包含 CORS 访问控制标头，可以在控制器或方法添加注释 @CrossOrigin，启用 CORS，在RESTFulController中添加\n控制器添加注解 @CrossOrigin 当前类中所有方法启用跨域资源共享 (CORS)\n@CrossOrigin(origins = \u0026#34;https://ichochy.com\u0026#34;) @RestController public class RESTFulController { @GetMapping(\u0026#34;/greeting\u0026#34;) public Greeting greeting(@RequestParam(value = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;World\u0026#34;) String name) { return new Greeting(counter.incrementAndGet(), String.format(template, name)); } } 方法添加注解 @CrossOrigin 当前方法启用跨域资源共享 (CORS)\n@CrossOrigin(origins = \u0026#34;https://ichochy.com\u0026#34;) @GetMapping(\u0026#34;/greeting\u0026#34;) public Greeting greeting(@RequestParam(value = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;World\u0026#34;) String name) { return new Greeting(counter.incrementAndGet(), String.format(template, name)); } 全局配置 CORS 通过 WebMvcConfigurer，自定义配置 CORS，统一管理，在RequsetService中添加\n@Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/greeting\u0026#34;).allowedOrigins(\u0026#34;https://ichochy.com\u0026#34;); } }; } @CrossOrigin 属性说明 origins 允许跨域请求的源列表 methods 支持的 HTTP 请求方法列表 allowedHeaders 实际请求中允许的请求头列表 exposedHeaders 用户代理中允许客户端响应头列表 allowCredentials 浏览器是否响应发送凭据 maxAge 缓存持续时间的最长期限 运行项目 Dubug 运行项目 main 方法启动项目\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } 服务默认端口号为8080\n访问测试 访问：http://localhost:8080/greeting\n{\u0026#34;id\u0026#34;:1,\u0026#34;content\u0026#34;:\u0026#34;Hello, World!\u0026#34;} 跨域访问测试 在网站（https://ichochy.com）上 Ajax 跨域访问当前接口，没有出现跨域问题，可以正常访问\nResponse Headers\nAccess-Control-Allow-Origin: https://ichochy.com 返回信息\n{\u0026#34;id\u0026#34;:1,\u0026#34;content\u0026#34;:\u0026#34;Hello, World!\u0026#34;} 总结 如果没有添加 @CrossOrigin，会出现如下错误信息：\nAccess to XMLHttpRequest at \u0026lsquo;http://localhost:8080/greeting\u0026rsquo; from origin \u0026lsquo;https://ichochy.com\u0026rsquo; has been blocked by CORS policy: No \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header is present on the requested resource.\n添加注解@CrossOrigin，启用跨域资源共享 (CORS)。默认支持所有域名跨域访问当前接口，通过注解属性origins可以指定一个或多个域名地址\n//默认，所用域名都可访问 @CrossOrigin //单个域名 @CrossOrigin(origins = \u0026#34;https://ichochy.com\u0026#34;) //多个域名 @CrossOrigin(origins = {\u0026#34;https://ichochy.com\u0026#34;,\u0026#34;http://localhost:8888\u0026#34;}) GitHub https://github.com/iChochy/Example\n引用 Ajax：https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX Enabling Cross Origin Requests：https://spring.io/guides/gs/rest-service-cors/ ",
    "pubDate": "2021-07-15T21:22:45+08:00"
  }, 
  {
    "objectID": 20210712,
    "url": "https://ichochy.com/posts/life/20210712.html",
    "title": "快捷支付停车费，免去扫码操作，快捷指令快速支付",
    "summary": "小区一直都是停车难，每次还要扫码缴停车费，车库网络还不好，到小区门口就排起长队扫码。快人一步，创建快捷指令，一键支付停车费。\n",
    "content": "小区一直都是停车难，每次还要扫码缴停车费，车库网络还不好，到小区门口就排起长队扫码。快人一步，创建快捷指令，一键支付停车费。\n创建指令 用苹果手机的快捷指令来创建，以怡园的二维码为例来创建快捷指令。\n获取二维码地址 拿出你的手机，支付宝扫描缴费二维码，复制二维码地址，创建快捷指令会用到，很关键的一步。\n新建快捷指令 新建快捷指令，添加操作 添加文稿，选择文本，输入启动支付宝的 scheme 地址：alipays://platformapi/startapp?appId=20000067\u0026amp;url= 添加文稿，选择文本，输入二维码地址 添加脚本，选择编码URL，编码二维码地址的文本 添加文稿，选择合并文本，合并支付宝 scheme 地址的文本和二维码地址的文本，使用自定合并 添加网页，选择打开URL，打开合并后的文本 设置快捷指令的名称和图标 编辑，添加到主屏幕 使用快捷指令 打开主屏幕的快捷缴费，自动打开支付宝，完成停车缴费\n添加分享指令 快捷指令地址 指令分享地址：https://www.icloud.com/shortcuts/addcda91b2ce4ade8f35b79d0791f869\n添加快捷指令 Safari 浏览器打开快捷指令地址，获取捷径 查看快捷指令的内容并添加 注: 在手机设置中，找到快捷指令并打开允许不受信任的快捷指令开关，然后就可以直接添加分享的快捷指令\n总结 通过scheme启动支付宝，打开二维码地址完成缴费操作，快人一步，去掉了找二维码和扫二维码的操作。\n更快一步，在支付宝中输入车牌号后的支付页面地址放入快捷指令中，替换掉原来的二维码地址，就可以不用再次输入车牌号，直接支付 引用 通过scheme启动支付宝\n快捷指令使用手册\n",
    "pubDate": "2021-07-12T12:22:45+08:00"
  }, 
  {
    "objectID": 20210710,
    "url": "https://ichochy.com/posts/life/20210710.html",
    "title": "居家全屋无线 Wi-Fi 网络改造",
    "summary": "家里以前是网孔面板，没有用上，前几天老婆说房间里网速不好，Wi-Fi 老掉线，于是有了改造全屋 Wi-Fi 的想法。\n",
    "content": "家里以前是网孔面板，没有用上，前几天老婆说房间里网速不好，Wi-Fi 老掉线，于是有了改造全屋 Wi-Fi 的想法。\n改造方案 中继/桥接 MESH 组网 AC+AP 方案说明 中继/桥接 需要手动设置，配置中继的无线 Wi-Fi，放大原有的无线信号的覆盖范围，信号衰减严重\nMESH 组网 自动设置，网络统一管理，支持有线，无线，混合等回程方式，有良好的漫游体验\nAC+AP AC 统一管理，有线连接 AP，信号稳定，有良好的漫游体验\nAC+AP 组网 已经预埋网线，选择 AC+AP 组网，信号稳定无衰减，无线环境更加理想。添加 AC 路由器，POE 网线供电，直接更换原有网孔面板。\n添加 AC 路由器 替换原有的面板 水晶头接法 一般选用 T568B 直连的接法，注意线的颜色，一定要一根一根的对，不然会导致网络不通，或只能百兆以内。\n问题 网速只能百兆以内？ 查看水晶头接线有没有问题，线的颜色排列是否正确。 MAC 电脑搜索不到 5G 频率的 Wi-Fi 热点？ 查看电脑无线网卡支持的信道，修改热点的信道。 按住option键查以查询网络连接的具体信息 在线测速 https://test.ustc.edu.cn/ 总结 刚开始网速只能达到 10Mbps，现在通过 AC+AP 的方式可以达到 200Mbps，提升非常明显。 TP-LINK 的 AC 不能很好的管理终端信息，不能对单个终端进行别名添加、限速和网络禁用。 TP-LINK 的 AP 面板发热量大，长时间高温运行。 ",
    "pubDate": "2021-07-10T12:22:45+08:00"
  }, 
  {
    "objectID": 20210620,
    "url": "https://ichochy.com/posts/spring/20210620.html",
    "title": "Spring 调用 RESTful Web 服务 Hello World",
    "summary": "使用 Spring 的 RestTemplate 调用 HTTP 请求，实现 RESTful Web 服务调用\n",
    "content": "使用 Spring 的 RestTemplate 调用 HTTP 请求，实现 RESTful Web 服务调用\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 New Project 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加依赖 添加 Spring Web 依赖，finish 创建项目 pom.xml 中手动管理依赖模块\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写项目 创建数据对象 /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/17 11:40:17 */ package com.ichochy.example.restful; public class Greeting { private Long id; private String content; /** * JSON 转换时需要无参构造方法 */ public Greeting() {} /** * 用参的构造方法 * @param id * @param content */ public Greeting(Long id, String content) { this.id = id; this.content = content; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } 注： 需要一个无参的构造方法，JSON转换时需要\n创建请求服务 /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/25 09:07:25 */ package com.ichochy.example.restful; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class RequsetService { @Bean public RestTemplate restTemplate(RestTemplateBuilder builder) { return builder.build(); } @Bean public ObjectMapper mapper() { return new ObjectMapper(); } @Bean public CommandLineRunner run(RestTemplate restTemplate,ObjectMapper mapper) throws Exception { return args -\u0026gt; { Greeting object = restTemplate.getForObject( \u0026#34;http://localhost:8080/greeting\u0026#34;, Greeting.class); System.out.println(mapper.writeValueAsString(object)); }; } } @Service 注释，它将类标记为服务 @Bean 注释，定义类的方法实例化 RestTemplate.getForObject，GET 请求地址，返回数据对象 ObjectMapper.writeValueAsString，对象转化为字符串 项目目录 ├── pom.xml └── src └── main └── java └── com └── ichochy └── example ├── ExampleApplication.java └── restful ├── Greeting.java ├── RequsetService.java └── RESTFulController.java 运行项目 Dubug 运行项目 main 方法启动项目\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } 服务默认端口号为8080\n访问测试 日志中会打印如下信息，说明RestTemplate.getForObject成功请求并返回数据对象\n{\u0026#34;id\u0026#34;:1,\u0026#34;content\u0026#34;:\u0026#34;Hello, World!\u0026#34;} 总结 RestTemplate.getForObject成功请求并返回数据对象 ObjectMapper.writeValueAsString将对象转化为字符串 GitHub https://github.com/iChochy/Example\n引用 Jackson：https://github.com/FasterXML/jackson Consuming RESTFul Service：https://spring.io/guides/gs/consuming-rest/ ",
    "pubDate": "2021-06-20T11:33:45+08:00"
  }, 
  {
    "objectID": 20210615,
    "url": "https://ichochy.com/posts/spring/20210615.html",
    "title": "Spring 构建 RESTful Web 服务 Hello World",
    "summary": "使用 Spring 创建 RESTful Web 服务，实现Hello World的 RESTful 请求\n",
    "content": "使用 Spring 创建 RESTful Web 服务，实现Hello World的 RESTful 请求\n什么是 RESTful RESTful 是应用程序接口的一种架构风格，它使用 HTTP 请求来访问和使用数据。请求方式包含 GET、PUT、POST 和 DELETE 类型，这些类型是指有关资源操作的读取、更新、创建和删除。\nRESTful 协议定义 HTTP 方法如下：\nGET 检索资源 PUT 更新资源 POST 创建资源 DELETE 删除资源 开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 New Project 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加依赖 添加 Spring Web 依赖，finish 创建项目 pom.xml 中手动管理依赖模块\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写项目 创建数据对象 /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/17 11:40:17 */ package com.ichochy.example.restful; public class Greeting { private Long id; private String content; /** * 用参的构造方法 * @param id * @param content */ public Greeting(Long id, String content) { this.id = id; this.content = content; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } 创建控制器 /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/17 11:44:17 */ package com.ichochy.example.restful; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.concurrent.atomic.AtomicLong; @RestController public class RESTFulController { private static final String template = \u0026#34;Hello, %s!\u0026#34;; private final AtomicLong counter = new AtomicLong(); @GetMapping(\u0026#34;/greeting\u0026#34;) public Greeting greeting(@RequestParam(value = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;World\u0026#34;) String name) { return new Greeting(counter.incrementAndGet(), String.format(template, name)); } } @RestController 注释，它将类标记为控制器，其中每个方法返回的是对象而不是视图。 它是同时包含@Controller和@ResponseBody @GetMapping 注释，定义 /greeting 为 HTTP GET 请求 @RequestParam 注释，定义参数（name）为请求参数，默认值为 “World” 项目目录 ├── pom.xml └── src └── main └── java └── com └── ichochy └── example ├── ExampleApplication.java └── restful ├── Greeting.java └── RESTFulController.java 运行项目 Dubug 运行项目 main 方法启动项目\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } 服务默认端口号为8080\n访问测试 访问：http://localhost:8080/greeting\n{\u0026#34;id\u0026#34;:1,\u0026#34;content\u0026#34;:\u0026#34;Hello, World!\u0026#34;} 访问：http://localhost:8080/greeting?name=iChochy\n{\u0026#34;id\u0026#34;:2,\u0026#34;content\u0026#34;:\u0026#34;Hello, iChochy!\u0026#34;} 总结 通过 Spring 可以快速创建 RESTful 请求服务，实现服务接口统一。 其它请求方式可以通过 @RequestMapping 注释中的 method 参数指定，如 @RequestMapping(method=GET)。 默认情况使用 Jackson JSON库自动将类型实例编组为 JSON GitHub https://github.com/iChochy/Example\n引用 Jackson：https://github.com/FasterXML/jackson Spring rest service：https://spring.io/guides/gs/rest-service/ ",
    "pubDate": "2021-06-15T22:25:45+08:00"
  }, 
  {
    "objectID": 20210612,
    "url": "https://ichochy.com/posts/blog/20210612.html",
    "title": "使用 GitHub Actions 自动上传搜索记录到 Algolia",
    "summary": "博客使用 Algolia 实现搜索功能，手动上传搜索记录数据一直很烦琐，只好苦学 API 和 Action，通过 GitHub Actions 实现自动上传搜索记录到 Algolia，完美呈现。\n",
    "content": "博客使用 Algolia 实现搜索功能，手动上传搜索记录数据一直很烦琐，只好苦学 API 和 Action，通过 GitHub Actions 实现自动上传搜索记录到 Algolia，完美呈现。\nGitHub Actions 使用 GitHub Actions 在您的存储库中自动化、自定义和执行您的软件开发工作流程。您可以发现、创建和共享操作以执行您喜欢的任何作业，包括 CI/CD，并在完全自定义的工作流中组合操作。\n生成搜索数据 数据格式 [ { \u0026#34;objectID\u0026#34;: 1, \u0026#34;url\u0026#34;: \u0026#34;https://ichochy.com\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;回忆中的明天\u0026#34;, \u0026#34;summary\u0026#34;: \u0026#34;码农小站，写点Java、Swift和感悟\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;码农小站，写点Java、Swift和感悟\u0026#34;, \u0026#34;pubDate\u0026#34;: \u0026#34;2021-06-01T11:25:45+08:00\u0026#34; } ] 数据生成参考： 使用 Algolia 云引擎，实现个人博客 Hugo 本地智能搜索\n设置 Secrets Settings =\u0026gt; Secrets =\u0026gt; New repository secret\nAlgolia 参数信息 APPLICATION_ID （应用程序ID） ADMIN_API_KEY （管理API KEY，注意保密，不可共享） INDEX_NAME （索引名称） FILE_PATH （搜索数据路径） 注： FILE_PATH 以项目为起点目录，如: iChochy.github.io/docs/algolia.json 填写 docs/algolia.json\nAPI KEYS 新建 Actions 新建自己的工作流程 写入工作流程 文件路径如：iChochy.github.io/.github/workflows/main.yml\n具体内容 name: Algolia Upload Records on: [push] #推送时执行 jobs: algolia: runs-on: ubuntu-latest steps: - name: Checkout # 获取代码 Checkout uses: actions/checkout@v2 - name: Upload Records # 使用 Action uses: iChochy/Algolia-Upload-Records@main # 设置环境变量 env: APPLICATION_ID: ${{secrets.APPLICATION_ID}} ADMIN_API_KEY: ${{secrets.ADMIN_API_KEY}} INDEX_NAME: ${{secrets.INDEX_NAME}} FILE_PATH: ${{secrets.FILE_PATH}} 执行过程和结果 Actions =\u0026gt; Workflows 中查询所有工作流程的工作日志\n上传记录成功后会返回数据记录 ID\n引用 GitHub 操作快速入门：https://docs.github.com/en/actions/quickstart Algolia Upload Records Action：https://github.com/iChochy/Algolia-Upload-Records ",
    "pubDate": "2021-06-12T15:25:45+08:00"
  }, 
  {
    "objectID": 20210602,
    "url": "https://ichochy.com/posts/spring/20210602.html",
    "title": "Spring 文件上传，Uploading Files",
    "summary": "项目中文件上传是必不可少的，快速实现将客户端文件上传至服务器，实现文件的在线管理。\n",
    "content": "项目中文件上传是必不可少的，快速实现将客户端文件上传至服务器，实现文件的在线管理。\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 New Project 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加依赖 添加 web、thymeleaf 依赖，finish 创建项目 pom.xml 中手动管理依赖模块\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写项目 文件操作接口 package com.ichochy.web.upload.storage; import org.springframework.core.io.Resource; import org.springframework.web.multipart.MultipartFile; import java.nio.file.Path; import java.util.stream.Stream; public interface StorageService { /** * 初始化操作 */ void init(); /** * 存储文件 * @param file */ void store(MultipartFile file); /** * 加载所有文件路径 * @return */ Stream\u0026lt;Path\u0026gt; loadAll(); /** * 加载文件路径 * @param filename * @return */ Path load(String filename); /** * 加载文件数据 * @param filename * @return */ Resource loadAsResource(String filename); /** * 初始化完全删除 */ void deleteAll(); } 文件操作接口实现 package com.ichochy.web.upload.storage; import org.springframework.core.io.Resource; import org.springframework.core.io.UrlResource; import org.springframework.stereotype.Service; import org.springframework.util.FileSystemUtils; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.net.MalformedURLException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardCopyOption; import java.util.stream.Stream; @Service public class FileSystemStorageService implements StorageService{ //文件存储路径 private Path rootLocation = Paths.get(\u0026#34;temp\u0026#34;); @Override public void init() { try { //创建文件夹 Files.createDirectories(rootLocation); } catch (IOException e) { throw new RuntimeException(\u0026#34;Could not initialize storage\u0026#34;, e); } } @Override public void store(MultipartFile file) { try { if (file.isEmpty()) { throw new RuntimeException(\u0026#34;Failed to store empty file.\u0026#34;); } //存储文件路径 Path destinationFile = this.rootLocation.resolve( Paths.get(file.getOriginalFilename())) .normalize().toAbsolutePath(); if (!destinationFile.getParent().equals(this.rootLocation.toAbsolutePath())) { // This is a security check throw new RuntimeException( \u0026#34;Cannot store file outside current directory.\u0026#34;); } try (InputStream inputStream = file.getInputStream()) { //复制存储文件 Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING); } } catch (IOException e) { throw new RuntimeException(\u0026#34;Failed to store file.\u0026#34;, e); } } @Override public Stream\u0026lt;Path\u0026gt; loadAll() { try { return Files.walk(this.rootLocation, 1) .filter(path -\u0026gt; !path.equals(this.rootLocation)) .map(this.rootLocation::relativize); } catch (IOException e) { throw new RuntimeException(\u0026#34;Failed to read stored files\u0026#34;, e); } } @Override public Path load(String filename) { return rootLocation.resolve(filename); } @Override public Resource loadAsResource(String filename) { try { Path file = load(filename); Resource resource = new UrlResource(file.toUri()); if (resource.exists() || resource.isReadable()) { return resource; } else { throw new RuntimeException( \u0026#34;Could not read file: \u0026#34; + filename); } } catch (MalformedURLException e) { throw new RuntimeException(\u0026#34;Could not read file: \u0026#34; + filename, e); } } @Override public void deleteAll() { FileSystemUtils.deleteRecursively(rootLocation.toFile()); } } 创建控制器 创建控制器 FileUploadController\npackage com.ichochy.web.upload; import com.ichochy.web.upload.storage.StorageService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.CommandLineRunner; import org.springframework.context.annotation.Bean; import org.springframework.core.io.Resource; import org.springframework.http.HttpHeaders; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import java.util.stream.Collectors; @Controller public class FileUploadController { @Autowired private StorageService storageService; @GetMapping(value = \u0026#34;/upload\u0026#34;) public String listFiles(Model model){ model.addAttribute(\u0026#34;files\u0026#34;, storageService.loadAll().map( path -\u0026gt; MvcUriComponentsBuilder.fromMethodName(FileUploadController.class, \u0026#34;getFiles\u0026#34;, path.getFileName().toString()).build().toUri().toString()) .collect(Collectors.toList())); return \u0026#34;uploadForm\u0026#34;; } @GetMapping(value = \u0026#34;/files/{filename}\u0026#34;) public ResponseEntity\u0026lt;Resource\u0026gt; getFiles(@PathVariable String filename){ Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + file.getFilename() + \u0026#34;\\\u0026#34;\u0026#34;).body(file); } @PostMapping(value = \u0026#34;/upload\u0026#34;) public String uploadFile(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file, RedirectAttributes redirectAttributes){ storageService.store(file); redirectAttributes.addFlashAttribute(\u0026#34;message\u0026#34;, \u0026#34;You successfully uploaded \u0026#34; + file.getOriginalFilename() + \u0026#34;!\u0026#34;); //重定向开始页面 return \u0026#34;redirect:/upload\u0026#34;; } /** * 初始化操作 * @param storageService * @return */ @Bean CommandLineRunner init(StorageService storageService) { return (args) -\u0026gt; { storageService.deleteAll(); storageService.init(); }; } } 创建上传页面 新建 uploadForm.html\n\u0026lt;html xmlns:th=\u0026#34;https://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div th:if=\u0026#34;${message}\u0026#34;\u0026gt; \u0026lt;h2 th:text=\u0026#34;${message}\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;form method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;/upload\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;File to upload:\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Upload\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;file : ${files}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;${file}\u0026#34; th:text=\u0026#34;${file}\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 添加项目配置 修改 application.properties\n# thymeleaf 缓存关闭 spring.thymeleaf.cache=false # 最大文件数据 spring.servlet.multipart.max-file-size=128KB # 最大请求数据 spring.servlet.multipart.max-request-size=128KB 项目目录 ├── pom.xml ├── src │ └── main │ ├── java │ │ └── com │ │ └── ichochy │ │ └── web │ │ ├── WebApplication.java │ │ └── upload │ │ ├── FileUploadController.java │ │ └── storage │ │ ├── FileSystemStorageService.java │ │ └── StorageService.java │ └── resources │ ├── application.properties │ ├── static │ └── templates │ ├── index.html │ └── uploadForm.html └── temp 注解说明 注解 位置 说明 @Controller 类 控制器 @RequestMapping 类 控制器请求路径 @Service 类 注册服务类 @GetMapping 方法 Get 请求路径 @PostMapping 方法 Post 请求路径 @Autowired 参数 自动装配类 @PathVariable 参数 路径变量 @RequestParam 参数 请求参数 @Bean 方法 注册类 运行项目 Dubug 运行项目 启动成功后可以看到默认端口号为8080 浏览器访问 直接访问：http://localhost:8080/upload 文件上传 浏览文件，Upload 上传文件 文件下载 点击文件列表可下载文件 GitHub https://github.com/iChochy/Example\n引用 快速开始：https://spring.io/quickstart 文件上传：https://spring.io/guides/gs/uploading-files/ ",
    "pubDate": "2021-06-02T11:25:45+08:00"
  }, 
  {
    "objectID": 20210530,
    "url": "https://ichochy.com/posts/spring/20210530.html",
    "title": "Spring 表单提交，Form Submission",
    "summary": "表单提交完成数据的交互，实现数据的传递并进行系统处理或反馈，完成用户的指令。\n",
    "content": "表单提交完成数据的交互，实现数据的传递并进行系统处理或反馈，完成用户的指令。\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 New Project 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加依赖 添加 web、thymeleaf 依赖，finish 创建项目 pom.xml 中手动管理依赖模块\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写项目 表单信息对象 创建 Form 对象，用来接收、传递表单数据\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/10 19:36:10 */ package com.ichochy.example.form; /** * 表单信息 */ public class Form { private long id; private String title; private String url; private String content; public long getId() { return id; } public void setId(long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } } 创建控制器 创建控制器 FormController，接收表单数据\n/* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example.form; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.PostMapping; @Controller public class FormController { /** * 打开表单 * @param model * @return */ @GetMapping(value = \u0026#34;/form\u0026#34;) public String openForm(Model model) { model.addAttribute(\u0026#34;form\u0026#34;, new Form()); return \u0026#34;form\u0026#34;; } /** * 提交表单 * @param form * @param model * @return */ @PostMapping(value = \u0026#34;/form\u0026#34;) public String submitForm(@ModelAttribute Form form, Model model) { model.addAttribute(\u0026#34;form\u0026#34;, form); return \u0026#34;result\u0026#34;; } } Model 为前端视图模型，添加视图数据，供视图展示 @Controller 注解，告诉 Spring 该类（FormController）为请求控制器 @ModelAttribute 注解，告诉 Spring 该对象为视图请求参数对象 @GetMapping(“/form) 注解，告诉 Spring 该方法（openForm）来响应 http://localhost:8080/form 的 get 请求。 @PostMapping(“/form) 注解，告诉 Spring 该方法（submitForm）来响应 http://localhost:8080/form 的 get 请求。 方法返回 String 为展示对应的视图名称，如：return \u0026quot;form\u0026quot;展示 form.html 视图 创建表单页面 新建 form.html，接交表单数据\n\u0026lt;!-- ~ Copyright (c) 2021 iChochy ~ URL:https://ichochy.com ~ Date:2021/06/10 19:44:10 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Form\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Form\u0026lt;/h1\u0026gt; \u0026lt;form th:action=\u0026#34;@{/form}\u0026#34; th:object=\u0026#34;${form}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Id: \u0026lt;br\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; th:field=\u0026#34;*{id}\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Title:\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; th:field=\u0026#34;*{title}\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;URL: \u0026lt;br\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; th:field=\u0026#34;*{url}\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: \u0026lt;br\u0026gt;\u0026lt;textarea th:field=\u0026#34;*{content}\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;Reset\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; th:action=\u0026quot;@{/form}\u0026quot; 设置表单的请求地址 method=\u0026ldquo;post\u0026rdquo; 设置表单的请求方式为 post th:object=\u0026quot;${form}\u0026quot; 设置表单的请求数据对象 th:field=\u0026quot;*{id}\u0026quot; 设置表单的请求参数属性 创建结果页面 新建 result.html，展示表单数据\n\u0026lt;!-- ~ Copyright (c) 2021 iChochy ~ URL:https://ichochy.com ~ Date:2021/06/10 19:44:10 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Result\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Form\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;Result\u0026lt;/h1\u0026gt; \u0026lt;p th:text=\u0026#34;\u0026#39;Id: \u0026#39; + ${form.id}\u0026#34;/\u0026gt; \u0026lt;p th:text=\u0026#34;\u0026#39;Title: \u0026#39; + ${form.title}\u0026#34;/\u0026gt; \u0026lt;p th:text=\u0026#34;\u0026#39;URL: \u0026#39; + ${form.url}\u0026#34;/\u0026gt; \u0026lt;p th:text=\u0026#34;\u0026#39;Message: \u0026#39; + ${form.content}\u0026#34;/\u0026gt; \u0026lt;a href=\u0026#34;/form\u0026#34;\u0026gt;Submit another message\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ${form.id} 获取数据对象属性值展示 项目目录 ├── pom.xml └──src └── main ├── java │ └── com │ └── ichochy │ └── example │ ├── ExampleApplication.java │ └── form │ ├── Form.java │ └── FormController.java └── resources ├── application.properties ├── static └── templates ├── form.html └── result.html 运行项目 Dubug 运行项目 启动成功后可以看到默认端口号为8080 浏览器访问 直接访问：http://localhost:8080/form 查看表单信息 Submit 提交表单后可以查看到表单提交的信息 GitHub https://github.com/iChochy/Example\n引用 Handling Form Submission：https://spring.io/guides/gs/handling-form-submission/ Thymeleaf Documentation：https://www.thymeleaf.org/documentation.html ",
    "pubDate": "2021-05-30T22:25:45+08:00"
  }, 
  {
    "objectID": 20210525,
    "url": "https://ichochy.com/posts/spring/20210525.html",
    "title": "Spring 开篇，创建第一个 Web 项目 Hello World",
    "summary": "学习 Java，就离不开 Spring ，现在就用 Spring 框架快速创建一个 WEB 项目，欢迎来到我的世界 Hello World。\n",
    "content": "学习 Java，就离不开 Spring ，现在就用 Spring 框架快速创建一个 WEB 项目，欢迎来到我的世界 Hello World。\n开发工具 IDEA: 2021.1.2 Java: 1.8 Spring Boot: 2.5 创建项目 打开 IDEA 创建新项目 New Project，使用 start.spring.io 快速构建 添加 Spring Web 依赖，finish 创建项目 项目目录 ├── pom.xml └── src └── main ├── java │ └── com │ └── ichochy │ └── example │ ├── ExampleApplication.java │ └── hello │ └──HelloWorldController.java └── resources ├── application.properties ├── static └── templates 编写项目 创建控制器 HelloWorldController package com.ichochy.example.hello; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloWorldController { @GetMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(value = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;World\u0026#34;) String name) { return String.format(\u0026#34;Hello %s!\u0026#34;, name); } } @RestController 注解，告诉 Spring 该类（HelloWorldController）为请求控制器 @GetMapping(“/hello”) 注解，告诉 Spring 该方法（hello）来响应 http://localhost:8080/hello 的 get 请求。 @RequestParam 注解，告诉 Spring 该参数（name）为请求参数，默认值为 “World”。 创建启动器 ExampleApplication /* * Copyright (c) 2021 iChochy * URL:https://ichochy.com * Date:2021/06/09 22:07:09 */ package com.ichochy.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); } } @SpringBootApplication 注释，包如下注解的合集：\n@Configuration：将类标记为应用程序配置类 @EnableAutoConfiguration：告诉 Spring Boot 根据类路径自动启用配置 @ComponentScan：告诉 Spring 在com.ichochy.example当前包中查找组件、配置、服务和控制器 运行项目 Dubug 运行项目，启动成功后可以看到默认端口号为8080 浏览器访问 http://localhost:8080/hello，Web 项目默认返回 Hello World 添加 name 参数访问 http://localhost:8080/hello?name=iChochy GitHub https://github.com/iChochy/Example\n引用 快速开始：https://spring.io/quickstart ",
    "pubDate": "2021-05-25T16:25:45+08:00"
  }, 
  {
    "objectID": 20210522,
    "url": "https://ichochy.com/posts/blog/20210522.html",
    "title": "使用 Algolia 云引擎，实现个人博客 Hugo 本地智能搜索",
    "summary": "一直想实现博客的本地搜索，没有找到好的实现方式。尝试了好几个方案，现在使用 Algolia 实现本地搜索。实现方式简单，每月可搜索 10000 次，可以一直白票下去\n",
    "content": "一直想实现博客的本地搜索，没有找到好的实现方式。尝试了好几个方案，现在使用 Algolia 实现本地搜索。实现方式简单，每月可搜索 10000 次，可以一直白票下去\n构建数据 1、 修改配置文件 修改 config.toml，配置生成 algolia.json 文件\n[outputs] home = [\u0026#34;HTML\u0026#34;,\u0026#34;RSS\u0026#34;,\u0026#34;TXT\u0026#34;,\u0026#34;Algolia\u0026#34;] section = [\u0026#34;HTML\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;] term = [\u0026#34;HTML\u0026#34;] [outputFormats.Algolia] mediaType = \u0026#34;application/json\u0026#34; baseName = \u0026#34;algolia\u0026#34; isPlainText = true 2、 添加模版文件 创建文件/layouts/_default/list.algolia.json\n[ {{- range $index, $entry := .Site.RegularPages }} {{- if $index }}, {{ end }} { \u0026#34;objectID\u0026#34;: {{ .File.TranslationBaseName }}, \u0026#34;url\u0026#34;: {{ .Permalink | jsonify }}, \u0026#34;title\u0026#34;: {{ .Title | jsonify }}, \u0026#34;summary\u0026#34;: {{ .Summary | jsonify }}, \u0026#34;content\u0026#34;: {{ .Plain | jsonify }}, \u0026#34;pubDate\u0026#34;: {{ .PublishDate | jsonify }} } {{- end }} ] 注：objectID为algolia中的数据ID，可以用此ID进行CURD操作\n3、生成数据文件 运行hugo，生成数据文件algolia.json\n[ { \u0026#34;objectID\u0026#34;: 20210522, \u0026#34;url\u0026#34;: \u0026#34;https://ichochy.com/posts/20210522/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;使用 Algolia 云引擎，实现个人博客 Hugo 本地智能搜索\u0026#34;, \u0026#34;summary\u0026#34;: \u0026#34;现在使用 Algolia 实现本地搜索。实现方式简单，每月可搜索 10000 次，可以一直白票下去\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;一直想实现博客的本地搜索，没有找到好的实现方式。尝试了好几个方案，现在使用 Algolia 实现本地搜索。实现方式简单，每月可搜索 10000 次…… \u0026#34;, \u0026#34;pubDate\u0026#34;: \u0026#34;2021-05-22T10:22:45+08:00\u0026#34; }, { \u0026#34;objectID\u0026#34;: 20210418, \u0026#34;url\u0026#34;: \u0026#34;https://ichochy.com/posts/20210418/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Elasticsearch, Kibana, Logstash, Filebeat 实现日志的自动采集、搜索和分析\u0026#34;, \u0026#34;summary\u0026#34;: \u0026#34;实时地对数据进行搜索、分析和可视化\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）…… \u0026#34;, \u0026#34;pubDate\u0026#34;: \u0026#34;2021-04-18T10:22:45+08:00\u0026#34; }, …… ] 构建索引数据 1、创建Algolia帐号 官网注册：https://www.algolia.com/\n2、创建应用程序 新建Application，选择免费套餐 3、创建索引 新建Index，存储要在Algolia中进行搜索的数据 4、导入记录 可以通过API推送数据或直接上传记录 手动上传 5、配置搜索属性 配置可搜索的属性，通过属性搜索数据 6、配置自定义排名 选择排序属性，对搜索结果进行排序 构建搜索页面 1、创建搜索页面 \u0026lt;h3\u0026gt;搜索\u0026lt;/h3\u0026gt; \u0026lt;div id=\u0026#34;searchbox\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div id=\u0026#34;hits\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 2、引入主题样式 \u0026lt;!-- Include only the reset 基本样式--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/instantsearch.css@7.3.1/themes/reset-min.css\u0026#34; integrity=\u0026#34;sha256-t2ATOGCtAIZNnzER679jwcFcKYfLlw01gli6F6oszk8=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;!-- or include the full Satellite theme 主题样式--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css\u0026#34; integrity=\u0026#34;sha256-TehzF/2QvNKhGQrrNpoOb2Ck4iGZ1J/DI4pkd2oUsBc=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 3、引入搜索引擎 API \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js\u0026#34; integrity=\u0026#34;sha256-EXPXz4W6pQgfYY3yTpnDa3OH8/EPn16ciVsPQ/ypsjk=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/instantsearch.js@4.8.3/dist/instantsearch.production.min.js\u0026#34; integrity=\u0026#34;sha256-LAGhRRdtVoD6RLo2qDQsU2mp+XVSciKRC8XPOBWmofM=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4、编写搜索 JS // 构建搜索客户端 const searchClient = algoliasearch(\u0026#39;Application_ID\u0026#39;, \u0026#39;Search-Only_API_Key\u0026#39;); // 构建索引搜索 const search = instantsearch({ indexName: \u0026#39;Index_Name\u0026#39;, searchClient, }); //展示数据模版 var hitTemplate = \u0026#39;\u0026lt;article class=\u0026#34;post\u0026#34;\u0026gt;\u0026#39; + \u0026#39;\u0026lt;h2 class=\u0026#34;post-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{url}}\u0026#34;\u0026gt;{{{_highlightResult.title.value}}}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\u0026#39; + \u0026#39;{{{_highlightResult.summary.value}}}\u0026#39; + \u0026#39;\u0026lt;/article\u0026gt;\u0026#39;; //无数据模版 var noResultsTemplate = \u0026#39;\u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt;没有找到 \u0026lt;strong\u0026gt;{{query}}\u0026lt;/strong\u0026gt; 相关的结果\u0026lt;/div\u0026gt;\u0026#39;; //配置添加小部件 search.addWidgets([ instantsearch.widgets.searchBox({ container: \u0026#39;#searchbox\u0026#39;, placeholder: \u0026#39;请输入搜索内容……\u0026#39;, autofocus: true, }), instantsearch.widgets.hits({ container: \u0026#39;#hits\u0026#39;, templates: { empty: noResultsTemplate, item: hitTemplate } }), instantsearch.widgets.pagination({ container: \u0026#39;#pagination\u0026#39;, }) ]); //启动搜索 search.start(); API Keys 查看成果 https://ichochy.com/search.html 引用 搜索页面创建：https://www.algolia.com/doc/guides/building-search-ui/installation/js/\n搜索 API：https://www.algolia.com/doc/api-client/getting-started/install/javascript/?client=javascript\n",
    "pubDate": "2021-05-22T10:22:45+08:00"
  }, 
  {
    "objectID": 20210418,
    "url": "https://ichochy.com/posts/elasticsearch/20210418.html",
    "title": "Elasticsearch, Kibana, Logstash, Filebeat 实现日志的自动采集、搜索和分析",
    "summary": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\n",
    "content": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎\nKibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化管理和展示\nLogstash 是一个免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中\nBeats 是一个免费且开放的平台，集合了多种单一用途数据采集器，将数据发送给 Logstash 或 Elasticsearch\nBeats 系列 全品类采集器，搞定所有数据类型，如下：\nFilebeat：日志文件 Metricbeat：指标 Packetbeat：网络数据 Winlogbeat：Windows 事件日志 Auditbeat：审计数据 Heartbeat：运行时间监控 Functionbeat：无需服务器的采集器 一、下载镱像(image) Docker映像和标签的列表：https://www.docker.elastic.co 搜索镱像(image)\ndocker search elasticsearch docker search kibana docker search logstash 获取镱像(image)\ndocker pull elasticsearch:7.6.0 #镜像名称:Tag docker pull kibana:7.6.0 #镜像名称:Tag docker pull logstash:7.6.0 #镜像名称:Tag docker pull docker.elastic.co/beats/filebeat:7.6.0 #镜像名称:Tag 注：版本要统一\n二、创建 ELK.yml ELK.yml\nversion: \u0026#34;3.5\u0026#34; services: elasticsearch: container_name: elasticsearch image: elasticsearch:7.6.0 #镱像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana image: kibana:7.6.0 #镱像(image) restart: always #重启方式 environment: I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 logstash: container_name: logstash image: logstash:7.6.0 restart: always ports: - \u0026#34;5044:5044\u0026#34; - \u0026#34;9600:9600\u0026#34; filebeat: container_name: filebeat image: filebeat:7.6.0 restart: always command: filebeat -e -strict.perms=false #禁用严格权限检查 volumes: #文件夹映射，本地:容器 - \u0026#34;/Users/ichochy/beats/filebeat.yml:/usr/share/filebeat/filebeat.yml\u0026#34; 注：\n注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败 读取文件权限问题是软件自身的权限验证，可使用--strict.perms=false，禁用严格权限验证 # 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here # 错误息信 Exiting: error loading config file: config file (\u0026#34;{beatname}.yml\u0026#34;) can only be writable by the owner but the permissions are \u0026#34;-rw-rw-r--\u0026#34; (to fix the permissions use: \u0026#39;chmod go-w /etc/{beatname}/{beatname}.yml\u0026#39;) 三、运行容器 宿主机hosts中添加\n127.0.0.1 elasticsearch 命令启动\ndocker-compose -f ELK.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 四、检查容器的运行状态 elasticsearch 访问：http://127.0.0.1:9200\nlogstash 访问：http://127.0.0.1:9600\nKibana 访问：http://127.0.0.1:5601，进入 Kibana\n运行docker ps查询容器运行状态，可以查看到容器的ID\nmleo$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4d53b3ab9772 filebeat:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 days ago Up 8 minutes 1b8cb2effede logstash:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 hours ago Up About an hour 0.0.0.0:5044-\u0026gt;5044/tcp, 0.0.0.0:9600-\u0026gt;9600/tcp logstash 69b8bc678e4e kibana:7.6.0 \u0026#34;/usr/local/bin/dumb…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:5601-\u0026gt;5601/tcp kibana 8c655f5b7493 elasticsearch:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp elasticsearch 运行docker logs id查看容器运行日志\n例：持续查看`filebeat`日志 docker logs 4d53b3ab9772 -f 五、修改 filebeats 配置 filebeat.inputs: - type: log paths: - /usr/share/filebeat/logs/file/*.log #output.elasticsearch: # hosts: [\u0026#34;http://elasticsearch:9200\u0026#34;] # index: \u0026#34;ichochy\u0026#34; output.logstash: hosts: [\u0026#34;logstash\u0026#34;] 注：容器中，服务间访问可以通过服务名直接访问（协议+服务名+端口），如：http://logstash:5044\n六、修改 logstash 配置 运行docker exec -it 1b8cb2effede bash进入logstash 运行vi pipeline/logstash.conf修改logstash默认配置 input { beats { port =\u0026gt; 5044 } } output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;http://elasticsearch:9200\u0026#34;] #elasticsearch请求地址 index =\u0026gt; \u0026#34;ichochy\u0026#34; #索引名称 } } 运行docker restart 1b8cb2effede重启 logstash 七、模拟采集日志 在filebeat的监控的文件路径下动态添加日志文件，日志就可以自动采集发送到logstash，过虑处理后发送到elasticsearch\n运行docker exec -it 4d53b3ab9772 bash进入filebeat，在logs文件夹添加web.log文件\ntouch web.log #创建日志文件 echo \u0026#34;https://ichochy.com\u0026#34; \u0026gt; web.log #添加日志信息 查看logstash日志信息可以看到打印的日志，监控来自filebeat发来的信息\n{ \u0026#34;ecs\u0026#34; =\u0026gt; { \u0026#34;version\u0026#34; =\u0026gt; \u0026#34;1.4.0\u0026#34; }, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2021-04-18T02:26:42.851Z, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;https://ichochy.com\u0026#34;, \u0026#34;tags\u0026#34; =\u0026gt; [ [0] \u0026#34;beats_input_codec_plain_applied\u0026#34; ], \u0026#34;input\u0026#34; =\u0026gt; { \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;log\u0026#34; }, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;agent\u0026#34; =\u0026gt; { \u0026#34;ephemeral_id\u0026#34; =\u0026gt; \u0026#34;cf2ff9ee-294a-4ac9-9ee7-3da65a3c5beb\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;4d53b3ab9772\u0026#34;, \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;897d2be6-5aa2-4a5d-a824-a440a4d19d73\u0026#34;, \u0026#34;version\u0026#34; =\u0026gt; \u0026#34;7.6.0\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;filebeat\u0026#34; }, \u0026#34;host\u0026#34; =\u0026gt; { \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;4d53b3ab9772\u0026#34; }, \u0026#34;log\u0026#34; =\u0026gt; { \u0026#34;file\u0026#34; =\u0026gt; { \u0026#34;path\u0026#34; =\u0026gt; \u0026#34;/usr/share/filebeat/logs/file/web.log\u0026#34; }, \u0026#34;offset\u0026#34; =\u0026gt; 0 } } 例：持续查看`logstash`日志 docker logs 1b8cb2effede -f 八、管理、搜索、分析日志 访问：http://127.0.0.1:5601，进入 Kibana\n在设置管理（management）中创建索引： 在Discover可以看到刚刚添加进来的日志数据，开始你的表演…………\n引用 Beats配置文件权限问题：https://www.elastic.co/guide/en/beats/libbeat/current/config-file-permissions.html Compose网络访问：https://docs.docker.com/compose/networking/ Docker映像和标签的列表：https://www.docker.elastic.co ",
    "pubDate": "2021-04-18T10:22:45+08:00"
  }, 
  {
    "objectID": 20210315,
    "url": "https://ichochy.com/posts/java/20210315.html",
    "title": "Java 递归实例操作-查询层级菜单",
    "summary": "递归 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。\n",
    "content": "递归 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。\n递归的运用 系统中总会有菜单和权限的操作，会出现无限层级的操作，就需要用到递归。运用其调用自身的特性，实现无限层级迭代，通过父子节点展示数据。\n递归的实例操作 以查询所有菜单为例\n数据结构 字段 名称 id ID fatherId 父ID name 名称 …… …… 数据实体 /* * File:Menus.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2021 * Date:2021/03/16 14:12:16 */ package com.ichochy.entity; import java.util.List; public class Menu { private int id; private int fatherId; private String name; private List\u0026lt;Menu\u0026gt; childs; //………… } 数据查询 通过 fatherId 查询子菜单信息\n/** * 查询菜单信息-模拟方法 * @param fatherId * @return */ public List\u0026lt;Menu\u0026gt; getMenuByFatherId(int fatherId) { int value = new Random().nextInt(fatherId); if (value % 2 != 0) { List\u0026lt;Menu\u0026gt; menus = new ArrayList\u0026lt;\u0026gt;(value); for (int i = 1; i \u0026lt;= value; i++) { Menu menu = new Menu(); menu.setId(i); menu.setFatherId(fatherId); menu.setName(\u0026#34;menu-\u0026#34; + fatherId+\u0026#34;-\u0026#34;+i); menus.add(menu); } return menus; } return Collections.EMPTY_LIST; } 没有建表查库，写个模拟方法\n递归方法 /* * File:Recursion.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2021 * Date:2021/03/16 14:07:16 */ package com.ichochy.recursion; import com.ichochy.entity.Menu; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; public class Recursion { /** * 获取菜单 * @param fatherId * @return */ public List\u0026lt;Menu\u0026gt; getAllMenus(int fatherId) { List\u0026lt;Menu\u0026gt; menus = getMenuByFatherId(fatherId); for (Menu menu : menus) { fatherId = menu.getId(); //自己调用自己 List\u0026lt;Menu\u0026gt; childMenus = getAllMenus(fatherId); //跳出递归 if (childMenus.isEmpty()) { continue; } menu.setChilds(childMenus); } return menus; } 构成递归需具备的条件：\n子类问题与父类问题相同 不能无限制地调用自身，须有跳出出口，边界返回 递归数据 [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-1\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-2\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;menu-2-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 3, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-3\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;menu-3-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 4, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-4\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-1\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-2\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;menu-2-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 3, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-3\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;menu-3-1\u0026#34; } ] } ] } ] ",
    "pubDate": "2021-03-15T10:11:35+08:00"
  }, 
  {
    "objectID": 20201010,
    "url": "https://ichochy.com/posts/java/20201010.html",
    "title": "Java JSON数据实战操作",
    "summary": "JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。\n",
    "content": "JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。\nJSON 采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等），这些特性使JSON成为理想的数据交换语言。\n引入GSON Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。\n功能\n提供简单的toJson()和fromJson()方法，将Java对象到JSON，反之亦然 允许将已有的不可修改的对象与JSON相互转换 Java泛型的广泛支持 允许对象的自定义表示 支持任意复杂的对象（具有深层继承层次结构和泛型类型的广泛使用） Maven \u0026lt;dependencies\u0026gt; \u0026lt;!-- Gson: Java to Json conversion --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.code.gson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.6\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; } 创建 GSON 默认创建 Gson gson = new Gson() 指定创建 Gson gson = new GsonBuilder() //自定义序列化或反序列化 .registerTypeAdapter(Id.class, new IdTypeAdapter()) //启用复杂的 Map 键序列化 .enableComplexMapKeySerialization() //序列化空字段 .serializeNulls() //设定时间格式 .setDateFormat(DateFormat.LONG) //设定字段命名策略 .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE) //设定打印样式 .setPrettyPrinting() //设定版本号 .setVersion(1.0) //创建 GSON //... .create(); 使用 GSON 对象实例 对象 User /* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 10:18:31 */ package com.ichochy.entity; public class User { private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } toJson 方法将对象转换成 JSON 字符串 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.ichochy.example.User; public class Example { public static void main(String[] args) { //创建 GSON 对象 Gson gson = new Gson(); //toJson 将对象转换成 JSON 字符串 String json = gson.toJson(new User()); //{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;} System.out.println(json); } } fromJson 方法将 JSON 字符串转换成对象 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.ichochy.example.User; public class Example { public static void main(String[] args) { //创建 GSON 对象 Gson gson = new Gson(); // JSON 字符串 String json = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;MLeo\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:35,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;https://ichochy.com\\\u0026#34;}\u0026#34;; //fromJson 将 JSON 字符串转换成对象 User user = gson.fromJson(json,User.class); //Name:MLeo //Age:35 //URL:https://ichochy.com } } 集合实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import com.ichochy.example.User; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class Example { public static void main(String[] args) { //创建 GSON 对象 Gson gson = new Gson(); //toJson 将集合转换成 JSON 字符串 List\u0026lt;User\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.add(new User()); data.add(new User()); String json = gson.toJson(data); //[{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;}] System.out.println(json); //fromJson 将 JSON 字符串转换成集合 //通过 TypeToken 指定类型 List\u0026lt;User\u0026gt; users = gson.fromJson(json, new TypeToken\u0026lt;Collection\u0026lt;User\u0026gt;\u0026gt;(){}.getType()); System.out.println(users); } } 泛型实例 TypeToken 泛型对象 Result /* * File:Result.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/24 10:59:24 */ package com.ichochy.entity; public class Result\u0026lt;T\u0026gt; { private String code = \u0026#34;0000\u0026#34;; private String message = \u0026#34;OK\u0026#34;; private T data; //... } TypeToken 指定泛型 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import com.ichochy.entity.Result; import com.ichochy.entity.User; import java.util.ArrayList; import java.util.List; public class Example { public static void main(String[] args) { //创建 GSON 对象 Gson gson = new Gson(); //toJson 将对象转换成 JSON 字符串 Result result = new Result(); List\u0026lt;User\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.add(new User()); data.add(new User()); result.setData(data); String json = gson.toJson(result); //{\u0026#34;code\u0026#34;:\u0026#34;0000\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;OK\u0026#34;,\u0026#34;data\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;}]} System.out.println(json); //fromJson 将 JSON 字符串转换成对象 //通过 TypeToken 指定类型 Result\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; values = gson.fromJson(json, new TypeToken\u0026lt;Result\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;\u0026gt;(){}.getType()); System.out.println(values); } } SerializedName 注解重命名属性 属性添加注解SerializedName，实现自定义属性名\n对象 User /* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 12:49:22 */ package com.ichochy.entity; import com.google.gson.annotations.SerializedName; public class User { @SerializedName(\u0026#34;userName\u0026#34;) private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.ichochy.entity.User; public class Example { public static void main(String[] args) { //创建 GSON 对象 Gson gson = new Gson() String json = gson.toJson(new User()); /** * { * \u0026#34;userName\u0026#34;: \u0026#34;iChochy\u0026#34;, * \u0026#34;age\u0026#34;: 35, * \u0026#34;url\u0026#34;: \u0026#34;https://ichochy.com\u0026#34; * } */ System.out.println(json); } } FieldNamingPolicy 指定命名规则 配置GSON（setFieldNamingPolicy） Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.IDENTITY).create(); 枚举常量 枚举常量和描述 IDENTITY 字段名称不变 LOWER_CASE_WITH_DASHES 字段名称从其驼峰式的形式修改为小写的字段名称，其中每个单词都用短划线（-）分隔 LOWER_CASE_WITH_DOTS 字段名称从其驼峰大小写形式修改为小写的字段名称，其中每个单词都用点（.）分隔 LOWER_CASE_WITH_UNDERSCORES 字段名称从其驼峰式的形式修改为小写的字段名称，其中每个单词都用下划线（_）分隔 UPPER_CAMEL_CASE 字段名称的第一个字母在序列化为JSON格式时大写 UPPER_CAMEL_CASE_WITH_SPACES 字段名称的第一个字母在序列化为JSON格式时大写，并且单词之间将用空格分隔 时间格式 配置GSON（setDateFormat） Gson gson = new GsonBuilder().setDateFormat(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;).create(); /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import java.util.Date; public class Example { public static void main(String[] args) { //创建 GSON 对象，指定时间格式 Gson gson = new GsonBuilder().setDateFormat(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;).create(); String json = gson.toJson(new Date()); //2020-12-24 11:40:45 System.out.println(json); //fromJson 将 JSON 字符串转换成对象 //通过 TypeToken 指定类型 Date values = gson.fromJson(json, Date.class); //Thu Dec 24 11:40:45 CST 2020 System.out.println(values); } } Expose 注解显示属性 配置GSON（excludeFieldsWithoutExposeAnnotation） Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation.create(); 属性添加注解 Expose，显示属性 package com.ichochy.entity; import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; public class User { @Expose private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } Since 注解版本支持 配置GSON（setVersion） Gson gson = new GsonBuilder().setVersion(1.0).create(); 属性添加注解 Since，添加版本 package com.ichochy.entity; import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; public class User { @Since(1.1) private String name = \u0026#34;iChochy\u0026#34;; @Since(1.0) private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } 注： 高版本会显示低版本信息\n",
    "pubDate": "2020-10-10T22:22:35+08:00"
  }, 
  {
    "objectID": 20200902,
    "url": "https://ichochy.com/posts/software/20200902.html",
    "title": "MacOS 或 Linux 软件包管理器 Homebrew",
    "summary": "Homebrew 可以方便、快捷的安装第三方软件包，不再需要手动编译安装，通过brew install命令就可以完成软件的安装，包括相关的依赖包。甚至使用brew cask安装macOS应用程序、字体和插件以及其他非开源软件。\n",
    "content": "Homebrew 可以方便、快捷的安装第三方软件包，不再需要手动编译安装，通过brew install命令就可以完成软件的安装，包括相关的依赖包。甚至使用brew cask安装macOS应用程序、字体和插件以及其他非开源软件。\n安装 Homebrew 终端运行脚体就可以一步安装，非常简单。\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 同时支持MacOS、Linux或Windows的子系统WSL，并不需要管理员（sudo）权限。\n使用 Homebrew 常用命令 brew 搜索可用的软件包\nbrew search [TEXT|/REGEX/] 查看软件包的信息\nbrew info [FORMULA...] 安装软件包\nbrew install FORMULA... Homebrew会将软件包安装到独立目录/usr/local/Cellar，并将其文件软链接至/usr/local\n更新brew索引信息\nbrew update 更新软件包\nbrew upgrade [FORMULA...] 卸载软件包\nbrew uninstall FORMULA... 查询本机安装的软件包\nbrew list [FORMULA...] 常用命令 brew cask 查看程序信息\nbrew cask info 安装程序\nbrew cask install 查看程序列表\nbrew cask list 卸载程序\nbrew cask uninstall 更新程序\nbrew cask upgrade 常用命令 brew services 查看当前服务列表\n[sudo] brew services [list]: 运行服务\n[sudo] brew services run (formula|--all): 启动服务，并注册自启动加载\n[sudo] brew services start (formula|--all): 停用服务，并取消自启动加载\n[sudo] brew services stop (formula|--all): 重启服务\n[sudo] brew services restart (formula|--all): 清理无用服务\n[sudo] brew services cleanup: 替换国内源 因为国外网络访问的问题，brew update会出现一直等待中或中断的问题，可以考虑替换国内源，来加快访问速度。下面介绍替换国内源，如：清华大学镜像源、中国科学技术大学镜像源、阿里云镜像源\n清华大学镜像源 https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\nbrew 替换 git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git Homebrew 替换 # 以下针对 mac OS 系统上的 Homebrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git git -C \u0026#34;$(brew --repo homebrew/cask-fonts)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git git -C \u0026#34;$(brew --repo homebrew/cask-drivers)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/linuxbrew-core.git Homebrew-bottles 替换 临时替换\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles 长期替换\n如果你使用 bash:\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 如果你使用 zsh:\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc Linuxbrew-bottles 替换 临时替换\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/linuxbrew-bottles 长期替换\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/linuxbrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 中国科学技术大学镜像源 https://mirrors.ustc.edu.cn/help/brew.git.html\nBash 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git # 替换homebrew-cask.git: cd \u0026#34;$(brew --repo)\u0026#34;/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile Zsh 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git # 替换homebrew-cask.git: cd \u0026#34;$(brew --repo)\u0026#34;/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc 阿里云镜像源 https://developer.aliyun.com/mirror/homebrew\nBash 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile Zsh 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc 恢复镜像源 brew 恢复 git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://github.com/Homebrew/brew.git Homebrew 恢复 # 以下针对 mac OS 系统上的 Homebrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask.git git -C \u0026#34;$(brew --repo homebrew/cask-fonts)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask-fonts.git git -C \u0026#34;$(brew --repo homebrew/cask-drivers)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://github.com/Homebrew/linuxbrew-core.git Homebrew-bottles 恢复 删除~/.bash_profile或~/.zshrc中的HOMEBREW_BOTTLE_DOMAIN环境变量，并执行source，重新加载环境变量。\nsource ~/.bash_profile source ~/.zshrc ",
    "pubDate": "2020-09-02T16:22:35+08:00"
  }, 
  {
    "objectID": 20200828,
    "url": "https://ichochy.com/posts/java/20200828.html",
    "title": "Java 正则表达式实例操作",
    "summary": "Regular Expression正则表达式，简称RegExp，常规通用的表达式，在多个开发语言中都有它的实现，可以通过正则表达式来快速的检索、匹配、查找、替换字符串中的文本。\n",
    "content": "Regular Expression正则表达式，简称RegExp，常规通用的表达式，在多个开发语言中都有它的实现，可以通过正则表达式来快速的检索、匹配、查找、替换字符串中的文本。\n简单实例 匹配网址\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;https://ichochy.com\u0026#34;; //正则表达式，(.+)代表一个或多个字符 String regex = \u0026#34;https://.+.com\u0026#34;; Boolean flag = Pattern.matches(regex,input); System.out.println(flag); //全文匹配返回：true } } Matches 方法 Matcher.matches方法，为整块全匹配，字符串完全匹配返回true。\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;https://ichochy.com\u0026#34;; //正则表达式，(.+)代表一个或多个字符 String regex = \u0026#34;https://.+.com\u0026#34;; Pattern pattern = Pattern.compile(regex);//编译表达式 Matcher matcher = pattern.matcher(input);//匹配表达式 System.out.println(matcher.matches());//全文匹配返回：true } } Find 方法 Matcher.find方法，为查找模式匹配，匹配到就返回true。\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;我的网站是：https://ichochy.com，你知道吗？\u0026#34;; //正则表达式，(.+)代表一个或多个字符 String regex = \u0026#34;https://.+.com\u0026#34;; Pattern pattern = Pattern.compile(regex);//编译表达式 Matcher matcher = pattern.matcher(input);//匹配表达式 System.out.println(matcher.find());//查找匹配返回：true System.out.println(matcher.matches());//全文匹配返回：false System.out.println(matcher.find());//再次查找匹配返回：false matcher.reset();//重置匹配器 System.out.println(matcher.find());//重置查找返回：true } } find方法多次调用，出现结果不相同的问题：\nThis method starts at the beginning of this matcher\u0026#39;s region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match. Matcher.find方法第一次查找匹配成功后，如果Matcher没有重置(Matcher.reset())，则从上一次匹配成功位置的后面开始查找，所以会出现，再次匹配不成功，返回false。\nGroup 分组 正则表达式通过括号分组进行匹配，matcher.group(int group)：通过组序号获取匹配信息\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;我的网站是：https://ichochy.com，你知道吗？\u0026#34;; String regex = \u0026#34;(https://)(.+)(.com)\u0026#34;;//分组表达式 Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(input); if(matcher.find()){//查找匹配成功 //匹配的信息：https://ichochy.com System.out.println(matcher.group().toString()); //groupCount 组数 for (int i = 0; i \u0026lt; matcher.groupCount(); i++) { //每组匹配的信息，注意：序号是从 1 开始 System.out.println(matcher.group(i+1)); } } } } 正则表达式规则 字符 构造 匹配 x 字符 x \\ 反斜线字符 \\0n 带有八进制值 0 的字符 n (0 \u0026lt;= n \u0026lt;= 7) \\0nn 带有八进制值 0 的字符 nn (0 \u0026lt;= n \u0026lt;= 7) \\0mnn 带有八进制值 0 的字符 mnn（0 \u0026lt;= m \u0026lt;= 3、0 \u0026lt;= n \u0026lt;= 7） \\xhh 带有十六进制值 0x 的字符 hh \\uhhhh 带有十六进制值 0x 的字符 hhhh \\t 制表符(\u0026rsquo;\\u0009') \\n 新行（换行）符 (\u0026rsquo;\\u000A') \\r 回车符 (\u0026rsquo;\\u000D') \\f 换页符 (\u0026rsquo;\\u000C') \\a 报警 (bell) 符 (\u0026rsquo;\\u0007') \\e 转义符 (\u0026rsquo;\\u001B') \\cx 对应于 x 的控制符 字符类 构造 匹配 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z\u0026amp;\u0026amp;[def]] d、e 或 f（交集） [a-z\u0026amp;\u0026amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z\u0026amp;\u0026amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 预定义字符类 构造 匹配 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] POSIX 字符类（仅 US-ASCII） 构造 匹配 \\p{Lower} 小写字母字符：[a-z] \\p{Upper} 大写字母字符：[A-Z] \\p{ASCII} 所有 ASCII：[\\x00-\\x7F] \\p{Alpha} 字母字符：[\\p{Lower}\\p{Upper}] \\p{Digit} 十进制数字：[0-9] \\p{Alnum} 字母数字字符：[\\p{Alpha}\\p{Digit}] \\p{Punct} 标点符号：!\u0026quot;#$%\u0026amp;\u0026rsquo;()*+,-./:;\u0026lt;=\u0026gt;?@[]^_`{ \\p{Graph} 可见字符：[\\p{Alnum}\\p{Punct}] \\p{Print} 可打印字符：[\\p{Graph}\\x20] \\p{Blank} 空格或制表符：[ \\t] \\p{Cntrl} 控制字符：[\\x00-\\x1F\\x7F] \\p{XDigit} 十六进制数字：[0-9a-fA-F] \\p{Space} 空白字符：[ \\t\\n\\x0B\\f\\r] java.lang.Character 类（简单的 java 字符类型） 构造 匹配 \\p{javaLowerCase} 等效于 java.lang.Character.isLowerCase() \\p{javaUpperCase} 等效于 java.lang.Character.isUpperCase() \\p{javaWhitespace} 等效于 java.lang.Character.isWhitespace() \\p{javaMirrored} 等效于 java.lang.Character.isMirrored() Unicode 块和类别的类 构造 匹配 \\p{InGreek} Greek 块（简单块）中的字符 \\p{Lu} 大写字母（简单类别） \\p{Sc} 货币符号 \\P{InGreek} 所有字符，Greek 块中的除外（否定） [\\p{L}\u0026amp;\u0026amp;[^\\p{Lu}]] 所有字母，大写字母除外（减去） 边界匹配器 构造 匹配 ^ 行的开头 $ 行的结尾 \\b 单词边界 \\B 非单词边界 \\A 输入的开头 \\G 上一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符（如果有的话） \\z 输入的结尾 Greedy 数量词 构造 匹配 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 Reluctant 数量词 构造 匹配 X?? X，一次或一次也没有 X*? X，零次或多次 X+? X，一次或多次 X{n}? X，恰好 n 次 X{n,}? X，至少 n 次 X{n,m}? X，至少 n 次，但是不超过 m 次 Possessive 数量词 构造 匹配 X?+ X，一次或一次也没有 X*+ X，零次或多次 X++ X，一次或多次 X{n}+ X，恰好 n 次 X{n,}+ X，至少 n 次 X{n,m}+ X，至少 n 次，但是不超过 m 次 Logical 运算符 构造 匹配 XY X 后跟 Y X Y (X) X，作为捕获组 Back 引用 构造 匹配 \\n 任何匹配的 nth 捕获组 引用 构造 匹配 \\ Nothing，但是引用以下字符 \\Q Nothing，但是引用所有字符，直到 \\E \\E Nothing，但是结束从 \\Q 开始的引用 特殊构造（非捕获） 构造 匹配 (?:X) X，作为非捕获组 (?idmsux-idmsux) Nothing，但是将匹配标志i d m s u x on - off (?idmsux-idmsux:X) X，作为带有给定标志 i d m s u x on - off (?=X) X，通过零宽度的正 lookahead (?!X) X，通过零宽度的负 lookahead (?\u0026lt;=X) X，通过零宽度的正 lookbehind (?\u0026lt;!X) X，通过零宽度的负 lookbehind (?\u0026gt;X) X，作为独立的非捕获组 总结 可以看到，通过灵活的规则，设计出你想的表达式，来匹配复杂的字符串，从而快速便捷的操作。\n",
    "pubDate": "2020-08-28T15:25:35+08:00"
  }, 
  {
    "objectID": 20200825,
    "url": "https://ichochy.com/posts/java/20200825.html",
    "title": "简述 Cookie、Token、JWT、Session",
    "summary": "早期互联网只是用来访问查看，不需要关心谁在访问查看。HTTP是一种无状态的协议，每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，为了标示用户，就出现了Cookie，而Cookie、Token、JWT 都是用来标示用户的。\n",
    "content": "早期互联网只是用来访问查看，不需要关心谁在访问查看。HTTP是一种无状态的协议，每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，为了标示用户，就出现了Cookie，而Cookie、Token、JWT 都是用来标示用户的。\nCookie 如：iChochy用户发起访问，服务端为了进行会话跟踪，会为当前用户的访问会话（Session）生成一个会话ID(Session ID)，并通过Set Cookie方式，将Session ID发送给用户的客户端浏览器。客户端自动识别服务端发来的Cookie信息，就会存储在客户端。再次请求时，都带上这个Cookie信息来标示当前用户，服务端自动识别到Cookie信息，就可以判断具体是哪个用户了。\nToken Token是一个令牌，用户登录成功后服务端会生成一个令牌，用来关联会话（Session）信息，如同Cookie，只是需要手动传递。\nJWT JWT是JSON Web Token的简称，可以理解为是Token的升级版本，用户登录成功后服务端会生成的一个很长的字符串，中间用点（.）分隔成三个部分，内容包含Header.Payload.Signature。JWT的不同点就是可以携带具体的用户信息，不再只是标示ID。\nSession Session就是服务端生成的用户会话信息，一般就是用户信息，存储在服务端。\n对比Cookie、Token、JWT 不同点 Cookie Token JWT 标准 系统默认 自定义 自定义 用户标示 包含 包含 包含 跨域 不支持 支持 支持 具信信息 不包含 不包含 包含 关系 关系如下图： 总结 Cookie、Token、JWT都是请求无状态的一种补充，用来标示用户，只是侧重点不同。Cookie是最原始的系统默认标准，前后端都会自动处理Cookie信息，不需要过多的干预。而Token、JWT都是标准的升级和自定义，Token出现解决了Cookie不能跨域的问题，而JWT可以携带具体的用户信息，将用户信息存储在客户端，解决了分布式用户信息存储。\n**Session**是用户会话的具体信息，一般就是用户信息，如ID、Role、Auth等。\n",
    "pubDate": "2020-08-25T11:25:35+08:00"
  }, 
  {
    "objectID": 20200824,
    "url": "https://ichochy.com/posts/java/20200824.html",
    "title": "Java 方法代理实例操作，静态代理、JDK动态代理、CGLIB动态代理",
    "summary": "方法的代理可以在调用方法时进行其它的相关操作，并减少代码的入侵和偶合。很多框架都用到了动态代理，并提供了减化代理操作，如：Spring 的 AOP。\n",
    "content": "方法的代理可以在调用方法时进行其它的相关操作，并减少代码的入侵和偶合。很多框架都用到了动态代理，并提供了减化代理操作，如：Spring 的 AOP。\n静态代理 以电脑为模型，我们都知道，电脑是由 CPU、GPU、DISK 多个设备组装的，它们都是通过接口相连接。现在模拟一台电脑（Computer）通过接口设备(Device)，代理（Proxy）组装不同的设备（CPU、GPU），并运行（run）。\n接口设备Device /* * File:Device.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:49:31 */ package com.ichochy.proxy; public interface Device { public void run(); } 设备 CPU /* * File:CPU.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:52:31 */ package com.ichochy.proxy; public class CPU implements Device { @Override public void run() { System.out.println(\u0026#34;Game\u0026#34;); } } 设备 GPU /* * File:GPU.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:52:31 */ package com.ichochy.proxy; public class GPU implements Device { @Override public void run() { System.out.println(\u0026#34;Display\u0026#34;); } } 电脑Computer Computer的start方法代理执行接口类方法\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; public class Computer { private Device device; public Device start(){ System.out.println(\u0026#34;Start Computer\u0026#34;); device.run(); return device; } public Device getDevice() { return device; } public void setDevice(Device device) { this.device = device; } } 运行电脑 通过类Computer的start方法代理执行接口类方法\npackage com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import com.ichochy.proxy.GPU; public class App { public static void main(String[] args) { Computer proxy = new Computer(); proxy.setDevice(new CPU()); proxy.start(); proxy.setDevice(new GPU()); proxy.start(); } } 运行情况 Start Computer Game Start Computer Display 小结 静态代理可以代理某个方法，实现AOP操作，代理需求变更只需修改代理类，实现了解偶的效果。但不同的接口多个方法就要重复的编写代理类，来实现方法代理操作。\nJDK动态代理 实现接口InvocationHandler的invoke方法，通过Proxy的newProxyInstance方法，构建代理接口实例。相比静态代理更加灵活，动态代理不同的接口和接口中的方法。\n改进电脑Computer 实现接口InvocationHandler的invoke方法，运用反射，动态执行代理方法\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class Computer implements InvocationHandler { private Device device; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;Start...\u0026#34;); //运用反射，动态执行代理方法，并返回方法执行结果 Object result = method.invoke(device, args); System.out.println(\u0026#34;End\u0026#34;); return result; } public Device getDevice() { return device; } public void setDevice(Device device) { this.device = device; } } 动态运行电脑 通过类Proxy的newProxyInstance方法构建代理接口类，实现方法的代理执行\n/* * File:App.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/01 12:46:01 */ package com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import com.ichochy.proxy.Device; import java.lang.reflect.Proxy; public class App { public static void main(String[] args) throws Exception { CPU cpu = new CPU(); Computer computer = new Computer(); computer.setDevice(cpu); //获取代理接口实例 Device device = (Device) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), cpu.getClass().getInterfaces(), computer); device.run(); } } 运行情况 Start... Game End 小结 运用反射，动态代理可以代理不同的接口的多个方法，不必修改代码。但只能用于接口方法的代理，无法实现所有类方法。\nCGLIB动态代理 CGLIB库是用于生成和转换Java字节码的高级API，它允许运行时对字节码进行修改和动态生成，通过继承方式实现动态代理。\n引入CGLIB库 通过Maven库管理引入第三方CGLIB库\n\u0026lt;!-- https://mvnrepository.com/artifact/cglib/cglib --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 改进电脑Computer 实现接口MethodInterceptor的intercept方法，运用反射，动态执行代理方法（原父类方法）\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class Computer implements MethodInterceptor { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;Start...\u0026#34;); //运用反射，动态执行代理方法，并返回方法执行结果 Object result = methodProxy.invokeSuper(obj, args); System.out.println(\u0026#34;End\u0026#34;); return result; } } 动态运行电脑 通过类Enhancer的create方法构建代理类，实现方法的代理执行\n/* * File:App.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/01 12:46:01 */ package com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import net.sf.cglib.proxy.Enhancer; public class App { public static void main(String[] args) throws Exception { Computer computer = new Computer(); Enhancer enhancer = new Enhancer(); //设置要代理超类 enhancer.setSuperclass(CPU.class); //设置回调处理类 enhancer.setCallback(computer); //构建代理类 CPU cpu = (CPU)enhancer.create(); cpu.run(); } } 运行情况 Start... Game End 小结 通过CGLIB库可以很方便的实现方法的动态代理，实现AOP操作。CGLIB库构建代理类的子类，并重写代理父类的方法，通过执行子类方法实现动态代理操作。\n总结 当我们要对一类方法或所有方法进行相同操作时，运用方法代理可以很好实现我们的需求，并不用去重写以前的业务方法，如：事务处理、日志监控、权限管理、异常捕捉及处理。\n总结：方法代理，实现AOP操作。\n",
    "pubDate": "2020-08-24T16:45:35+08:00"
  }, 
  {
    "objectID": 20200823,
    "url": "https://ichochy.com/posts/java/20200823.html",
    "title": "Java 反射实例操作",
    "summary": "反射可以在代码运行时，动态的获取对象、调用方法、设置属性。动态操作，降低代码偶合性，提高灵活度。其JDBC库就是通过反射加载。\n",
    "content": "反射可以在代码运行时，动态的获取对象、调用方法、设置属性。动态操作，降低代码偶合性，提高灵活度。其JDBC库就是通过反射加载。\n实例操作 以操作User对象为例:\n/* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 10:18:31 */ package com.ichochy.example; public class User { private String name = \u0026#34;iChochy\u0026#34;; private int age = 32; private String url = \u0026#34;https://ichochy.com\u0026#34;; public void display(){ System.out.println(\u0026#34;Name:\u0026#34;+name); System.out.println(\u0026#34;Age:\u0026#34;+age); System.out.println(\u0026#34;URL:\u0026#34;+url); } } 正常调用 User user = new User(); user.display(); 获取对象 类动态获取\n//获取类 Class\u0026lt;?\u0026gt; clazz = User.class; //获取对象 Object obj = clazz.newInstance(); 类路径获取\n//获取类 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.ichochy.example.User\u0026#34;); //获取对象 Object obj = clazz.newInstance(); 获取属性 获取全部\nField[] fields = clazz.getDeclaredFields(); for (Field field: fields) { System.out.println(field.getName());//name、age、url } 属性名获取\nField field = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field.getName());//age 设置属性 Object obj = clazz.newInstance(); Field field= clazz.getDeclaredField(\u0026#34;age\u0026#34;);//获取私用属性 field.setAccessible(true);//设置反射访问权限检查 System.out.println(field.get(obj)); //32 field.set(obj,18);//设置属性 System.out.println(field.get(obj));//18 获取方法 获取全部\nMethod[] methods = clazz.getMethods(); for(Method method:methods){ System.out.println(method.getName()); //display } 方法名获取\nMethod method = clazz.getMethod(\u0026#34;display\u0026#34;); System.out.println(method.getName()); //display 调用方法 Object obj = clazz.newInstance(); Method[] methods = clazz.getMethods(); for(Method method:methods){ //调用 display 方法 if(\u0026#34;display\u0026#34;.equals(method.getName())){ method.invoke(obj); } } 方法名调用\nObject obj = clazz.newInstance(); Method method = clazz.getMethod(\u0026#34;display\u0026#34;); method.invoke(obj); ",
    "pubDate": "2020-08-23T16:45:35+08:00"
  }, 
  {
    "objectID": 20200822,
    "url": "https://ichochy.com/posts/blog/20200822.html",
    "title": "Vercel 上自动部署你的个人博客 Hugo",
    "summary": "Vercel 可以依托 Git仓库 ，在线自动构建和发布Web静态项目，支持自定义域名，可以自动签发SSL证书，开启HTTPS，还有一个特点，拥有全球CDN，国内速度不错。\n",
    "content": "Vercel 可以依托 Git仓库 ，在线自动构建和发布Web静态项目，支持自定义域名，可以自动签发SSL证书，开启HTTPS，还有一个特点，拥有全球CDN，国内速度不错。\n支持多套框架和模版，如：Hugo、Jekyll、Hexo、Next、Vue\u0026hellip;\n注册账号 通过Git仓库账号关联注册，如果注册中出现错误，检查下账号是不是QQ邮箱。 Vercel不支持QQ邮箱，以GitHub为例，可以修改GitHub的默认邮箱。\nGitHub -\u0026gt; Settings -\u0026gt; Emails -\u0026gt; Primary email address 导入项目 输入你的项目地址 选择你的账户 在线安装Vercel 授权Vercel，选择授权项目\nGitHub -\u0026gt; Settings -\u0026gt; Applications -\u0026gt; Vercel -\u0026gt; Configure 导入项目，选择项目框架 部署项目 导入项后会自动构建、发布项目，直接访问: https://ichochy.com/\n下次提交代码到Git仓库，Vercel不用任何操作，就可以直接自动构建和发布项目\n自定义域名 直接添加已有的域名，域名商管理系统配置域名记录，等待生效。\nVercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Domains 生效后会自动签发SSL证书，开启HTTPS 指定 Hugo 版本 在项目的环境变量中添加Hugo版本\nVercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Environment Variables HUGO_VERSION 0.74.2 完成后重新发布\nBuild Logs 12:21:18.550 Cloning github.com/iChochy/iChochy.github.io (Branch: master, Commit: a169de0) 12:21:19.212 Cloning completed in 662ms 12:21:19.213 Analyzing source code... 12:21:19.799 Installing build runtime... 12:21:20.194 Build runtime installed: 394.753ms 12:21:20.575 Looking up build cache... 12:21:20.638 Build cache found. Downloading... 12:21:20.647 Build cache downloaded [206.00 B]: 8.14ms 12:21:21.022 Installing Hugo version 0.74.2 12:21:23.078 Installing dependencies... 12:21:23.290 yarn install v1.22.4 12:21:23.302 info No lockfile found. 12:21:23.306 [1/4] Resolving packages... 12:21:23.306 [2/4] Fetching packages... 12:21:23.309 [3/4] Linking dependencies... 12:21:23.312 [4/4] Building fresh packages... 12:21:23.315 success Saved lockfile. 12:21:23.316 Done in 0.03s. 12:21:23.515 Building sites … 12:21:23.515 | EN 12:21:23.515 -------------------+------ 12:21:23.515 Pages | 109 12:21:23.515 Paginator pages | 4 12:21:23.515 Non-page files | 0 12:21:23.515 Static files | 13 12:21:23.515 Processed images | 0 12:21:23.515 Aliases | 1 12:21:23.515 Sitemaps | 1 12:21:23.515 Cleaned | 0 12:21:23.515 Total in 162 ms 12:21:23.776 Uploading build outputs... 12:21:31.360 Build completed. Populating build cache... 12:21:31.457 Uploading build cache [220.00 B]... 12:21:31.614 Build cache uploaded: 156.776ms 12:21:31.620 Done with \u0026#34;config.toml\u0026#34; ",
    "pubDate": "2020-08-22T13:22:35+08:00"
  }, 
  {
    "objectID": 20200820,
    "url": "https://ichochy.com/posts/java/20200820.html",
    "title": "Java 中的重写(Override)与重载(Overload)",
    "summary": "Java 是一个面向对象编程的语言，我们就以面向对象的方式来解释下重写(Override)与重载(Overload)。子类存在父类名字相同的方法，而参数的个数与类型一样，返回值也一样的方法，就称为方法的重写（Override）。同类中定义了多个名字相同的方法，但他们的参数数量不同或数量相同而类型和次序不同，则称为方法的重载(Overload)。\n",
    "content": "Java 是一个面向对象编程的语言，我们就以面向对象的方式来解释下重写(Override)与重载(Overload)。子类存在父类名字相同的方法，而参数的个数与类型一样，返回值也一样的方法，就称为方法的重写（Override）。同类中定义了多个名字相同的方法，但他们的参数数量不同或数量相同而类型和次序不同，则称为方法的重载(Overload)。\n重写(Override) 重写出现在继承中，子类重新编写父类的方法，改写父类现有的方法，方法相同而不相似。如：你继承了你爸的房子，用来装修婚房，按照自己想法去装修，完成后外表起来没有什么变化，可内部的格局已经发生了变化。\n重写代码实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/25 22:33:25 */ package com.ichochy.example; public class Example { public static class Father{ public void house(){ System.out.println(\u0026#34;father house\u0026#34;); } } public static class Child extends Father{ /** * 重写父类方法，方法名、参数完全相同 */ @Override public void house() { super.house();//调用父类 house 方法 System.out.println(\u0026#34;child house\u0026#34;); } } public static void main(String[] args) { new Father().house(); System.out.println(\u0026#34;################\u0026#34;); new Child().house(); } } 重载(Overload) 重载出现在同类中，重新编写一个新的方法，改进现有的方法，方法相似而不相同。如：你要修建一套房子，可以借鉴别人建房子的经验来建造自己的房子，格局相似而不相同。\n重载代码实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/25 22:33:25 */ package com.ichochy.example; public class Example { public void house(){ System.out.println(\u0026#34;house\u0026#34;); } /** * 重载同类方法，方法名相同，而参数不相同 * @param name */ public void house(String name) { this.house(); System.out.println(name+\u0026#34; house\u0026#34;); } public static void main(String[] args) { new Example().house(); System.out.println(\u0026#34;################\u0026#34;); new Example().house(\u0026#34;iChochy\u0026#34;); } } 对比 对比 重写 重载 方法名字 相同 相同 方法参数 相同 不相同 返回值 相同 可以不相同 范围 子类中 同类或子类中 总结 方法的重写是有严格的定义，子类重写父类的方法，是自我型态表达，形成 Java 中多态的特性。而方法的重载没有严格的定义，就是个不同的方法，只是名字相同而已。\n",
    "pubDate": "2020-08-20T11:22:35+08:00"
  }, 
  {
    "objectID": 20200819,
    "url": "https://ichochy.com/posts/software/20200819.html",
    "title": "免费申请 JetBrains 开源开发许可证，包含 IDEA",
    "summary": "如果您是开源项目的负责人或核心贡献者，就可以申请 JetBrains 所有产品的License，用于您的项目开发。\n",
    "content": "如果您是开源项目的负责人或核心贡献者，就可以申请 JetBrains 所有产品的License，用于您的项目开发。\n免费许可计划 开源项目：\n符合 Open Source 定义。 正在积极开发中，即在过去3个月内定期提交新的代码提交。 请勿在开源项目周围提供付费版本的开源软件或任何商业服务（例如，付费支持，咨询等）。 不由商业公司或组织（非政府组织，教育，研究或政府）资助。 不付钱给他们的核心项目开发商。 支持条款：\n许可证仅提供给项目负责人和核心项目提交者。 许可证的有效期为一年，如果您的项目仍符合支持计划的要求，则可以续签。 您可以将免费许可证仅用于开发非商业性开源项目。 您不得与任何第三方共享免 说明：有个公开项目，并添加开源License，近三个月有代码的提交和维护。\n申请开发许可 申请地址：https://www.jetbrains.com/shop/eform/opensource\n填写开源项目信息和个人信息，提交审核后，等待一周左右的时间，审核结果会有邮件回复。通过会有License信息，如果没有通过也会有相关说明。\n",
    "pubDate": "2020-08-19T22:22:25+08:00"
  }, 
  {
    "objectID": 20200818,
    "url": "https://ichochy.com/posts/life/20200818.html",
    "title": "重疾保险理赔的亲身经历，分享下流程和套路",
    "summary": "相信很多人都为自己和家人购买过保险，特别是重疾险。常说保险就是一种保障，可以让你的家庭不会因为高昂的医药费而操心，有病没钱治。\n",
    "content": "相信很多人都为自己和家人购买过保险，特别是重疾险。常说保险就是一种保障，可以让你的家庭不会因为高昂的医药费而操心，有病没钱治。\n购买保险时，都会很轻松，交钱，签字就完事了。可是到了理赔时就会发现没有那么轻松了，在国内保险都是一种宽进严出的处理方式，购买时什么都赔，理赔时给人感觉这也不赔那也不赔。前段时间看到网上很多退保的，买十万，保五万，所以购买时要看清条款和健康告知。\n理赔经历 下面就来说说我的理赔经历：\n首先是提交理赔申请，将个人信息和诊断证明提交，通过初审。\n然后会有专门的理赔员上门对接审查，购买时轻松带过的健康告知，现在开始认真审查起来了，看有没有不符合条款的。询问你的病情的起因，条款一条一条的询问，细细审查，全程录音，并做好笔录签字确认，犹如审判一样，反正给人的感觉不太好（有个很大的疑问：为什么购买保险前不去细细的审查，看看是否符合购买保险的条款，不符合就直接拒保，就没有后面什么事情了）。\n随后会要求调取你的医保流水记录，并配合去各个医院调取你近年来的就医记录，并详细询问就医情况、用药情况，不明确的要找主治医生确认，不漏掉每一个细节，没有什么隐私可言，只能说理赔审查还是很严苛，骗保的可能性不大。\n接下来就开始总结和理赔，不管你是不是初次确诊，只要你之前有相关症状可以人为判断的，就可以不赔，如：长期感冒，感染可能就是某重疾的症状，可以不赔，或协商赔偿，这其中就没有明确的界限，哈哈。\n确认好理赔方案后，签字确认，等待审核，然后就是漫长的等待赔款。\n总结 购买保险时一定要看清条款和如实的健康告知，不然理赔时就可能拒绝赔付。衷心希望大家不需要理赔，合理的安排作息和饮食，有个健康的体魄。\n",
    "pubDate": "2020-08-18T12:22:25+08:00"
  }, 
  {
    "objectID": 20200815,
    "url": "https://ichochy.com/posts/java/20200815.html",
    "title": "Java 开发环境的搭建，开启你的编程之旅",
    "summary": "Java 是一门跨平台的高级程序设计语言，可运行在linux、Windows、Mac OS及其他多种UNIX版本的系统。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等\n",
    "content": "Java 是一门跨平台的高级程序设计语言，可运行在linux、Windows、Mac OS及其他多种UNIX版本的系统。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等\nJava 版本 Java Platform, Standard Edition (Java SE) Java SE 使您可以在台式机和服务器上开发和部署Java应用程序。Java SE和组件技术提供了当今应用程序所需的丰富的用户界面，性能，多功能性，可移植性和安全性。\nJava Platform, Enterprise Edition (Java EE) Java EE 提供了一个API和运行时环境，用于开发和运行大型，多层，可靠且安全的企业应用程序，这些应用程序具有可移植性和可伸缩性，并且可以轻松地与旧版应用程序和数据集成。\nJava Embedded Java ME Embedded 专为资源受限的设备而设计，例如用于M2M的无线模块，工业控制，智能电网基础设施，环境传感器和跟踪等。\nJRE 与 JDK 1、JRE（Java Runtime Environment） JRE顾名思义是Java运行时环境，包含了Java虚拟机，Java基础类库。是使用Java语言编写的程序运行所需要的软件环境，是提供给想运行Java程序的用户使用的。JRE根据不同操作系统（如：Windows，Linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本，最常用的是Oracle公司收购Sun公司的JRE版本。\n2、JDK（Java Development Kit） JDK顾名思义是java开发工具包，是程序员使用Java语言编写Java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译Java源码的编译器javac，还包含了很多Java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了Java程序编写所需的文档和demo例子程序。如果你需要运行Java程序，只需安装JRE就可以了。如果你需要编写Java程序，需要安装JDK。\n安装步骤 下载 JDK Java 官网：https://www.oracle.com/java/\n在 Java下载页面 选择Java版本，然后选择自己系统的安装包下载，并完成安装\n配置环境变量 JAVA_HOME:JDK安装路径位置\nPATH：JDK命令目录位置（jdk\\bin)\nCLASSPATH：类库文件位置（jdk\\lib）\nJava 版本查询 运行 Java 版本命令，检查是否安装成功\njava -version # java 版本信息 java version \u0026#34;1.8.0_162\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode) 运行代码 创建文件 touch HelloWorld.java 写入代码 /** * 通过 Class 定义类 * https://ichochy.com */ public class HelloWorld{ //编写 main 方法，程序中唯一的入口方法 public static void main(String args[] ){ //打印输出 Hello World System.out.println(\u0026#34;Hello World\u0026#34;); System.out.println(\u0026#34;https://ichochy.com\u0026#34;); } } 编译代码 使用编译器javac命令，对源代码文件进行编译操作，产生.class文件。\n该文件是 Java 的字节码文件，Java 虚拟机执行文件，与系统平台无关\njavac HelloWorld.java 运行代码 使用 java命令对.class文件进行解释运行。\njava HelloWorld # 运行结果 Hello World https://ichochy.com 注意：使用java解释时，不需要带.class后缀\n",
    "pubDate": "2020-08-15T11:13:25+08:00"
  }, 
  {
    "objectID": 20200810,
    "url": "https://ichochy.com/posts/blog/20200810.html",
    "title": "HUGO 目录详解，创建自己的网站系统",
    "summary": "HUGO 是一套模版静态化的系统，了解其目录结构有助于创建我们的网站系统\n",
    "content": "HUGO 是一套模版静态化的系统，了解其目录结构有助于创建我们的网站系统\n目录结构 以Hyde主题为例，完整的目录结构如下：\niChochy ├── archetypes 内容模版目录 │ └── default.md 模版文件 ├── config.toml 配置文件 ├── content 内容目录 ├── data 数据目录 ├── layouts 网站模版目录 ├── static 静态文件目录 └── themes 主题目录 └── hyde Hyde主题目录 ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes 内容模版 │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts 网站模版 │ ├── 404.html 404面目模版 │ ├── _default 默认模版目录 │ │ ├── baseof.html 基础模版 │ │ ├── list.html 列表页面模版 │ │ └── single.html 单页面模版 │ ├── index.html 首页模版 │ └── partials 模块模版目录 │ ├── head.html HEAD模块模版 │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static 静态目录 │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 主题配置文件 archetypes 内容模版目录，通过内容模版，使用hugo new命令创建新的内容文件\ndefault.md 内容模版\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} categories: - iChochy tags: - iChochy --- 使用命令：hugo new posts/iChochy.md，生成内容文件 content/posts/iChochy.md\n--- title: \u0026#34;iChochy\u0026#34; date: 2020-08-10T18:13:25+08:00 categories: - iChochy tags: - iChochy --- config.toml 项目的配置文件，列举些常用的参数。如下：\n# 基础参数，通过.Site.xxxx获取参数 # 网站标题 title = \u0026#34;回忆中的明天\u0026#34; # 域名地址 baseURL = \u0026#34;https://ichochy.com/\u0026#34; # 主题名称 theme = \u0026#34;hyde\u0026#34; # 网站的语言代码 languageCode = \u0026#34;zh_CN\u0026#34; # 启用以将相对URL变为绝对URL canonifyURLs = false # Hugo 生成静态站点的目录 publishDir = \u0026#34;docs\u0026#34; # 启用生成robots.txt文件 enableRobotsTXT = false # 启用自动检测内容中的中文/日语/韩语，让.Summary和.WordCount对于CJK语言正确运行 hasCJKLanguage = false # 指定.Summary 的长度 summaryLength = 70 # 默认分页数 paginate = 10 # 启用.html后缀地址，默认URL为/filename/，启用为/filename.html uglyurls = false # 自定义参数，通过.Site.Params.xxxx获取参数 [params] postDir = \u0026#34;posts\u0026#34; layoutReverse = false copyright = \u0026#34;iChochy\u0026#34; description = \u0026#34;码农小站，写点Java、Swift和感悟\u0026#34; # 菜单参数，通过.Site.Menus.main获取参数 # Name为菜单名称、Weight为菜单排序参数、URL为菜单名称 [Menus] main = [ {Name = \u0026#34;Categories\u0026#34;, Weight = 1, URL = \u0026#34;/categories/\u0026#34;}, {Name = \u0026#34;Tags\u0026#34;, Weight = 2, URL = \u0026#34;/tags/\u0026#34;}, {Name = \u0026#34;Links\u0026#34;, Weight = 3, URL = \u0026#34;/links/\u0026#34;}, {Name = \u0026#34;About\u0026#34;, Weight = 4, URL = \u0026#34;/about/\u0026#34;}, {Name = \u0026#34;Feedback\u0026#34;, Weight = 5, URL = \u0026#34;/feedback/\u0026#34;} ] content 内容目录，网站的MD源文件，通过对应的模版生成静态文件\ndata 数据目录，存储结构数据，可以用YAML，JSON或TOML格式编写数据文件，可用.Site.Data.xxxx的方式来获取数据\nlayouts 模版目录，以.html文件形式存储模板，这些模板指定如何将内容目录中的源文件呈现到静态网站中\n模版包括：主页模版、单页模板、列表模版、分类模版、模块模版等\nstatic 静态文件目录，存储所有静态内容，如：Image，CSS，JavaScript等\n当Hugo建立您的网站时，静态目录内的所有文件均按原样复制生成，可有来存储效验文件、CNAME文件等\n",
    "pubDate": "2020-08-10T18:13:25+08:00"
  }, 
  {
    "objectID": 20200807,
    "url": "https://ichochy.com/posts/java/20200807.html",
    "title": "了解 JS 的加载顺序和方式，实现 Ready 方法",
    "summary": "页面加载 JS 顺序或方式不同，可能会导致功能失效、错误的产生或加载解析时间过长，拖慢整个页面展示。\n",
    "content": "页面加载 JS 顺序或方式不同，可能会导致功能失效、错误的产生或加载解析时间过长，拖慢整个页面展示。\n了解 JS 的加载顺序 了解页面元素的加载顺序，找到 JS 执行失败原因。有时明明没有问的代码，可就获取不到元素值或信息，这可能是JS执行时间过早或过晚，而导致的 JS 执行失败。\n我们来看一幅图，了解defer、async属性对JS下载、执行顺序的影响 默认情况下，浏览器解析到JS文件就会立即下载文件，并执行文件，JS提前执行，获取不到页面元素，并导致页面解析中断，拖慢整个页面的加载。 添加async属性后，就会异步下载JS文件并执行，执行时间不可控，JS执行时间过早或过晚，而导致的 JS 执行错误或失败。 添加defer属性后，就会异步下载JS文件，等页面解析完成后再执行JS Ready方法的实现 很多时候我们不把JS放在head中，而把JS放到body的最后面也就很好解释了？\n首先，JS的下载和执行会中断页面的解析，拖慢整个页面展示， 然后，放在head中，页面元素还没有加载，JS方法就无法获取或处理页面上的元素，这一点很容易忽视， 但是，我们还有ready方法。 jQuery中的ready方法会在页面解析后运行，语法如下：\n//语法 1 $(document).ready(function) //语法 2 $().ready(function) //语法 3 $(function) 自定义方法，通过监听DOMContentLoaded实现ready方法\n/** * 页面解析后执行 fn * https://ichochy.com * / function ready(fn) { if (document.addEventListener) { document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { //注销时间，避免重复触发 document.removeEventListener(\u0026#39;DOMContentLoaded\u0026#39;, arguments.callee, false); fn(); //运行函数 }, false); } else if (document.attachEvent) { //IE浏览器 document.attachEvent(\u0026#39;onreadystatechange\u0026#39;, function () { if (document.readyState == \u0026#39;complete\u0026#39;) { document.detachEvent(\u0026#39;onreadystatechange\u0026#39;, arguments.callee); fn(); //函数运行 } }); } } 当然还有我的onload方法，可以在页面完成所有加载后再执行\n//window 的 onload window.onload = function(){ //load https://ichochy.com //some things …… } //body 的 onload \u0026lt;body onload=\u0026#34;load()\u0026#34;\u0026gt; 总结 可以看到，JS的执行顺序决定着程序是否正常工作。加载过早，可能无法获取到页面元素，而太晚，页面元素无法交互。对于执行的顺序，要以当前的程序功能而定。\n",
    "pubDate": "2020-08-07T16:13:25+08:00"
  }, 
  {
    "objectID": 20200802,
    "url": "https://ichochy.com/posts/blog/20200802.html",
    "title": "免费创建属于自己的博客，Hugo+Github Pages",
    "summary": "Hugo 拥有超快的速度，强大的内容管理和强大的模版语言，使其非常适合各种静态网站。可以轻松安装在macOS，Linux，Windows等平台上，在开发过程中使用LiveReload可即时渲染更改\n",
    "content": "Hugo 拥有超快的速度，强大的内容管理和强大的模版语言，使其非常适合各种静态网站。可以轻松安装在macOS，Linux，Windows等平台上，在开发过程中使用LiveReload可即时渲染更改\n一、安装 Hugo Mac 上安装 HUGO，很简单，通过 brew 可以快速安装\nbrew install hugo 检查安装版本信息\nhugo version 二、使用 Hugo 1、创建网站 hugo new site iChochy 创建\n其中 iChochy 为你的博客目录\n目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 2、添加主题 a、下载主题 以 hyde主题为例 https://github.com/spf13/hyde\n直接下载主题，放到themes目录中，或通过 git 方式添加主题\ngit submodule add https://github.com/spf13/hyde.git themes/hyde b、修改配置 echo \u0026#39;theme = \u0026#34;hyde\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml config.toml 文件内容\nbaseURL = \u0026#34;https://ichochy.com/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;hyde\u0026#34; 目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 3、编写内容 新建文章 hugo new posts/HelloWorld.md 新建\n注：以 archetypes/default.md为模版创建\n编写文章 vim content/posts/HelloWorld.md HelloWorld.md 文件内容\n--- title: \u0026#34;HelloWorld\u0026#34; date: 2020-08-02T21:47:48+08:00 draft: true --- ### HelloWorld https://ichochy.com 预览文章 hugo server -D 启动服务，访问 http://localhost:1313\n目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content │ └── posts │ └── HelloWorld.md ├── data ├── layouts ├── resources │ └── _gen │ ├── assets │ └── images ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 部署 修改部署目录 修改 config.toml 文件\n1、修改 bashURL 的部署域名\n2、添加 publishDir = \u0026quot;docs\u0026quot;，指定部署目录为 docs\nconfig.toml 文件内容\nbaseURL = \u0026#34;https://ichochy.com/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;hyde\u0026#34; publishDir = \u0026#34;docs\u0026#34; 生成静态文件 hugo -D 生成静态文件\n目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content │ └── posts │ └── HelloWorld.md ├── data ├── docs │ ├── 404.html │ ├── apple-touch-icon-144-precomposed.png │ ├── categories │ │ ├── index.html │ │ └── index.xml │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ ├── favicon.png │ ├── index.html │ ├── index.xml │ ├── posts │ │ ├── helloworld │ │ │ └── index.html │ │ ├── index.html │ │ └── index.xml │ ├── sitemap.xml │ └── tags │ ├── index.html │ └── index.xml ├── layouts ├── resources │ └── _gen │ ├── assets │ └── images ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 部署 GitHub Pages 将整个项目推送到 GitHub，然后在项目的 Settings 中开启的 GitHub Pages，并指定分支和目录 docs 就是可以直接在线访问了，如：https://ichochy.github.io\n总结 Hugo 简单、易用、快速\n模版化强大，只需要关心文章的编写\n默认开启 LiveReload，修改后可以实时预览，免去手去刷新操作\n还有很多强大的功能，如：摘要(Summary)、文章目录(TableOfContents)、相关推荐(Related)、多语言支持(i18n)、列表分页(Pagination)、简码(Shortcodes)等。\n",
    "pubDate": "2020-08-02T13:13:25+08:00"
  }, 
  {
    "objectID": 20200710,
    "url": "https://ichochy.com/posts/elasticsearch/20200710.html",
    "title": "Elastic Stack 实现日志的自动采集、搜索和分析",
    "summary": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\n",
    "content": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎\nKibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化管理和展示\nBeats 是一个免费且开放的平台，集合了多种单一用途数据采集器，将数据发送给 Logstash 或 Elasticsearch\nLogstash 是一个免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中\n一、下载镱像(image) 搜索镱像(image)\ndocker search elasticsearch docker search kibana docker search logstash 获取镱像(image)\ndocker pull elasticsearch:7.6.0 #镜像名称:Tag docker pull kibana:7.6.0 #镜像名称:Tag docker pull logstash:7.6.0 #镜像名称:Tag 注：版本要统一\n二、创建 ELK.yml ELK.yml\nversion: \u0026#34;3.5\u0026#34; services: elasticsearch: container_name: elasticsearch image: elasticsearch:7.6.0 #镱像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana image: kibana:7.6.0 #镱像(image) restart: always #重启方式 environment: I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 logstash: container_name: logstash image: logstash:7.6.0 restart: always volumes: #文件夹映射，本地:容器 - \u0026#34;/Users/iChochy/logs:/usr/share/logstash/logs\u0026#34; ports: - \u0026#34;5044:5044\u0026#34; - \u0026#34;9600:9600\u0026#34; volumes自定义监控的文件夹\n**注：**注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败\n# 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here 三、运行容器 宿主机hosts中添加\n127.0.0.1 elasticsearch 命令启动\ndocker-compose -f ELK.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 四、检查容器的运行状态 elasticsearch 访问：http://127.0.0.1:9200\nlogstash 访问：http://127.0.0.1:9600\nKibana 访问：http://127.0.0.1:5601，进入 Kibana\n运行docker ps查询容器运行状态，可以查看到容器的ID\nmleo$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b8cb2effede logstash:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 hours ago Up About an hour 0.0.0.0:5044-\u0026gt;5044/tcp, 0.0.0.0:9600-\u0026gt;9600/tcp logstash 69b8bc678e4e kibana:7.6.0 \u0026#34;/usr/local/bin/dumb…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:5601-\u0026gt;5601/tcp kibana 8c655f5b7493 elasticsearch:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp elasticsearch 运行docker logs id查看容器运行日志\n例：持续查看logstash日志 docker logs 1b8cb2effede -f 五、修改logstash配置，监控日志文件 运行docker exec -it 1b8cb2effede bash进入logstash 运行vi pipeline/logstash.conf修改logstash默认配置 input { beats { port =\u0026gt; 5044 } file { path =\u0026gt; \u0026#34;/usr/share/logstash/logs/*\u0026#34; #监控的文件路径 } } output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;http://elasticsearch:9200\u0026#34;] #elasticsearch请求地址 index =\u0026gt; \u0026#34;ichochy\u0026#34; #索引名称 } } 运行docker restart 1b8cb2effede重启 logstash 六、采集日志 在logstash的监控的文件路径下动态添加日志文件，日志就可以自动采集到 elasticsearch\ntouch web.log #创建日志文件 echo \u0026#34;www.ichochy.com\u0026#34; \u0026gt; web.log #添加日志信息 查看 logstash 日志信息可以看到打印的日志\n{ \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;path\u0026#34; =\u0026gt; \u0026#34;/usr/share/logstash/logs/web.log\u0026#34;, \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;1b8cb2effede\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2020-07-10T14:07:16.633Z, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;www.ichochy.com\u0026#34; } 七、搜索、分析日志 访问：http://127.0.0.1:5601，进入 Kibana\n在Discover可以看到刚刚添加进来的日志数据，开始表演…………\n",
    "pubDate": "2020-07-10T15:28:45+08:00"
  }, 
  {
    "objectID": 20200622,
    "url": "https://ichochy.com/posts/blog/20200622.html",
    "title": "个人站长的加速器 - 百度云加速",
    "summary": "免费申请20个SSL证书，支持HTTPS、多CDN节点，国内外加速、每天10G流量、3条特定页面规则等\n",
    "content": "免费申请20个SSL证书，支持HTTPS、多CDN节点，国内外加速、每天10G流量、3条特定页面规则等\n套餐对比：https://su.baidu.com/plan.html#compare\n一、域名接入 NS接入方式（推荐）\n一劳永逸，NS方式可以使用百度高智能DNS服务\nCNAME接入方式\n简单快捷、生效迅速，每个子域名都需要单独设置CNAME解析\n二、管理子域名，开启CDN 添加子域名解析，默认开启小云朵\n三、申请SSL证书 百度云加速为方便用户使用HTTPS服务，联合知名CA证书厂商，推出了证书申请服务。证书申请成功后可以直接部署到CDN节点，实现一键HTTPS加密。\n云加速为用户提供了两类证书：\n专有证书： 可以为指定的域名申请独享的证书，在用户侧证书显示的是网站真实的域名。目前只要您的域名接入云加速，即可以免费为域名申请此类SSL证书。单个域名最多可以申请20个子域证书（包括在其他渠道申请的数量，不支持泛域申请），每个证书的有效期为1年。\n通用证书： 可以为主域的所有子域名申请SSL证书，在用户侧证书显示的是统一的非本域名名称。此类证书可申请的子域名证书个数没有限制，仅限收费版套餐使用。\n四、开启全站HTTPS 关闭：暂停HTTPS访问和加速，支持HTTP访问和加速。 半程加密：仅在网民到CDN节点的访问采用HTTPS服务。 全程加密：网民到CDN节点和CDN节点到源站都采用HTTPS服务。但是不校验源站证书。\n须源站开通并支持SSL，同时支持自签名证书和受信任的CA签发的证书。 严格加密：网民到CDN节点和CDN节点到源站都采用HTTPS服务。且校验源站证书。\n须源站开通并支持SSL，只支持受信任的CA签发的证书。 五、其它，跳转HTTPS 特定页面规则-实现跳转HTTPS，*为通配符，$为变量\n六、总结 对于个人来说，已经基本够用了，就是个人认证需要手持身份证，多节点CDN速度很稳定，全国有7个节点\n送上邀请地址：https://su.baidu.com/?ic=1dR4jc\n",
    "pubDate": "2020-06-22T12:22:45+08:00"
  }, 
  {
    "objectID": 20200605,
    "url": "https://ichochy.com/posts/software/20200605.html",
    "title": "Office 批量激活的命令工具 slmgr",
    "summary": "软件许可证管理器脚本用于配置和检索 Office KMS 主机和 Windows 主机的批量激活信息。\n",
    "content": "软件许可证管理器脚本用于配置和检索 Office KMS 主机和 Windows 主机的批量激活信息。\n适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\nslmgr.vbs 脚本 您可以在目标计算机上以本地方式运行脚本，或从另一台计算机中以远程方式运行。您必须是管理员才能使用此脚本。如果标准用户运行 slmgr.vbs，则某些许可证数据可能缺失或不正确，并且许多操作将被禁止。\nslmgr.vbs 脚本可以使用基于 Windows 的脚本主机 wscript.exe 或基于命令的脚本主机 cscript.exe，管理员可以指定要使用的脚本引擎。如果未指定脚本引擎，slmgr.vbs 将使用默认脚本引擎 wscript.exe 运行。我们建议使用 cscript.exe 脚本引擎。\n您必须重新启动软件授权服务才能使任何更改生效。若要重新启动软件授权服务，请使用 Microsoft 管理控制台 (MMC) 服务管理单元或运行以下命令：\nnet stop sppsvc \u0026amp;\u0026amp; net start sppsvc slmgr.vbs 脚本需要至少一个参数。如果您运行不带任何参数的脚本，则会显示帮助信息。下表列出了 slmgr.vbs 的命令行选项以及每个选项的说明。该表中的大多数参数都用于配置 KMS 主计算机。不过，参数 /sai 和 /sri 是在 KMS 客户端与 KMS 主计算机联系后才传递给 KMS 客户端。\nslmgr.vbs 的常规语法如下所示（假定所使用的脚本引擎为 cscript.exe）： cscript slmgr.vbs /parameter cscript slmgr.vbs [ComputerName] [User] [Password] [Option] ComputerName ：远程计算机的名称。如果您不提供计算机名称，则使用本地计算机。\nUser：远程计算机上具有所需权限的帐户。\nPassword ：帐户的密码。如果您不提供用户帐户和密码，则使用当前凭据。\nOption：选项显示在下表中。\nSlmgr.vbs 命令选项 选项 说明 / ipk [ProductKey] 为 Windows（默认设置）或由产品密钥标识的其他应用程序安装产品密钥。 / ato [ActivationID] 激活 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主机。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 / dti [ActivationID] 显示用于 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主计算机的电话激活的安装 ID。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 在电话中输入安装 ID 以接收确认 ID，该 ID 用于使用 /atp 参数激活 KMS 主机。 / atp [ConfirmationID][ActivationID] 收到确认 ID 后，激活 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主机。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 / dlv [ActivationID] 显示有关 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的详细许可证信息。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。例如，在提升的命令符处运行以下命令，在 C:\\windows\\system32 文件夹中获取 Office KMS 主机的状态：cscript slmgr.vbs /dlv 70512334-47B4-44DB-A233-BE5EA33B914C / dli [ActivationID] 显示有关 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的许可证信息。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 / upk [ActivationID] 卸载 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的产品密钥。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 警告： 如果打算卸载 Office 产品密钥，并且忘记要输入激活 ID，则所有已安装的产品密钥将被卸载。 这包括 Windows 产品密钥。 / xpr [ActivationID] 显示当前许可证状态的到期日期。 / sprt [PortNumber] 在 KMS 主计算机上设置 TCP 通信端口。此操作会将 PortNumber 替换为要使用的 TCP 端口号。默认设置为 1688 。 / cdns 禁止通过 KMS 主计算机自动发布 DNS。 / sdns 启用通过 KMS 主计算机自动发布 DNS。 / cpri 降低 KMS 主计算机进程的优先级。 / sai [ActivationInterval] 更改当 KMS 客户端找不到 KMS 主计算机时尝试激活其自身的频率。此操作会将 ActivationInterval 替换为一个分钟数。默认设置为 120 分钟。 / sri [RenewalInterval] 更改 KMS 客户端尝试通过联系 KMS 主计算机来续订其激活状态的频率。此操作会将 RenewalInterval 替换为一个分钟数。默认设置为 10080 分钟（7 天）。此设置将替代本地 KMS 客户端设置。 Slmgr.vbs 命令选项 基于 Active Directory 的激活 选项 说明 / ad-activation-online [ProductKey] 通过用户提供的产品密钥激活 AD DS 林。 / ad-activation-apply-get-iid [ProductKey] 显示用于 AD DS 林的安装 ID。 / ad-activation-apply-cid [ProductKey][ConfirmationID] 通过用户提供的产品密钥以及确认 ID 激活 AD DS 林。 ",
    "pubDate": "2020-06-05T19:22:45+08:00"
  }, 
  {
    "objectID": 20200602,
    "url": "https://ichochy.com/posts/software/20200602.html",
    "title": "Office 批量激活的命令工具 ospp",
    "summary": "Office 软件保护平台脚本使你能够配置 Office 产品（包括 Project 和 Visio）的批量许可版本。\n",
    "content": "Office 软件保护平台脚本使你能够配置 Office 产品（包括 Project 和 Visio）的批量许可版本。\nospp.vbs 脚本 opss.vbs 脚本位于 Program Files\\Microsoft Office\\Office16 或 Program Files (x86)\\Microsoft Office\\Office16 文件夹。\n适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\n运行 ospp.vbs 需要 cscript.exe 脚本引擎\n若要查看帮助文件，请键入以下命令，然后按 Enter：\ncscript ospp.vbs /? 常规语法如下所示：\ncscript ospp.vbs [Option:Value] [ComputerName] [User] [Password] Option：指定用于执行以下操作的选项和值：激活产品、安装或卸载产品密钥、安装和显示许可证信息、设置 KMS 主机名和端口，以及删除 KMS 主机名和端口。本节中的表中列出了这些选项和值。\nComputerName：远程计算机的名称。如果不提供计算机名称，则使用本地计算机。\nUser：在远程计算机上拥有所需权限的帐户。\nPassword：帐户的密码。如果不提供用户帐户和密码，则使用当前凭据。\nospp.vbs 的全局选项 全局选项 说明 /act 激活已安装的 Office 产品密钥。 /inpkey:value 使用用户提供的产品密钥安装产品密钥（取代现有密钥）。Value 选项为必需。 /unpkey:value 卸载安装的产品密钥（包含要卸载的产品密钥的最后五位数，如 /dstatus 选项显示）。Value 参数必需。 /inslic:value 使用用户提供的 .xrm-ms 许可证路径安装许可证。Value 参数必需。 /dstatus 显示已安装产品密钥的许可证信息。 /dstatusall 显示所有已安装许可证的许可证信息。 /dhistoryacterr 显示 MAK/零售激活的失败历史记录。 /dinstid 显示用于脱机激活的安装 ID。 /actcid:value 使用用户提供的确认 ID 激活产品。Value 参数必需。 /rearm 重置所有已安装 Office 产品密钥的许可状态。 /rearm:value 重置具有用户提供的 SKUID 值的 Office 许可证的许可状态。 Value 参数必需。 /ddescr:value 显示用户提供的错误代码的说明。Value 参数必需。 ospp.vbs 的 KMS 客户端选项 KMS 客户端选项 说明 /dhistorykms 显示 KMS 客户端激活历史记录。 /dcmid 显示 KMS 客户端计算机 ID (CMID)。 /sethst:value 使用用户提供的主机名设置 KMS 主机名。Value 参数为必需。这将设置 HKLM\\Software\\Microsoft\\OfficeSoftwareProtectionPlatform\\KeyManagementServiceName (REG_SZ) 。 /setprt:value 使用用户提供的端口号设置 KMS 端口。默认端口号为 1688。Value 参数为必需。这将设置 HKLM\\Software\\Microsoft\\OfficeSoftwareProtectionPlatform\\KeyManagementServicePort (REG_SZ) 。 /remhst 删除 KMS 主机名并将端口设置为默认值。默认端口为 1688。 /cachst:value 允许或拒绝 KMS 主机缓存。Value 参数必需（TRUE 或 FALSE）。 /actype:value 设置批量激活类型。Value 参数必需。值：1（表示基于 Active Directory），2（表示 KMS），0（表示二者）。 /skms-domain:value 设置可在其中找到所有 KMS SRV 记录的特定 DNS 域。如果特定的一个 KMS 主机名是由 /sethst 选项设置的，则此设置不起作用。Value 参数是完全限定的域名 (FQDN) 并且必需。 /ckms-domain 清除可在其中找到所有 KMS SRV 记录的特定 DNS 域。如果特定 KMS 主机是由 /sethst 选项设置的，则会使用该主机。否则，将使用 KMS 主机的自动发现。 使用 ospp.vbs 的方案 在远程计算机上将产品密钥更改为 MAK 密钥 如果远程计算机名为 contoso1，请运行以下命令输入产品密钥。此操作假定您在远程计算机上拥有管理员凭据。如果您在远程计算机上的凭据与您的登录名和密码不同，则必须在命令行中键入您的登录名和密码，然后按 Enter： cscript ospp.vbs /inpkey:xxxxx-xxxxx-xxxxx-xxxxx-xxxxx contoso1 若要激活远程计算机，请键入以下命令，然后按 Enter： cscript ospp.vbs /act contoso1 诊断 KMS 激活错误 如果计算机安装了 KMS 客户端密钥，请检查授权状态。为此，请键入以下命令，然后按 Enter： cscript ospp.vbs /dstatusall 若要检查 KMS 激活历史记录，请键入以下命令，然后按 Enter： cscript ospp.vbs /dhistorykms 若要触发激活，请键入以下命令，然后按 Enter： cscript ospp.vbs /act 检查错误消息中是否有错误代码 0xC004F042。如果在通知对话框中看到向用户显示的错误代码，您也可以使用该代码来检查错误消息。为此，请键入以下命令，然后按 Enter： cscript ospp.vbs /ddescr:0xC004F042 打开或关闭 KMS 客户端上的 KMS 主机缓存 在 KMS 客户端计算机上，若要打开缓存，请键入下面的命令，然后按 Enter： cscript ospp.vbs /cachst:TRUE 在 KMS 客户端计算机上，若要关闭缓存，请键入下面的命令，然后按 Enter： cscript ospp.vbs /cachst:FALSE 测试 KMS 主机名，然后设置为自动发现 如果在测试名为 kmstest.contoso.com 的 KMS 主机，并且要在 KMS 客户端中指定该主机，请键入以下命令，然后按 Enter： cscript ospp.vbs /sethst:kmstest.contoso.com 若要触发激活，请键入以下命令，然后按 Enter： cscript ospp.vbs /act 若要检查 KMS 激活历史记录以查看是否成功连接主机，请键入以下命令，然后按 Enter： cscript ospp.vbs /dhistorykms 现在，您希望此 KMS 客户端使用域名系统 (DNS) 自动发现生产 KMS 主机。若要移除 KMS 主机名，请键入以下命令，然后按 Enter： cscript ospp.vbs /remhst ",
    "pubDate": "2020-06-02T19:22:45+08:00"
  }, 
  {
    "objectID": 20200528,
    "url": "https://ichochy.com/posts/software/20200528.html",
    "title": "KMS 激活 Office 批量许可证密钥 KEY",
    "summary": "在配置为支持 Office 批量激活的 KMS 主计算机上，你只需安装和启用一个 KMS 主机密钥，即可激活 Office 的所有批量许可版本。\n",
    "content": "在配置为支持 Office 批量激活的 KMS 主计算机上，你只需安装和启用一个 KMS 主机密钥，即可激活 Office 的所有批量许可版本。\nOffice 的所有批量许可版本（包括 Project 和 Visio）都预安装了通用批量许可密钥 (GVLK)。\nGVLK 支持通过密钥管理服务 (KMS) 激活和基于 Active Directory 的激活。\nOffice 2019 的 GVLK Product GVLK Office 专业增强版 2019 NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP Office 标准版 2019 6NWWJ-YQWMR-QKGCB-6TMB3-9D9HK Project 专业版 2019 B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B Project 标准版 2019 C4F7P-NCP8C-6CQPT-MQHV9-JXD2M Visio 专业版 2019 9BGNQ-K37YR-RQHF2-38RQ3-7VCBB Visio 标准版 2019 7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2 Access 2019 9N9PT-27V4Y-VJ2PD-YXFMF-YTFQT Excel 2019 TMJWT-YYNMB-3BKTF-644FC-RVXBD Outlook 2019 7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK PowerPoint 2019 RRNCX-C64HY-W2MM7-MCH9G-TJHMQ Publisher 2019 G2KWX-3NW6P-PY93R-JXK2T-C9Y9V Skype for Business 2019 NCJ33-JHBBY-HTK98-MYCV8-HMKHJ Word 2019 PBX3G-NWMT6-Q7XBW-PYJGG-WXD33 Office 2016 的 GVLK Product GVLK Office 专业增强版 2016 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 Office Standard 2016 JNRGM-WHDWX-FJJG3-K47QV-DRTFM Project Professional 2016 YG9NW-3K39V-2T3HJ-93F3Q-G83KT Project Standard 2016 GNFHQ-F6YQM-KQDGJ-327XX-KQBVC Visio Professional 2016 PD3PC-RHNGV-FXJ29-8JK7D-RJRJK Visio Standard 2016 7WHWN-4T7MP-G96JF-G33KR-W8GF4 Access 2016 GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW Excel 2016 9C2PK-NWTVB-JMPW8-BFT28-7FTBF OneNote 2016 DR92N-9HTF2-97XKM-XW2WJ-XW3J6 Outlook 2016 R69KK-NTPKF-7M3Q4-QYBHW-6MT9B PowerPoint 2016 J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6 Publisher 2016 F47MM-N3XJP-TQXJ9-BP99D-8837K Skype for Business 2016 869NQ-FJ69K-466HW-QYCP2-DDBV6 Word 2016 WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6 适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\n",
    "pubDate": "2020-05-28T12:12:45+08:00"
  }, 
  {
    "objectID": 20200526,
    "url": "https://ichochy.com/posts/aml/20200526.html",
    "title": "移植物抗宿主病详解",
    "summary": "移植物抗宿主病（graft versus host disease，GVHD）是allo- HSCT最常见的并发症，分为急性和慢性2种类型。\n",
    "content": "移植物抗宿主病（graft versus host disease，GVHD）是allo- HSCT最常见的并发症，分为急性和慢性2种类型。\naGVHD是供者T细胞识别不匹配的宿主多态性组织相容性抗原而发生的免疫应答； cGVHD也是由供者T细胞引发，但是参与应答的抗原特性、细胞类型以及发生机制尚未明了。\n移植物抗宿主病发病机制 GVHD发生条件 异基因HCT后，即便是人类白细胞抗原（human leukocyte antigen，HLA）完全匹配的亲缘供者移植、尽管受者接受严格的免疫抑制预防，仍无法完全避免发生GVHD，这是由于供受者间存在病理生理学差异造成的。早年Billingham就提出GVHD发病必备3个条件：移植物含有免疫活性细胞、供受者之间存在组织不相容性、受者不排斥或灭活输注或植入的细胞。\naGVHD发生机制 HLA是主要组织相容性复合物（major histocompatibility complex，MHC）编码的高度多态性蛋白，次要组织相容性抗原（minor histocompatibility antigen，miHA）是MHC以外的多态性基因编码的多肽。它们是在异基因HCT宿主引发GVH反应的最重要的免疫原性蛋白。这些组织不相容的宿主多态性抗原经来自受者和（或）供者的APC提呈，被供者同种反应性T细胞识别，最终造成aGVHD的靶器官损伤；同时一些非特异性炎症介质进一步加重这种损伤。根据实验动物研究结果，aGVHD的发生可以理解为连续的3个阶段：抗原提呈细胞（antigen presenting cells，APC）活化；供者T细胞活化、增殖、分化和迁移；靶器官损伤。\ncGVHD发生机制 一直以来，未能建立一个实验动物模型恰当地模拟临床cGVHD特征，这种状况一定程度上使得对cGVHD发病机制的理解远不如aGVHD清楚。可能的机制是供者反应性供者型Th细胞逃逸胸腺阴性选择，识别MHC抗原肽复合物后活化增殖，继而协助自身反应性B细胞合成自身抗体，最终产生类似自身免疫病的cGVHD征象。\n移植物抗宿主病临床分型 根据GVHD发生时间在移植后100天之内或之外，传统分类法将之分为急性和慢性2种类型。急性或慢性GVHD事实上存在本质差别。这种分类法是基于发病时间，而非疾病的临床或病理生理特征，在临床应用中存在一定局限性。比如，接受减低强度预处理的患者可在移植90天以后发生aGVHD；供者淋巴细胞输注后很快可以发生cGVHD征象，移植后100天以内也可再出现cGVHD的典型症状；此外某些常见征象在急性或慢性GVHD均可出现。为此，NIH根据特异征象而非发生时间提出了aGVHD和cGVHD的定义，其中aGVHD亚型包括经典、迁延、复发、迟发型，cGVHD亚型包括经典型和重叠综合征（overlap syndrome）。\nGVHD分类标准\n注：DLI，供者淋巴细胞输注\n组织病理学 病变脏器细胞凋亡是aGVHD典型的组织学特征，受累细胞是与组织增殖和再生有关的上皮细胞，包括表皮或上皮组织的基底细胞和基底上细胞、小肠上皮细胞和肝胆管上皮细胞。凋亡细胞周边出现免疫细胞浸润——即所谓的“卫星细胞坏死”——是aGVHD受损脏器的一个共同病理特征。皮肤GVHD病变在真皮表皮交界处最为严重，可见表皮细胞和基底细胞空泡变性、表皮细胞角化不良、嗜酸小体形成以及黑素细胞增生。最严重的皮肤GVHD表现为表皮坏死（Lyell综合征），活检见整个基底层角化细胞卫星坏死，导致表皮上层与基底层分离。肠道GVHD的病理特征是紧邻上皮内淋巴细胞出现隐窝上皮基底细胞凋亡。肝脏GVHD的靶细胞是胆管上皮细胞，淋巴细胞浸润主要发生在汇管区。有时可见肝细胞灶性坏死，但在GVHD急性期不出现肝硬化。肝小胆管可见节段性损伤、胆管周围上皮细胞损伤、胆管变形和细胞变性。\ncGVHD的组织学表现通常为苔藓样改变、干燥、管腔狭窄（stricture）或硬化。累及脏器较aGVHD更为广泛，包括皮肤（硬皮病）、口腔（口腔干燥症）、眼（干眼症）、阴道、食管、肝、肺（阻塞性细支气管炎）、筋（肌）膜炎、浆膜炎（心包或胸腔积液），而肾脏（肾病综合征）较少累及。根据病变严重程度不同，有时可出现多血质病理特征；但是器官纤维化是cGVHD不同于aGVHD的最具特征的病理学表现。\n移植物抗宿主病临床表现及分型 1.急性移植物抗宿主病临床表现 有明显临床征象的aGVHD（Ⅱ～Ⅳ度）的发病率因移植种类不同而在10%～80%不等，平均约为40%。aGVHD典型征象一般出现在清髓性异基因HCT后20～40天内，或在减低强度预处理异基因HCT后更迟的时候。主要累及皮肤、胃肠道和肝脏。\n手掌、脚底皮肤斑丘疹往往成为aGVHD先发征象。皮损可伴有痒觉和（或）痛觉，随之波及颜面，乃至全身皮肤；严重者形成水疱或发生表皮剥脱。皮肤aGVHD需与预处理皮损、植入综合征等鉴别。预处理毒性造成的皮损常发生于移植后3周以内（抑制期），病理特征为表皮淋巴细胞浸润，损伤细胞发生坏死而非凋亡；植入综合征发生在移植后粒细胞重建72小时内，特征表现为非感染性发热、皮疹、肺浸润/低氧血症；皮肤活检可以确诊aGVHD，表现为电镜发现卫星细胞坏死、抗TNF抗体标记上皮内激活淋巴细胞。\n肝脏病变表现为胆汁淤积性肝炎，可以出现黄疸；淤胆性指标升高，而转氨酶的变化没有特异性。肝脏aGVHD有时很难与治疗相关性肝炎、感染、肝静脉闭塞症鉴别。药物性或感染性肝炎可以找寻明确的病因，病变最初表现为肝实质细胞损伤，以转氨酶升高为主；肝静脉闭塞症发生于移植后早期（35～40天），特征表现为黄疸、肝大和水钠潴留，典型病理特征是肝内小静脉腔向心性非血栓性狭窄，血清纤维蛋白原活化抑制物（PAI- 1）水平增高。\n胃肠道aGVHD起病常表现为恶心呕吐和绿色水样便，腹泻量与肠道累及程度正相关，严重者伴有剧烈腹痛、鲜血便；极轻型仅累及上消化道，仅表现为食欲减退和恶心，对免疫抑制剂治疗有效。肠道GVHD需与病毒感染，尤其是CMV感染鉴别，典型GVHD病理改变容易加以区分，而且感染上皮细胞可以清晰见到病毒包涵体，抗CMV抗体染色（+）；但是GVHD早期病理改变易与CMV感染混淆，而且二者常可伴发，因此有必要采用针对CMV早期蛋白的治疗加以区分。\n2.急性移植物抗宿主病分级和分度 1974年Glucksberg等首次提出aGVHD分类标准。将皮肤、肝脏、胃肠道3个主要累及脏器的功能指标分为0～4级（stage）（表153- 5），综合这些客观指标以及临床功能状态的主观评定将aGVHD分为Ⅰ～Ⅳ度（grade）（表153-6）。习惯上将aGVHD分为临床征象不明显的0～Ⅰ度和征象明显的Ⅱ～Ⅳ度。鉴于这个分度法中主观评定的局限性，1995年NIH的Consensus Workshop在此基础上做出一些改良，摒弃了“临床状况”这一主观参数（表153- 7）。\n表153-5　aGVHD脏器累及分级\n表153-6　Glucksberg aGVHD分度系统（1974年）\n表153-7　NIH aGVHD分度系统（1995年）\n3.慢性移植物抗宿主病临床表现 cGVHD是异基因HCT晚期最主要的并发症，是造成晚期非复发死亡的主要原因。cGVHD临床表现多样，累及脏器较aGVHD更多。疾病特征类似许多自身免疫性疾病或其他免疫性疾病，如硬皮病、Sjǎgren综合征、原发性胆汁性肝硬化、Wasting综合征、阻塞性细支气管炎、免疫性血细胞减少和慢性免疫缺陷病等。\ncGVHD通常在HCT后3年内起病，存在三种病理过程：aGVHD的延续（progressive）、在aGVHD停止一段时间后发病（quiescent）、发病前无aGVHD征象（de novo），以前两种常见。\n4.慢性移植物抗宿主病分型 自1980年沿用至今的西雅图标准将cGVHD分为局限型和广泛型2类。此标准来自于1个仅20例患者的回顾性观察，近年多有建议使用NIH提出的cGVHD器官积分系统来分型。这个总体积分系统是从患者功能状况上来综合反映cGVHD的病变程度，将cGVHD分为轻、中、重三型（表153- 8）。\n表153-8　2005年NIH Consensus Development Project推荐的cGVHD器官评分和总体评价系统\n注：AKP =alkaline phosphatase，ALT=alanine aminotransferase，AST=aspartate aminotransferase；FEV1=forced expiratory volume in 1s；LFS=lung function score（includes FEV1and diffusion capacity of the lung for CO）\n当症状与肺功能试验积分不符时，以高积分者为准\nGVHD相关肺损伤 移植后非感染性肺部并发症与GVHD密切相关，是HCT相关死亡的一个主要原因。在GVHD的致病过程中，是否引起肺的同种反应性损伤，目前还很难定论，因为支持GVHD肺损伤的实验数据还很少。许多肺部并发症被认为是GVHD反应的表现，主要依据仅是基于肺部改变与GVHD同时出现而不存在感染因素，而并没有发现GVHD的特征性病理损伤。不过，许多移植后早期或晚期发生的肺损伤综合征都与GVHD有着密切的临床联系，如特发性肺炎综合征（idiopathic pneumonia syndrome，IPS）、植入综合征、阻塞性细支气管炎（bronchiolitis obliterans，BO）、阻塞性细支气管炎伴肌化性肺炎（bronchiolitis obliterans organizing pneumonia，BOOP）等。\nBO多发生于移植后3个月，几乎常与cGVHD相关，1/3以上的cGVHD患者可能发生呼吸道结构异常，其中大部分为BO，组织学特征是呼吸性和膜性细支气管内腔纤维性阻塞。表现为干咳、呼吸困难和喘息，胸部X线可能漏诊，高分辨CT常可见到呼气性气阱（air trapping）、纹理稀薄（hypoattenuation）和支气管扩张。HCT后气道阻塞的病因不清，由于cGVHD与初次发生的气道阻塞之间关系密切，因此推测免疫机制是造成支气管上皮细胞损伤的原因，推测BO可能是cGVHD在肺部的表现。\nBOOP非常少见，病例对照研究（n = 49）提示，经组织学诊断的移植后BOOP的临床表现类似于特发性BOOP或其他疾病伴发的BOOP。GVHD与随之发生的BOOP存在关联，如BOOP患者多有累及皮肤的aGVHD或累及肠道和口腔的cGVHD。BOOP病因不明，肺损伤可能与免疫反应、非典型感染或不典型IPS有关。\n移植物抗宿主病危险因素 无关供者、多次妊娠的女性供者、老龄受者、移植物类型（CB发生率低于、PB发生率高于BM）、某些预处理方案均可增加aGVHD风险（表153- 9）。cGVHD风险因素与之相仿，只是移植物类型的预测效果不同。CB移植能降低aGVHD风险，但不影响cGVHD的发生；PB移植对aGVHD影响不大，但能增加cGVHD的发生。\n在众多危险因素中，HLA匹配程度是aGVHD最直接的相关因素。HLA相合移植受者aGVHD发生率约40%，无关供者或HLA 1个位点不合移植受者aGVHD发生率增高到60%～80%。与aGVHD不同，只有少数研究涉及MHC不合cGVHD实验动物模型。MHC不合移植aGVHD小鼠模型显示，将受鼠体内出现的供者反应性供者型T细胞过继转移至供型小鼠可导致严重“自身免疫性”大肠炎，而过继至受型小鼠则不发生。虽然这项研究提示MHC不合在急、慢性GVHD的诱发中均有关键作用，但是并不清楚对于cGVHD而言，哪些特定的MHC不合更为重要。\n表153-9　GVHD风险因素\n移植物抗宿主病预防和治疗 GVHD以及为之进行的免疫抑制治疗造成异基因HCT受者处于严重的免疫缺陷状态，机会性感染和疾病复发或第二肿瘤的发生风险增高。目前很难找到有效措施将“坏”的GVHD和“好”的移植物抗白血病（graft versus leukemia，GVL）效应区别处理，即难以制定一个最佳方案在防治GVHD的同时，又能促进免疫重建和维护正常免疫功能。\n移植物抗宿主病预防 钙调磷酸酶抑制剂如环孢素（cyclosporin，Cs）或他克莫司（FK506）联合短疗程甲氨蝶呤（MTX）是目前常用的预防方案。被认为是清髓性、HLA相合亲缘供者HCT获得GVHD/GVL理想平衡的标准方案。钙调磷酸酶抑制剂通过抑制IL- 2生成来干扰T细胞的活化和功能。主要毒性作用包括血压升高、肾毒性、神经毒性和胆汁淤积性肝炎。若无GVHD发生则在移植后180天或更迟的时候停用。一项前瞻性研究比较他克莫司+短疗程MTX或Cs+短疗程MTX在成人无关供者移植中的预防效果，发现tacrolimus组Ⅱ～Ⅳ度aGVHD发生率明显减低，而两组cGVHD发生率无差异，毒性作用发生率、白血病复发率和总生存率也无差异。另一项前瞻性研究比较Cs+mycophenolate mofetil（MMF）与Cs+MTX在清髓性移植中的预防效果，MMF组黏膜炎发生率极少、造血重建更快，而两组aGVHD发生率、100天生存率无差异，似乎MMF可以代替MTX，避免MTX相关不良事件如影响植入、黏膜炎和其他脏器毒性。\n对于高风险受者，如HLA不相合供者、无关供者或减低强度预处理移植的受者以及老龄受者，很难制定一个最佳方案，可以使用其他的一些免疫抑制剂如MMF、抗人胸腺细胞球蛋白（anti- thymocyte globulin，ATG）等（表153- 10）。\n表153-10　常用GVHD预防用药\nHLA不相合移植应该采取更强的免疫抑制措施，如体外TCD（如移植物CD34细胞分选）或受者体内TCD（如使用ATG或CD52单克隆抗体）。虽然这些措施可以减轻aGVHD，却增加了感染、肿瘤复发/发生的风险。HLA相合移植无需体外TCD，因为（虽然GVHD发生率明显下降）总生存、无病生存和移植相关死亡率并未得到改善；而3个抗原不合的移植，体外TCD很有必要，需要保证移植物中T细胞＜5×104/kg。T细胞抗体的体内TCD对于植入具有双重效应，一方面通过抑制宿主应答促进供者细胞植入，另一方面由于抗体的较长半衰期可能影响移植物中的成熟T细胞。\n急性移植物抗宿主病的治疗 GVHD的初始治疗反应是判断GVHD预后的最重要指标，因为二线治疗的总体疗效仍然令人沮丧。甲泼尼龙（methyl- prednisolone，MP）联合钙调磷酸酶抑制剂是aGVHD首选初治方案。MP每日剂量2mg/kg，连续7～14天，在获得完全治疗反应后缓慢减停。主要毒副作用包括血糖升高、骨质疏松和影响发育等，这是制约糖皮质激素长期使用的主要因素。\nBlazar认为糖皮质激素不适合用于治疗严重的aGVHD。而且一些前瞻性研究显示，更强的方案（较标准方案）不宜用于一线治疗。MP高剂量10mg/（kg•d）和低剂量2mg/（kg•d）之间、或者ATG治疗和MP平均剂量5mg/（kg•d）治疗之间的移植相关死亡率均无差异；此外，对低剂量糖皮质激素治疗早期有效者移植相关死亡率显著降低，而早期无效者应该选择其他免疫抑制治疗方案，因为增高剂量的MP治疗并不能阻止aGVHD的进展。\n初始给予“糖皮质激素+钙调磷酸酶”联合治疗时，当出现下列情况之一者被认为是治疗无效：①治疗3天病情仍进展；②治疗7天病情无改善；③治疗14天病情未完全缓解。这些患者接受二线挽救治疗。\nCs难治性aGVHD可以选择tacrolimus+MP。一项回顾性研究提示换用tacrolimus后有效率为10% （2/20）。糖皮质激素难治性aGVHD可以选择其他免疫抑制治疗（表153- 11）。单克隆抗体如IL- 2R抗体、TNF-α抗体、CD3抗体的Ⅰ～Ⅱ期临床试验有显示一定的疗效，但还需要随机对照试验加以证实。\n表153-11　糖皮质激素难治性aGVHD的二线治疗\n慢性移植物抗宿主病的治疗 cGVHD是造血干细胞移植后晚期最主要的并发症和致死原因。Cs联合泼尼松是治疗cGVHD的标准方案。泼尼松起始给予1～1. 5mg/（kg•d）至少2周，再根据治疗反应缓慢减停，服药通常持续1年。治疗相关并发症包括骨坏死、糖尿病、感染、高血压、体型改变、皮肤萎缩、白内障、骨质疏松症、情绪波动、睡眠障碍和儿童发育迟缓等。有研究提示外周血血小板＞100×109/L患者似乎可以单用泼尼松，因为Cs+泼尼松或泼尼松单用的免疫抑制治疗终止率、需要二线免疫抑制治疗率以及死亡率差异无显著性。\n标准方案疗效为50%～55%，其中25%～50%需经免疫抑制剂延长治疗达4年以上。然而cGVHD自身以及长期免疫抑制将增加并发症的发生率和死亡率。为此，一些研究致力于使用新药作为首选治疗或者用于治疗激素难治性或依赖性患者。\ncGVHD还没有一种标准的二线治疗方案。许多药物在临床试验中都能不同程度改善难治性cGVHD的治疗现状。MMF治疗激素难治性cGVHD的有效率在46%～75%，疗效与MMF血清谷浓度正相关。主要不良事件是机会性感染。针对B细胞的利妥昔单抗（rituximab）的Ⅰ/Ⅱ期临床试验显示，难治性cGVHD能取得70%的有效率，感染是仅有的不良事件。西罗莫司（sirolimus）的Ⅱ期临床试验显示，联合使用sirolimus、tacrolimus和糖皮质激素的有效率为63%。大剂量糖皮质激素临床试验报道严重难治性cGVHD（n = 61）给予甲泼尼龙10mg/ （kg•d）连续4天，主要及次要反应率分别为48% 和27%，治疗耐受性良好，没有严重不良事件。\n间充质干细胞（mesenchymal stem cell，MSC） MSC是免疫隔离性细胞，在特定条件下才具备免疫抑制效应。小鼠非清髓异基因移植实验提示，受者MSC能支持长期植入和供受者抗原的耐受；而供者MSC却与异基因供者骨髓排斥增加有关。虽然如此，MSC在治疗GVHD上却带来了希望。瑞典的研究组报道，8例激素难治性Ⅲ～Ⅳ度aGVHD平均输注MSC 1×106/kg，结果完全有效率为6/8。临床扩大试验正在欧洲实施。\n体外光疗（extracorporeal photopheresis，ECP） 采集受者5×109白细胞，经光活性化合物（8-methoxypsoralen）和紫外A光处理后，细胞发生凋亡，这些凋亡细胞回输后被受者APC俘获，从而触发某种耐受机制，移植前受者接受ECP处理可能有助于减少GVHD的发生。奥地利Ⅱ期临床试验提示，激素难治性aGVHD接受ECP治疗后，完全缓解率在皮肤、肠道、肝脏分别是82%、61%、61%，完全缓解者预期生存率（59%）显著高于其他患者（11%）。\n不相合的供者NK细胞 小鼠实验提示供者不相合NK细胞能杀伤宿主APC。Aversa等报道，移植时同时输注体外扩增的不相合供者NK细胞通过杀伤宿主APC减少GVHD的发生，同时通过杀伤白血病细胞发挥抗肿瘤效应。\n源文出处：https://www.tsu.tw/edu/12523.html\n",
    "pubDate": "2020-05-26T22:12:45+08:00"
  }, 
  {
    "objectID": 20200506,
    "url": "https://ichochy.com/posts/aml/20200506.html",
    "title": "慢性髓系白血病（CML）的临床分期",
    "summary": "慢性髓细胞白血病的分期是目前指导治疗的主要依据，也是预后判断的参考标准。CML可分为慢性期、加速期、急变期。\n",
    "content": "慢性髓细胞白血病的分期是目前指导治疗的主要依据，也是预后判断的参考标准。CML可分为慢性期、加速期、急变期。\n慢性期 临床表现：无症状或有低热、乏力、多汗、体重减轻等症状。 血象：白细胞总数增高，主要为中性晚幼和杆状核粒细胞，原始粒细胞（Ⅰ型+Ⅱ型）≤5%～10%，嗜酸性和嗜碱性粒细胞增多，可有少数有核红细胞。 骨髓：增生明显活跃或极度活跃，以粒系增生为主，中、晚幼粒和杆状核粒细胞增多，原始粒细胞（Ⅰ型+Ⅱ型）≤10%。 染色体：有Ph染色体。 CFU-GM培养：集落或集簇较正常明显增加。 加速期 具有下列之二者可考虑为本期。\n不明原因的发热、贫血、出血加重、骨骼疼痛。 脾脏进行性肿大。 不是因药物引起的血小板进行性降低或增高。 原粒细胞（Ⅰ型+Ⅱ型）外周血和（或）骨髓中10%～19%。 外周血中嗜碱性粒细胞＞20%。 骨髓中有明显的胶原纤维增生。 出现Ph染色体以外的染色体核型异常。 对传统的抗慢性髓细胞白血病药物治疗无效。 CFU-GM增殖和分化缺陷，集簇增多，集簇和集落的比值增高。 急变期 具有下列之一者可诊断为本期。\n外周血或骨髓中的原始粒细胞（Ⅰ型+Ⅱ型）或原淋+幼淋或原单+幼单≥20%。 外周血中原始粒+早幼粒细胞≥30%。 骨髓中原始粒+早幼粒细胞≥50%。 有髓外原始细胞浸润。 CFU-GM培养呈小簇生长或不生长。 源文出处：https://www.tsu.tw/edu/12025.html\n",
    "pubDate": "2020-05-06T22:12:45+08:00"
  }, 
  {
    "objectID": 20200504,
    "url": "https://ichochy.com/posts/aml/20200504.html",
    "title": "急性髓系白血病（AML）的治疗",
    "summary": "白血病患者骨髓中存在着正常的多克隆造血和白血病性单克隆造血两类细胞群，急性白血病治疗目的是杀灭白血病克隆恢复持久的正常多克隆造血。\n",
    "content": "白血病患者骨髓中存在着正常的多克隆造血和白血病性单克隆造血两类细胞群，急性白血病治疗目的是杀灭白血病克隆恢复持久的正常多克隆造血。\n白血病疗效的改善起自20世纪60年代末。随着肿瘤治疗新药的不断发现，支持治疗的加强（包括高效抗生素、成分输血和造血生长因子的应用）以及对白血病生物学特性的认识提高，人们逐步探索出一套以联合用药、大剂量、早期强化为主要策略的治疗方法。目前儿童和60岁以下成人AML的CR率均为60%～85%，5年DFS儿童可达50%，成人约30%～40%。\nAML的治疗应分阶段进行 第一阶段是诱导治疗，目的是杀灭白血病细胞，达到骨髓常规检查（骨髓涂片分类或活检）恢复正常（完全缓解，CR）； 第二阶段是缓解后治疗（包括巩固、强化、维持治疗和髓外白血病防治以及造血干细胞移植等），目的是清除残余的、常规检查方法不能发现的白血病细胞，以减少复发、争取长期生存。 缓解后治疗可以人为地分成几个阶段 第一阶段为巩固治疗，通常是重复使用原诱导方案1～2个疗程，亦可有所改变； 第二阶段为强化治疗，不仅用药剂量比诱导化疗更大，而且经常要在原诱导方案基础上增添或换用不同的药物，治疗一至数个疗程； 最后阶段是维持治疗，即应用剂量较小、不引起明显骨髓抑制的化疗，通常持续时间较长，但其价值尚有较大争议。随着中、大剂量阿糖胞苷的应用（一般早期应用），目前AML的缓解后治疗已不再是这个规律。 AML的缓解后治疗还包括干细胞移植的应用（包括自体干细胞移植和异基因干细胞移植）。 急性白血病患者开始治疗前应进行基本的评估，评估的内容有两个 ①确定疾病本身的特点，如既往毒性物质接触史、骨髓增生异常情况、细胞遗传学或分子学异常； ②患者本身的情况，如并发症等影响患者对化疗耐受的因素。评估的最终目的是决定个体化的治疗方案。 源文出处：https://www.tsu.tw/edu/11966.html\n",
    "pubDate": "2020-05-04T16:12:45+08:00"
  }, 
  {
    "objectID": 20200502,
    "url": "https://ichochy.com/posts/aml/20200502.html",
    "title": "骨髓增生异常综合征（MDS）的病程与预后",
    "summary": "骨髓增生异常综合征（MDS）的病程大致有以下三种主要演变模式 第一种模式，患者病情稳定，骨髓中原始细胞不增多或轻微增多，而不超过5%，随诊中迄未发生白血病转变，仅靠一般支持治疗可活存数年甚至十多年。\n",
    "content": "骨髓增生异常综合征（MDS）的病程大致有以下三种主要演变模式 第一种模式，患者病情稳定，骨髓中原始细胞不增多或轻微增多，而不超过5%，随诊中迄未发生白血病转变，仅靠一般支持治疗可活存数年甚至十多年。\n第二种模式，患者初期病情稳定，与第一种相似，骨髓中原始细胞不增多或轻度增多，但一般＜10%。经过一段时间以后，骨髓中原始细胞突然迅速增多，转变为AML。\n第三种模式，患者骨髓中原始细胞缓渐地进行性增多，临床病情随之进展，直至转变为AML。MDS发生白血病转变时几乎全是转变为急性髓系白血病（AML），以M1、M2、M4、M6亚型为多。也有报道说个别病例转变为急性淋巴细胞白血病或髓淋混合型白血病。\n对MDS诸多参数的预后意义进行分析的结果表明，最主要的预后因素是骨髓中原始细胞比例，比例愈高，预后愈差。染色体异常（尤其是-7/7q-、+8或复杂核型异常）也具有非常重要的意义。其他具有独立不良预后意义的因素尚有：外周血细胞显著减少，尤其是血小板减少和全血细胞减少，高龄（＞60岁），ALIP（+），巨核细胞异常（特别是有淋巴细胞样小巨核细胞），伴有骨髓纤维化，SCD （-）等。\n1997年国际MDS危险分析专题讨论会综合一些大系列的MDS预后资料，经过对各个重要预后因素的逐个分析，确定骨髓原始细胞比例、骨髓造血细胞染色体核型和外周血细胞减少系列数最具有预后意义。据此提出一个MDS国际预后积分系统（International Prognostic Scoring System，IPSS）将MDS分为低危、中危-Ⅰ、中危-Ⅱ和高危四个危度组（下表），对提示患者的生存期及白血病转变具有肯定意义（下表2）。IPSS提出后，很快得到一些作者的验证和认同，已取代其他的预后积分系统，而被广泛接受，现已将它视为提示预后和指导治疗的临床MDS分型方案。\n*预后良好核型：正常核型，-Y，5q-，20q-。预后不良核型：复杂核型异常（≥3种异常），7号染色体异常。预后中间核型：除上述两类以外的其他核型异常\n△血细胞减少的标准：血红蛋白＜100g/L；中性粒细胞绝对数＜1. 8×109/L；血小板数＜100×109/L\n2001年WHO造血组织肿瘤分类提出WHO分型后，但按照FAB分类制定的IPSS中骨髓原始细胞比例分组不能充分发挥其预后作用，因而2005年德国学者基于WHO分型标准提出了WPSS积分系统（下表）。该积分系统将MDS患者划分为极低危、低危、中危、高危和极高危组，属于这些危度分组的患者中位生存期分别为141、66、48、26、9个月，2年转白率分别为3%、6%、21%、38%、80%，5年转白率分别为3%、14%、33%、54%、84%。与IPSS预后积分系统相比，WPSS系统最大的优点是：IPSS是基于原发初治患者提出的，仅适合原发初治患者的预后判断，而WPSS适合于MDS患者病程演进过程中任一时点的预后判断，此外还适合继发性MDS患者的预后判断。\n*预后良好核型：正常核型，-Y，5q-，20q-。预后不良核型：复杂核型异常（≥3种异常），7号染色体异常。预后中间核型：除上述两类以外的其他核型异常\n目前采用WPSS作为我国MDS患者预后判断标准尚存在以下主要问题 ①染色体核型分析（常规染色体核型分析及FISH）在我国尚未普及，并且即使在进行了染色体检查的MDS患者中结果可供分析者（达到判断正常核型或克隆性异常核型所需分裂象）不足50%；另外WPSS中染色体核型的预后分组延用了IPSS中的分组，某些染色体单一异常被划分至中危组，但有研究证明并非如此（例如1号染色体长臂异常、8-三体预后较中危组差；12号染色体短臂缺失预后较中危组好）； ②红细胞输注的原则在我国由于经济条件限制或认识不足尚未得到规范实施，导致对输血依赖的判断欠客观。鉴于此，我们通过COX模型从MDS常规实验室检查指标中筛选出具有独立预后意义的参数：MCV、是否存在有淋巴样小巨核细胞（MEGly），据此提出了一个改良的WPSS积分系统（下表）。该系统简便、实用，可望提供适合我国基层单位目前使用的MDS预后判断标准。 *MEGly：淋巴样小巨核细胞\nMDS患者的死亡原因: 约半数是由于骨髓无效造血加重，外周血中血细胞进行性减少而招致的出血和感染， 30%～40%是由于发生白血病转变， 10%～20%是由于与MDS无直接关系的其他疾病。 源文出处：https://www.tsu.tw/edu/12013.html\n",
    "pubDate": "2020-05-02T14:18:45+08:00"
  }, 
  {
    "objectID": 20200430,
    "url": "https://ichochy.com/posts/aml/20200430.html",
    "title": "急性白血病的临床表现",
    "summary": "急性白血病的临床表现主要与白血病细胞无控性增殖引起骨髓正常造血受抑制和髓外组织器官浸润有关。某些独特的临床表现对急性白血病的诊断和分型有重要提示作用。\n",
    "content": "急性白血病的临床表现主要与白血病细胞无控性增殖引起骨髓正常造血受抑制和髓外组织器官浸润有关。某些独特的临床表现对急性白血病的诊断和分型有重要提示作用。\n起病 急性白血病一般起病急骤，但老年病人、低增生性急性白血病以及红白血病的患者起病可以相对较缓。急性起病的患者往往以感染、出血或骨痛等为首要表现，而起病慢时则以贫血为主，进行性加重。起病前多有疲乏、不适和食欲缺乏等类似“感冒”症状，或皮肤破损后难愈、感染或出血不止等。病前数周可有关节肿痛（大关节常见），少数骨痛剧烈，与髓腔内压力增高或白血病骨膜浸润有关；也可以抽搐、视物不清、牙龈肿胀或胸痛等为首发表现。Sweet综合征又称急性中性粒细胞皮肤血管炎，是急性白血病并发的皮肤副癌综合征，主要见于急性髓系白血病（AML）；患者的上、下肢末端皮肤出现红色软性斑块或结节，病理检查可见中、上真皮层以成熟中性粒细胞为主的密集炎性细胞浸润，不具有特异性，可能与白血病细胞释放生长因子和抗原刺激有关；皮肤改变可先于白血病数月出现，与白细胞多少无关，皮质激素治疗有效。\n发热和感染 急性白血病起病时多有感染，化疗后的骨髓抑制期感染也很常见。感染部位多样，以口腔、牙龈、鼻咽、肺、消化道、肛门及泌尿道等开放部位为主，可迅速发展为菌血症或败血症。白细胞减少、中性粒细胞功能异常、皮肤黏膜屏障功能减低、长期使用广谱抗生素导致菌群失调、自身免疫功能低下和应用免疫抑制剂增加机会感染等是引起感染的主要原因。以细菌感染最为多见，初期多为革兰阳性球菌，治疗期间则以革兰阴性杆菌（包括假单孢菌、大肠杆菌和奇异变形杆菌等）为主；真菌感染以白色念珠菌、曲霉菌和毛霉菌多见；还可见单纯或带状疱疹病毒、巨细胞病毒和EB病毒等感染。病情、感染部位和用药情况对判断病源微生物有一定提示作用。\n出血 出血是急性白血病常见的临床表现，主要为皮肤和黏膜出血，如皮肤出血点、瘀斑、鼻出血、牙龈渗血及口腔血疱等；也可见消化道、呼吸道、泌尿道、眼底甚至中枢神经系统出血，严重时威胁生命。AMLM3和M5型患者初诊时出血相对较重。血小板减少和功能异常、凝血异常（原发性纤维蛋白溶解、弥散性血管内凝血和肝功受损致凝血因子合成减少）和血管壁白血病细胞浸润等是引起出血的主要原因。\n贫血 少数急性白血病患者早期可无贫血，但随着疾病进展，必然发生红细胞和血红蛋白进行性减少。化疗期间也可有短暂贫血。表现为苍白、头晕、疲乏、耳鸣、心悸、胸闷、消化不良和多尿等表现，严重时可见双下肢水肿。贫血主要原因是由于白血病细胞浸润和化疗致骨髓红细胞造血抑制，失血、溶血、造血原料缺乏和EPO生成减少等也可加重贫血。\n肝、脾、淋巴结及胸腺肿大 肝、脾肿大见于70%以上的急性淋巴细胞白血病（ALL）和50%以上的AML，AML尤以M4和M5更为明显。原发性AL的肝脾肿大一般为轻、中度，脾肿大显著（超过肋下5cm）的患者需考虑继发于慢性粒细胞白血病（CML）。ALL常有淋巴结和胸腺肿大，胸腺肿大见于7%～10%的儿童和15%的成人患者，并可引起上腔静脉阻塞综合征；而AML的淋巴结肿大罕见，一般不发生胸腺白血病细胞浸润。\n皮肤损害 约10%的AML可出现皮肤局限性或弥漫性紫色突起硬结或斑块，以M4和M5较为多见，病理检查可见白血病细胞浸润；而ALL仅1%有皮肤浸润。也可见瘀斑、荨麻疹、瘙痒和多形性红斑等非特异性皮肤损害，还可有皮肤疖、痈、丹毒、蜂窝织炎或疱疹等皮肤感染性表现。\n中枢神经系统及神经根浸润 ALL的中枢神经系统浸润明显多于AML，儿童多于成人。约1/3的儿童ALL初诊时有中枢神经系统白血病（CNSL），以Burkitt淋巴瘤/白血病和T 系ALL多见。而仅5%～7%的AML在常规脑脊液检查时发现有CNSL，且以M4和M5多见。高白血病症和乳酸脱氢酶增高者易患CNSL。病程中如未经CNSL预防，约70%以上的ALL和30%～50%的AML可出现CNSL；轻者无症状，或仅轻微头痛，重者可出现头痛加剧、喷射性呕吐、视物模糊和精神改变，甚至发生脑疝、出现呼吸和心血管中枢抑制等。检眼镜检查可见视盘水肿和视盘苍白；腰穿检查可发现脑脊液压力增高，白细胞数和蛋白质增加，糖和氯化物可减低，还可能发现白血病细胞。\n外周血原始细胞超过50×109/L时易发生颅内白血病细胞淤滞，表现为弥漫性头痛和疲乏，可迅速发展为精神错乱或昏迷。主要是因为WBC增高增加血黏度，使颅内小血管出现白血病细胞淤滞和栓塞；白血病细胞也浸润动脉血管，可引起颅内出血。白血病细胞淤滞在白髓和软脑膜较明显。降低白细胞数和血黏度并不能有效改善症状。\nWBC＞50×109/L也易发生神经根鞘的白血病细胞浸润，可致脑神经根麻痹，以第5、7对脑神经损害较多见。主要见于ALL，而AML罕见。患者可突然面肌无力，迅速面瘫。视神经浸润表现为视盘水肿、眼痛和视物模糊，或突然单眼盲。视网膜浸润降低视力。脑神经浸润可发生于无明显CNSL表现者，脑脊液可找不到白血病细胞，但MRI或CT可见神经鞘增厚，提示白血病细胞浸润；及时局部放疗以及降低WBC可避免脑神经功能永久性丧失。\n呼吸系统 呼吸系统改变的主要原因是肺感染。约5%的患者初诊时因WBC增高可出现肺内白血病细胞淤滞。此时肺内微血管栓塞、麻痹和体液渗漏，患者咳嗽、突然气短和进行性呼吸窘迫，可有发热，双肺广泛水泡音，胸部X线片可见弥漫性肺间质渗漏和胸腔积液，严重时出现呼吸功能衰竭。肺白血病细胞淤滞在单核细胞白血病和M3v较为多见。肺白血病细胞淤滞的表现也可类似于肺细菌或真菌感染。也可见弥漫性或局限性（肺段或叶）肺出血，表现为突然气短，可有咯血，胸部X线片可明确出血的部位。\n骨和关节疼痛 急性白血病体检常可发现胸骨压痛。骨和关节疼痛在ALL多于AML，尤以儿童ALL多见，甚至成为初诊时的主要表现。骨和关节疼痛与白血病细胞大量增殖致骨髓腔内压力增高和白血病侵蚀骨实质、骨膜和关节腔有关。\n消化道 急性白血病常因感染、白血病细胞侵蚀和化疗等损伤胃肠道，出现口咽部黏膜溃烂、吞咽困难、恶心、呕吐、腹痛、腹泻或出血等。食管念珠菌病可致胸骨下疼痛、“烧心”感和吞咽困难。长期应用广谱抗生素和化疗引起的黏膜损伤增加了胃肠道真菌的感染机会。少数患者食道和小肠内可形成绿色瘤或粒细胞肉瘤，引起梗阻。国外报道约10%的患者强化治疗期间出现阑尾炎和急性坏死性结肠炎，表现为突发性腹痛、发热、腹胀、腹肌紧张和肠鸣音减低，腹透常见不完全性小肠梗阻或可疑的右下腹包块以及积气，CT有助于诊断；并发阑尾炎的患者多数预后较差；治疗包括肠道休息、应用针对肠道厌氧菌、真菌的广谱抗生素及静脉营养等，少数需手术治疗，术式常采用部分结肠切除术。肛周感染较常见，最初表现为排便时痛，肛周发硬、有触痛，但无明显红肿，可发展为肛周脓肿。肛周感染应早发现、早处理。粒细胞缺乏期患者一般应避免做肛门指诊或直肠镜检；便秘者应注意及时通便，防止黏膜撕裂而继发感染。\n口腔、眼部及耳鼻咽喉 白血病细胞浸润可致牙龈增生和肿胀，多见于分化较好的单核细胞白血病。口腔溃疡与感染、浸润和化疗损伤黏膜有关。舌或软、硬腭等处是口腔念珠菌感染好发部位。鼻窦炎和中耳炎偶见。视盘和视神经浸润可致突然失明，也有脉络丛和视网膜等其他眼组织浸润的报道。绿色瘤可见于眼的任何部位。检眼镜检查发现视盘水肿和视盘苍白时应考虑白血病眼部浸润，高度提示脑膜白血病。\n乳腺 少数患者在疾病初期或白血病复发时出现乳腺局限性或弥漫性增生，应与乳腺癌或乳腺炎相鉴别。\n髓细胞肉瘤 髓细胞肉瘤包括粒细胞肉瘤和单核细胞肉瘤两种，是原始细胞髓外浸润的表现。可为单个皮下包块，以颅骨、眼眶或硬脊膜等部位多见，也可见于乳腺、肝、肾或肌肉等处，易与原发性肿瘤或转移瘤混淆。粒细胞肉瘤内原始细胞含较多的髓过氧化物酶颗粒，使瘤体切片在空气中易被氧化而呈绿色，又称绿色瘤。粒细胞肉瘤易见于t（8；21）/AML、inv （16）/AML和白细胞显著增多的患者。t（8；21）/ AML年龄越小粒细胞肉瘤越易见到。\n心血管 心功能改变通常是肺功能障碍、代谢和电解质紊乱的结果。白血病细胞浸润心脏和大血管较为罕见。原始单核细胞可浸润心传导系统、心包、心肌和动脉血管壁，动脉血管壁浸润可继发动脉瘤。化疗毒性是心功能改变的主要原因，蒽环类药物可致急、慢性心脏毒性，且与其他药物有协同作用。应在开始化疗前评估心脏功能及左、右室射血分数。\n泌尿生殖器 因白血病细胞浸润可致肾肿大、蛋白尿、血尿和少尿等。也可因高尿酸血症导致尿酸性肾病、肾结石、甚至急性肾衰竭。极少数情况下白血病细胞浸润前列腺可导致尿路梗阻。可并发泌尿系统感染。应用大剂量环磷酰胺治疗时因环磷酰胺代谢产物丙烯醛损伤膀胱黏膜，可致出血性膀胱炎。单、双侧睾丸浸润多见于ALL，尤其是儿童和T系ALL，且经常是复发的最早表现。极少数患者阴茎异常勃起，与海绵体白血病细胞浸润和栓塞有关。女性亦可有子宫和卵巢浸润。\n电解质与代谢紊乱 急性白血病的代谢和电解质紊乱较为常见。大量白血病细胞破坏可致高尿酸血症，大量尿酸盐结晶可损害肾小管和输尿管，引起急性肾衰竭，应及时给予水化、碱化和别嘌呤醇治疗。发生肾衰竭也与白血病细胞浸润肾皮质、髓质和肾间质有关。一般AML的肾功能损害较ALL少见。\n白血病细胞迅速杀灭可致高钾血症，但临床以低钾血症更为多见，且主要见于M4和M5。单核细胞白血病细胞的溶菌酶浓度较高，大量溶菌酶释放可损伤近端肾小管，使肾钾丢失；白血病细胞合成的肾素样因子及抗生素、化疗药物、腹泻、呕吐和低镁血症等也与低钾血症形成有关。高钙血症可由骨质浸润、破骨细胞活化和继发性溶骨引起，也可能与白血病细胞释放甲状旁腺素或甲状旁腺素样物质有关。低钙血症时同出现手足抽搐和致命的心律失常，可能与白血病细胞释放加快骨形成的因子或肾损害后血、尿中磷酸盐增多有关。\n肿瘤溶解综合征表现为快速进展的高尿酸血症、高钾血症、高磷酸盐血症和低钙血症，引起急性肾损害、致死性心律失常和手足抽搐、肌痉挛等。肿瘤溶解综合征见于原始细胞极高或迅速增高的患者，需在化疗前及时纠正代谢和电解质紊乱，早期给予别嘌呤醇和水化治疗，必要时可予血液透析。\n急性白血病可发生乳酸酸中毒，机制不明，可能与白血病细胞无氧糖原酵解有关。乳酸酸中毒主要见于极高原始细胞数和髓外浸润、白血病细胞淤滞的患者。外周血有大量原始细胞时可出现假性低血糖和动脉血氧饱和度降低，可能与白血病细胞代谢消耗氧和血糖有关。\n源文出处：https://www.tsu.tw/edu/11940.html\n",
    "pubDate": "2020-04-30T16:12:45+08:00"
  }, 
  {
    "objectID": 20200425,
    "url": "https://ichochy.com/posts/aml/20200425.html",
    "title": "慢性粒单核细胞白血病（CMML）",
    "summary": "慢性粒单核细胞白血病（chronic myelomonocytic leukemia，CMML）是一种骨髓造血干细胞的克隆性疾病\n",
    "content": "慢性粒单核细胞白血病（chronic myelomonocytic leukemia，CMML）是一种骨髓造血干细胞的克隆性疾病\n其特征为：\n外周血中单核细胞持续性增多＞1×109/L； 无Ph染色体或BCR-ABL融合基因； 无PDGFRα或PDGFRβ重排（在有嗜酸性粒细胞增多的病例中要特别加以排除）； 外周血和骨髓中原始细胞＜20%（幼单核细胞也视为原始细胞）； 一系或多系髓系细胞存在发育异常。 如无肯定的发育异常，但符合CMML的其他条件，且骨髓细胞有获得性克隆性细胞遗传学或分子学异常，或单核细胞增多持续至少3个月并能除外引起单核细胞增多的其他原因，如恶性肿瘤、感染或炎症，仍可诊断为CMML。CMML的临床血液学和形态学特征是异质性的，其表现变动于从以骨髓增生异常为主到以骨髓增殖为主的病谱之间。CMML中JAK2V617F突变不常见。\n流行病学：本病主要发生于老龄人，60岁以上人群中年发病率约为3/10 000。中位发病年龄为65～75岁，男女之比为1. 5～3：1。\n病因与发病机制 病因与发病机制未明。职业性和环境致癌因素、电离辐射和细胞毒药物在某些病例可能是致病因素。有迹象表明一些细胞因子如TNF、GM-CSF、IL-3、IL-4等可能参与了粒单核系的过度增殖。RAS基因突变在初诊和病程中可达40%。克隆性染色体异常可见于20%～40%的CMML患者，但均无特异性。\n临床和血液学表现 CMML外周血象的标志性特征是单核细胞增多＞1. 0×109/L，比例超过白细胞的10%，一般为成熟单核细胞，形态无明显异常。有时可有原始细胞或幼单核细胞，但数量不会很多。约50%的患者白细胞正常或轻度减少，伴有中性粒细胞减少，且其他血液学特点与MDS基本相同。另外约50%的患者白细胞增高，伴有中性粒细胞增多，也可有不成熟粒细胞，但一般＜10%，特别是原始细胞很少超过5%，有些病例嗜酸性粒细胞增多显著。如符合CMML的诊断标准，但外周血嗜酸性粒细胞≥1. 5× 109/L，可诊断为CMML伴嗜酸性粒细胞增多。这类患者可有嗜酸性粒细胞脱颗粒相关的并发症，必须做相应的基因检测以除外髓系肿瘤伴嗜酸性粒细胞增多并有PDGFRα或PDGFRβ基因异常的患者。\n75%以上的病例骨髓有核细胞增多。骨髓活检标本中粒系细胞增殖常是最显著的表现，但也可见有红系细胞增多。单核细胞系增殖必然存在，但在骨髓活检或骨髓穿刺液涂片中可能难以认出。当疑诊为CMML时，应使用有助于确认单核细胞和不成熟单核细胞的细胞化学和免疫组化方法。大多数患者有粒系和巨核系发育异常，可看到小巨核细胞和（或）核分叶异常的巨核细胞。约30%的患者骨髓中可见轻至中度网状纤维增加。20%的患者骨髓活检可见到成熟浆细胞样树突状细胞（浆细胞样单核细胞）结节。这些细胞核圆形，染色质细致分散，核仁不明显，极少量嗜酸性胞质，胞膜常清楚。浸润的细胞呈紧密聚集的外观，常见呈星空样分布的组织细胞中的凋亡小体。近来一项研究证明这些浆细胞样树突状细胞是克隆性、肿瘤性的，与合并的髓系肿瘤密切相关。\nCMML患者可有肝脾肿大，主要见于白细胞增高者，淋巴结肿大少见。但一旦出现淋巴结肿大，可能是向更为急性期转化的信号，淋巴结可有原粒细胞弥漫性浸润。\n其他实验室检查 CMML患者外周血和骨髓细胞通常表达粒、单核细胞抗原，如CD33与CD13，以及不同程度地表达CD14、CD68、CD64。组织切片免疫组化确认单核细胞相对不够敏感。最可靠的标志为CD68R与CD163。溶菌酶与CAE染色合用也有助于确认单核细胞，粒系细胞二者均阳性，而单核细胞为溶菌酶阳性，CAE阴性。\n20%～40%的CMML病例有克隆性细胞遗传学异常，但都无特异性。最常见重现性异常包括+8，-7/del（7q）及12p结构性异常。诊断时或病程当中多达40%的患者有RAS基因点突变。目前，有孤立性17q等臂染色体的造血组织肿瘤如何分类尚未确定，尽管部分患者符合CMML的诊断标准，其他患者可能更适合归入MDS/MPN，不能分类。11q23异常在CMML中不常见，如有，则提示AML的诊断。\n相似于CMML的病例可表达p190bcr-abl1，这种应分类为慢性粒细胞白血病（CML）。因此，若细胞遗传学分析未检出t（9；22）（q34；q11），仅用PCR方法检测p210以除外CML是不够的。\n诊断 2008年WHO分类中CMML诊断标准如下：\n外周血单核细胞持续性＞1×109/L。 无Ph染色体或BCR-ABL融合基因。 无PDGFRα或PDGFRβ重排（在有嗜酸性粒细胞增多的病例中要特别加以排除）。 外周血或骨髓中原始细胞（包括原始粒细胞和原、幼单核细胞）＜20%。 髓系细胞1系或多系发育异常，如无骨髓细胞发育异常或极微 但其他条件符合且有下述情况者，仍可诊断为CMML：\n1. 造血细胞有获得性克隆性细胞遗传学或分子基因异常，或 2. 单核细胞增多至少已持续3个月，而且 3. 除外所有已知能引起单核细胞增多的其他原因。 CMML还应进一步分为以下两个亚型：\nCMML-1：原始细胞数（包括幼单核细胞）外周血中＜5%，骨髓中＜10%。\nCMML-2：原始细胞数（包括幼单核细胞）外周血中占5%～19%，或骨髓中占10%～19%，如见到Auer小体，则不论原始细胞（包括幼单核细胞）占多少均诊断为CMML-2。\n如外周血中嗜酸性粒细胞＞1. 5×109/L，则相应诊断为CMML-1或CMML-2伴有嗜酸性粒细胞增多。\n预后 CMML患者的生存时间各报告中相差甚大，短者仅1个月，长者可100个月，但中位生存时间多为20～40个月。15%～30%的患者进展为急性白血病。外周血和骨髓中原始细胞百分比是最重要的提示预后不良的因素。\n治疗 到目前为止，CMML尚无满意治疗方法。小剂量化疗和大剂量强烈化疗均尚不能证实有肯定的疗效，特别是强烈化疗在老年患者应当慎用。异基因造血干细胞移植（Allo-HSCT）仍是唯一有可能治愈CMML的手段，因此，年纪较轻且有合适供者的CMML患者，应首先考虑Allo-HSCT。非清髓性Allo-HSCT可选择性地实施于老年和不能耐受强烈预处理方案的患者。红细胞生成素在某些患者可减少输血需求，改善贫血。G-CSF/GM-CSF可一时性提高外周血中性粒细胞数量。单药或联合化疗适用于中危或高危的CMML患者，完全缓解率为10%（单药）～50%（AML方案联合化疗）。目前，去甲基化药物5-氮杂胞苷和地西他滨已应用于临床。靶向治疗药物如法尼基转移酶抑制剂R115777，肽模拟剂E21R，以及DT388-GM-CSF等，均尚处于临床试验中。\n源文出处：https://www.tsu.tw/edu/12015.html\n",
    "pubDate": "2020-04-25T14:16:45+08:00"
  }, 
  {
    "objectID": 20200422,
    "url": "https://ichochy.com/posts/aml/20200422.html",
    "title": "白血病的分类：髓系肿瘤和淋系肿瘤",
    "summary": "真正的白血病分型是始于1887年德国人Ehrlich发明细胞染色方法之后。基于对白血病细胞形态和疾病进程的观察，不断发现新的白血病类型。\n",
    "content": "真正的白血病分型是始于1887年德国人Ehrlich发明细胞染色方法之后。基于对白血病细胞形态和疾病进程的观察，不断发现新的白血病类型。\n1900年以后在Naegeli描述了原始粒细胞的基础上明确了急性粒细胞白血病的诊断。1913年Reschad和Schilling两位学者报道了单核细胞白血病。1917年Di Guglielmo区分出红白血病。1938年又报道了粒-单细胞白血病。1957年Hillested发现急性早幼粒细胞白血病。1959年中国医学科学院血液学研究所通过细胞形态首次确认了一种新的白血病类型——亚急性粒细胞白血病；患者的病程介于急性和慢性白血病之间，骨髓中幼粒细胞比例明显增多，且以异常中性中幼粒细胞为主；后来按FAB分型的基本原则更名为AML-M2b型，继而又发现这类患者多有t（8；21），并阐明这类白血病致病与AML1-ETO募集组蛋白脱乙酰基转移酶（HDAC），进而通过染色体重塑机制影响造血特异基因的表达有关。1967年WHO将白血病分为急性淋巴细胞白血病、慢性淋巴细胞白血病、急性粒细胞白血病、急性单核细胞白血病和慢性粒细胞白血病等几类。后来英国和法国的几位学者又各自提出了不同的分型方法。这使白血病分型显得较为混乱。1976年，法-英-美3国7位学者共同研究了大量的白血病患者骨髓和外周血涂片，结合细胞化学染色，在广泛征求意见的基础上，提出了白血病的FAB诊断分型标准，后经多次修订补充，成为国际通用的白血病诊断分型语言。\nFAB分型标准将白血病分为急性淋巴细胞白血病、急性髓系白血病、慢性淋巴细胞白血病和慢性粒细胞白血病四类。其中急性淋巴细胞白血病又分为L1、L2和L3三种亚型；急性髓系白血病分为M0～M7型；慢性淋巴细胞白血病分为慢性B和T细胞白血病，共14种亚型，包括B幼淋巴细胞白血病、毛细胞白血病和成人T细胞白血病/淋巴瘤等临床罕见类型。\n随着研究的深入，发现白血病具有异常的细胞膜和细胞质分子免疫标记，许多白血病类型还有特征性的染色体和分子遗传异常。将细胞免疫表型和细胞遗传学特征与细胞形态诊断结合起来，无疑会使白血病的诊断分型更加客观、科学、精确，更具可重复性。为此，1985～1986年FAB协作组专家会同免疫学家和遗传学家，共同制订了白血病新的形态学-免疫学-细胞遗传学（MIC）分型标准；后来又结合了分子遗传特征，形成了MICM诊断分型标准。经过多年的临床实践，认识到一种恶性疾病实体的定义不能仅依靠细胞形态、免疫表型和遗传特征，而应综合现在已知的所有疾病要素。1997年WHO召集了130余位世界著名的临床血液学家和病理学家，借鉴淋巴瘤的REAL分型原则，综合病因、继往病史、细胞形态、免疫表型、遗传学特征及临床、治疗和预后特点，于2001年提出了包括白血病在内的造血和淋巴组织肿瘤新的诊断分型标准；经过多年实践，结合新的研究进展，2008年WHO对该标准又作了补充修订。总的来说，WHO诊断分型标准按细胞类型将造血和淋巴组织肿瘤分为三大类：髓系、淋系和组织细胞/树突细胞肿瘤。\n髓系肿瘤包括：\n骨髓增殖性肿瘤（如CML）； 伴嗜酸性粒细胞增多和PDGFRA、PDGFRB或FGFR1异常的髓系和淋巴肿瘤； 骨髓增生异常/骨髓增殖性肿瘤（如CMML）； 骨髓增生异常综合征； 急性髓系白血病及相关前体肿瘤； 系列模糊的急性白血病。淋系肿瘤包括： 淋系肿瘤包括：\n前体淋巴肿瘤（如ALL）； 成熟B细胞肿瘤（如CLL、Burkitt白血病）； 成熟T和NK细胞肿瘤（如成人T细胞白血病）； 霍奇金淋巴瘤； 免疫缺陷相关的淋巴增殖性疾病。 每一种类疾病又分若干亚型。WHO的诊断分型标准是开放性的，随着更多的临床和实验资料积累，相信将来有进一步的补充、完善。\n源文出处：https://www.tsu.tw/edu/11899.html\n",
    "pubDate": "2020-04-22T16:18:45+08:00"
  }, 
  {
    "objectID": 20200222,
    "url": "https://ichochy.com/posts/software/20200222.html",
    "title": "mysql 使用 source/mysqldump 命令导入/导出文件信息",
    "summary": "要导入/导出数据库信息，使用 mysql 的source命令可以方便快速的处理\n",
    "content": "要导入/导出数据库信息，使用 mysql 的source命令可以方便快速的处理\n以MAC为例：\n一、mysqldump命令导出SQL文件 /usr/local/mysql/bin/mysqldump -u root -p test \u0026gt; ~/test.sql 输入密码导出SQL文件，其中test为数据库名称\n二、source命令导入SQL文件 登录数据库\n/usr/local/mysql/bin/mysql -u root -p 输入密码登录数据库\n导入SQL文件\nshow databases; //查看数据库 create database test; //创建数据库 test use test; //使用数据库 test source ~/test.sql; //快速导入超大SQL文件 通过source命令可以快速导入超大SQL文件\n",
    "pubDate": "2020-02-22T22:16:45+08:00"
  }, 
  {
    "objectID": 20191107,
    "url": "https://ichochy.com/posts/elasticsearch/20191107.html",
    "title": "Docker 中运行 ElasticSearch 和 Kibana",
    "summary": "ElasticSearch 是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口；Kibana 是一个开源的分析和可视化平台，可以搜索，查看、分析存储在Elasticsearch索引中的数据\n",
    "content": "ElasticSearch 是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口；Kibana 是一个开源的分析和可视化平台，可以搜索，查看、分析存储在Elasticsearch索引中的数据\n一、下载镜像(image) 搜索镜像(image)\ndocker search elasticsearch docker search kibana 获取镜像(image)\ndocker pull elasticsearch:7.4.1 #镜像名称:Tag docker pull kibana:7.4.1 #镜像名称:Tag 二、创建 docker-compose.yml 构建 es.yml\nversion: \u0026#34;3.2\u0026#34; services: elasticsearch: container_name: elasticsearch #容器名称 image: elasticsearch:7.4.1 #镜像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana #容器名称 image: kibana:7.4.1 #镜像(image) restart: always #重启方式 environment: ELASTICSEARCH_URL: \u0026#34;127.0.0.1:9200\u0026#34; #环境变量：elasticsearch 请求地址 I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 三、运行 命令启动\ndocker-compose -f es.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 启动完成后直接访问：http://127.0.0.1:5601，进入 Kibana\n*注：*注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败\n# 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here ",
    "pubDate": "2019-11-07T13:24:45+08:00"
  }, 
  {
    "objectID": 20191106,
    "url": "https://ichochy.com/posts/elasticsearch/20191106.html",
    "title": "初识 Docker",
    "summary": "Docker 是个容器应用，可以跨平台安装，并使容器与容器间相“独立”运行；就好比每个容器都是一个虚拟机，而 Docker 成为了个云计算机。构建的容器好比机算机系统，可以在 Docker 中直接启动运行，而无需额外的配置系统环境。\n",
    "content": "Docker 是个容器应用，可以跨平台安装，并使容器与容器间相“独立”运行；就好比每个容器都是一个虚拟机，而 Docker 成为了个云计算机。构建的容器好比机算机系统，可以在 Docker 中直接启动运行，而无需额外的配置系统环境。\n一、安装 Docker Docker 分为企业版和社区版，还有桌面版，可以在 Docker Hub 去下载合适的版本 桌面版就是一个应用，直接安装就可以，很便捷，其它版本官方也有详细的说明\n二、使用 Docker 1、获取容器 容器(container)是通过镜像(image)构建的，在 Docker Hub 中获取镜像(image)\n搜索\ndocker search nginx //在 Docker Hub 搜索镜像(image) 获取\ndocker pull nginx //在 Docker Hub 获取镜像(image) 2、运行容器 运行\ndocker run --name ichochy-nginx -d -p 80:80 nginx docker run //在新容器(container)中运行命令 --name string //分配一个容器(container)名称 -d, --detach //后台运行容器(container)，打印容器(container)ID -p, --publish list //端口映射，宿主机端口:容器(container)端口 3、操作容器 执行 shell\ndocker exec -it 74282d01a2fc bash //在运行容器(container)中运行命令 复制文件\ndocker cp 74282d01a2fc:/usr/share/nginx/html/index.html ~/ichochy.html 查看镜像(image)\ndocker image ls -a //查看所有 -a 查看容器(container)\ndocker container ls -a //查看所有 -a 查看容器(container)\ndocker start/stop/restart 74282d01a2fc //启动/停止/重启 容器(container) ",
    "pubDate": "2019-11-06T15:24:45+08:00"
  }, 
  {
    "objectID": 20191028,
    "url": "https://ichochy.com/posts/shell/20191028.html",
    "title": "Mac 无密码 SSH 登录服务器",
    "summary": "Mac 无密码 SSH 登录服务器，只需要简单三步，不再需要记住账号密码，快速进入服务器\n",
    "content": "Mac 无密码 SSH 登录服务器，只需要简单三步，不再需要记住账号密码，快速进入服务器\n第一步，生成密钥对 在当前用户下创建.ssh目录\nmkdir ~/.ssh 使用命令ssh-keygen生成密钥对,会在~/.ssh目录下生成公/私钥\nid_rsa //私钥 id_rsa.pub //公钥 第二步，上传公钥 使用命令ssh-copy-id user@hostname\nssh-copy-id admin@192.168.1.55 输入密码，操作成功\n查看服务器～/.ssh/authorized_keys，可以看到本地的公钥已经写入到authorized_keys文件中\n运行命令ssh user@hostname就可以直接无密码 SSH 登录服务器\n第三步，config 配置 在当前用户.ssh目录下创建config文件\ntouch ~/.ssh/config 通过vim编辑config，添加服务器配置信息\nHost iChochy //服务器别名 Hostname 192.168.1.55 //服务器地址 User admin //服务器用户 Identityfile ~/.ssh/id_rsa //服务器公钥对应的本地私钥 直接运行命令ssh iChochy就可以直接无密码 SSH 登录服务器\n",
    "pubDate": "2019-10-28T15:10:45+08:00"
  }, 
  {
    "objectID": 20191018,
    "url": "https://ichochy.com/posts/spring/20191018.html",
    "title": "Spring Cloud Alibaba Nacos Discovery 实战",
    "summary": "Nacos 作为服务注册中心，可以快速简单的将服务自动注册到 Nacos 服务端，并且能够动态无感知的刷新某个服务实例的服务列表，为分布式系统提供服务注册与发现功能\n",
    "content": "Nacos 作为服务注册中心，可以快速简单的将服务自动注册到 Nacos 服务端，并且能够动态无感知的刷新某个服务实例的服务列表，为分布式系统提供服务注册与发现功能\n一、创建服务 1、创建项目 pom.xml中添加nacos支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; bootstrap.properties加入nacos参数\nserver.port=8080 spring.application.name=service-provider spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #如果不想 Nacos 注册和发现当前服务，可设置为false spring.cloud.nacos.discovery=true spring.cloud.nacos.discovery.server-addr：为nacos的服务器地址:端口，80端口不可省略\n通过 Spring Cloud 原生注解 @EnableDiscoveryClient 开启服务注册发现功能：\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } } 2、编写服务 package com.ichochy.nacos.service; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/service\u0026#34;) public class EchoService { @RequestMapping(\u0026#34;echo/{name}\u0026#34;) public String echo(@PathVariable String name){ System.out.println(\u0026#34;##############\u0026#34;); return \u0026#34;Hello Nacos Discovery \u0026#34;+name; } } 3、查看服务 启动项目，可以在Nacos的服务列表中查看到当前服务\n访问地址：http://127.0.0.1:8080/service/echo/ichochy\n二、调用服务 1、创建项目 创建项目和服务方项目相同，server.port和spring.application.name设置为不同\n构建RestTemplate，@LoadBalanced开启负载均衡\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } @Bean @LoadBalanced RestTemplate restTemplate(){ return new RestTemplate(); } } 2、编写远程服务调用 package com.ichochy.nacos.controller; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/result\u0026#34;) public class ResultController { @Autowired private RestTemplate restTemplate; @RequestMapping(\u0026#34;restTemplate/{name}\u0026#34;) public String restTemplate(@PathVariable String name){ String url = \u0026#34;http://service-provider/service/echo/\u0026#34;; return restTemplate.getForObject(url+name,String.class); } } 注：通过RestTemplate远程调用服务，远程调用地址为服务方项目名+请求路径\nspring.application.name=service-provider\n3、远程调用 启动项目，测试服务调用\n访问地址：http://127.0.0.1:8080/result/restTemplate/ichochy\n三、优化调用，使用FeignClient pom.xml中添加FeignClient支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1、Spring Cloud 原生注解 通过 @EnableFeignClients 开启调用\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } } 2、编写远程服务调用接口 package com.ichochy.nacos.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; @FeignClient(value = \u0026#34;service-provider\u0026#34;) public interface ServiceInterface { @RequestMapping(\u0026#34;/service/echo/{name}\u0026#34;) public String echo(@PathVariable String name); } 3、远程调用服务 package com.ichochy.nacos.controller; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/result\u0026#34;) public class ResultController { @Autowired private ServiceInterface serviceInterface; @RequestMapping(\u0026#34;feignClient/{name}\u0026#34;) public String feignClient(@PathVariable String name){ return serviceInterface.echo(name); } } 访问地址：http://127.0.0.1:8080/result/feignClient/ichochy\n",
    "pubDate": "2019-10-18T16:35:45+08:00"
  }, 
  {
    "objectID": 20191017,
    "url": "https://ichochy.com/posts/spring/20191017.html",
    "title": "Spring Cloud Alibaba Nacos Config 实战",
    "summary": "Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置\n",
    "content": "Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置\n一、安装 Nacos 1、下载 Nacos 最新稳定版下载：https://github.com/alibaba/nacos/releases\n2、启动 Nacos 启动 Nacos (单机模式)\nsh startup.sh -m standalone 关闭 Nacos\nsh shutdown.sh 二、配置 Nacos 1、打开 Nacos 默认地址：http://127.0.0.1:8848/nacos/#/login\n默认账号：账号密码相同，都为nacos\n2、添加配置 配置数据：\nData ID: nacos-dev.properties Group : DEFAULT_GROUP 配置格式: Properties 配置内容： useLocalCache=true Data ID 的格式说明：\n${prefix}-${spring.profile.active}.${file-extension} prefix:\n默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置\nspring.profile.active:\n即为当前环境对应的 profile， 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}\nfile-exetension:\n为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型\n实例：\nspring.application.name=nacos spring.profiles.active=dev spring.cloud.nacos.config.file-extension=properties Data ID 为：nacos-dev.properties\n三、使用 Nacos pom.xml中添加nacos支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; bootstrap.properties加入nacos参数\nserver.port=8080 spring.profiles.active=dev spring.application.name=nacos spring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.cloud.nacos.config.file-extension=properties spring.cloud.nacos.config.server-addr：为nacos的服务器地址:端口，80端口不可省略\nspring.cloud.nacos.config.file-extension：为nacos的支持的文件类型，如：yaml和properties\n四、调用 Nacos @Value SpEL调用\n@RefreshScope打开自动刷新\npackage com.ichochy.nacos.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;/config\u0026#34;) @RefreshScope public class ConfigController { @Value(\u0026#34;${useLocalCache:false}\u0026#34;) private boolean useLocalCache; @RequestMapping(\u0026#34;get\u0026#34;) public boolean getConfig(){ System.out.println(useLocalCache); return useLocalCache; } } ",
    "pubDate": "2019-10-17T14:10:45+08:00"
  }, 
  {
    "objectID": 20191016,
    "url": "https://ichochy.com/posts/shell/20191016.html",
    "title": "Shell 脚本重启项目",
    "summary": "每次发打包好项目后都需要手动重启项目，写个Shell脚本一键重启项目\n",
    "content": "每次发打包好项目后都需要手动重启项目，写个Shell脚本一键重启项目\nShell 脚本 #!/bin/bash while getopts \u0026#34;n:p:\u0026#34; arg do case $arg in n) echo \u0026#34;NAME\u0026#39;s arg:$OPTARG\u0026#34; NAME=$OPTARG ;; p) echo \u0026#34;PORT\u0026#39;s arg:$OPTARG\u0026#34; PORT=$OPTARG ;; esac done PROCESS=echo | lsof -i TCP:$PORT | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; if [ $PROCESS ]; then kill -9 $PROCESS echo kill $NAME:$PROCESS, restart fi cd jenkins cp jar/.tmp/$NAME-0.0.1-SNAPSHOT.jar jar/ nohup java -jar -Xms128m -Xmx256m jar/$NAME-0.0.1-SNAPSHOT.jar --eureka.url=\u0026#34;127.0.0.1:9100/eureka/\u0026#34; --profile=\u0026#34;dev\u0026#34; \u0026gt;logs/$NAME.log 2\u0026gt;\u0026amp;1 \u0026amp; echo $NAME starting Shell 说明 lsof：通过端口获取进程\ngetopts：实现Shell脚本多参数\nnohup：后台启动项目\nShell 运行 sh -n project -p 8080 ",
    "pubDate": "2019-10-16T16:10:45+08:00"
  }, 
  {
    "objectID": 20191012,
    "url": "https://ichochy.com/posts/spring/20191012.html",
    "title": "认识 Spring Cloud Alibaba",
    "summary": "个人理解 Spring Cloud Alibaba 就是 Spring Cloud 的微服务规范的一种实现，外加一些阿里云的商业组件\n",
    "content": "个人理解 Spring Cloud Alibaba 就是 Spring Cloud 的微服务规范的一种实现，外加一些阿里云的商业组件\nSpring Cloud 是什么 Spring Cloud 为开发人员提供一些分布式组件，使其快速构建分布式系统（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。\n开发人员使用 Spring Cloud 的组件，实现分布式服务系统，让服务可以在任何分布式环境中正常工作。\nSpring Cloud Alibaba 是什么 官方介绍：Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n组件说明： 开源组件 组件 说明 Nacos Config 分布式配置管理 Nacos Discovery 服务注册和发现管理 Sentinel 流量控制和服务降级 RocketMQ 消息事件驱动 Seata 分布式事务解决方案 Dubbo Spring Cloud 服务远程调用 商业化组件 组件 说明 ACM Nacos Config的商业云服务 ANS Nacos Discovery的商业云服务 SMS 阿里云短信服务 OSS 阿里云对象存储服务 SchedulerX 阿里分布式任务调度服务 有段很好的文字总结，分享给大家：\nSpring 通常指 Spring IOC Spring Framework 包含了 Spring IOC，同时包含了 Spring AOP，并实现与其它 J2EE 框架的整合 Spring Boot 是对 Spring Framework 的补充，让框架的集成变得更简单，致力于快速开发 独立的 Spring 应用 Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文 Spring Cloud Alibaba 采用阿里中间件作为原料，实现了 Spring Cloud 的微服务规范 Spring Cloud Alibaba的官方GitHub仓库地址：\nhttps://github.com/alibaba/spring-cloud-alibaba\n",
    "pubDate": "2019-10-12T14:12:45+08:00"
  }, 
  {
    "objectID": 20191008,
    "url": "https://ichochy.com/posts/blog/20191008.html",
    "title": "通过 Cloudflare 开启全站 https",
    "summary": "Cloudflare 添加域名后，会自动生成通用证书，快速开启全站HTTPS，服务端不用做任何修改，还可以选择多种开启模式\n",
    "content": "Cloudflare 添加域名后，会自动生成通用证书，快速开启全站HTTPS，服务端不用做任何修改，还可以选择多种开启模式\n一、注册Cloudflare账号 直接打开网站：https://www.cloudflare.com,就可以注册账号了，然后添加域名，选择Free套餐，没有任何费用\n二、修改DNS 免费套餐只能通过DNS方式配置 Cloudflare，收费套餐或 Partner，可以通过CNAME配置\n查看 Cloudflare 给自己分配的DNS\n打开自己的域名商网站修改DNS，以aliyun为例：\n控制台=\u0026gt;域名=\u0026gt;管理=\u0026gt;修改DNS 修改为 Cloudflare 分配的DNS后，等待生效……………………\n三、配置域名解析 检查生效状态\n配置域名解析，一般会将解析同步过来，打开小云朵表示开启CDN加速\n四、开启 HTTPS 有四种模式可以选择，分别是\n1. Off (not secure) 不开启 2. Flexible 开启 浏览器到\u0026lt;-\u0026gt;Cloudflare 3. Full 开启 浏览器\u0026lt;-\u0026gt;Cloudflare\u0026lt;-\u0026gt;服务器 4. Full (strict) 开启 浏览器\u0026lt;-\u0026gt;Cloudflare\u0026lt;-\u0026gt;服务器 信任证书，更加严格 至此，已经通过 Cloudflare 开启了 DNS、CDN、HTTPS\n但： 免费套餐在国内是没有快速的 CDN 节点，CDN 也就没有加速的效果了\n如果需要国内快速的 CDN ，可以使用企业版，但要不差钱，或使用国内合作商百度云加速\n",
    "pubDate": "2019-10-08T14:22:45+08:00"
  }, 
  {
    "objectID": 20190925,
    "url": "https://ichochy.com/posts/blog/20190925.html",
    "title": "jekyll-admin的搭建和使用",
    "summary": "通过jekyll搭建好了自己的博客。写博客成为了日常，经过一段时间的摸索，发现jekyll-admin是个好东西，它是博客的后台管理系统，可以方便的管理和编写自己的博客\n安装 运行命令gem install jekyll-admin进行安装\n",
    "content": "通过jekyll搭建好了自己的博客。写博客成为了日常，经过一段时间的摸索，发现jekyll-admin是个好东西，它是博客的后台管理系统，可以方便的管理和编写自己的博客\n安装 运行命令gem install jekyll-admin进行安装\n配置 在_config.yml中添加 - jekyll-admin\nplugins: - jekyll-admin 使用 运行命令jekyll server 启动jekyll\n直接访问http://127.0.0.1:4000/admin就可以看到jekyll-admin的使用界面\n",
    "pubDate": "2019-09-25T15:22:38+08:00"
  }, 
  {
    "objectID": 20190922,
    "url": "https://ichochy.com/posts/shell/20190922.html",
    "title": "神奇的不可见空格\u003c200b\u003e导致代码异常",
    "summary": "故事是这样发生的，在做一个JSON对象转化的时候，出现了转化异常；刚开始还是以为是格式错误，后来一步步排除，才发现是不可见空格\u0026lt;200b\u0026gt;导致的解析异常\n",
    "content": "故事是这样发生的，在做一个JSON对象转化的时候，出现了转化异常；刚开始还是以为是格式错误，后来一步步排除，才发现是不可见空格\u0026lt;200b\u0026gt;导致的解析异常\n出现 使用Typora编写文字时，使用Tab会生成神奇的不可见空格\n发现 通过VIM查看文档，会看到\u0026lt;200b\u0026gt;神奇的存在\n解决 1 . 使用trim()方法可以去除掉神奇的空格 2 . 使用正则表式进行替换replace(/\\t+/g,\u0026quot;\u0026quot;)\n",
    "pubDate": "2019-09-22T18:12:45+08:00"
  }, 
  {
    "objectID": 20190904,
    "url": "https://ichochy.com/posts/swift/20190904.html",
    "title": "OC与Swift混编，三种场景的实现方式",
    "summary": "多语言并存时期，混编成为一种必须的方式 ，在多场景中实现OC和Swift语言的并存原来是如此简单\n",
    "content": "多语言并存时期，混编成为一种必须的方式 ，在多场景中实现OC和Swift语言的并存原来是如此简单\n第一种场景，App中实现混编 1. 创建桥接文件*.h 新建一个桥接文件，New File 选择 Header File 创建\n2. 指定桥接文件 指定刚刚的新建的桥接文件 project-\u0026gt;targets-\u0026gt;Build Setting-\u0026gt;All-\u0026gt;Swift Compilter General-\u0026gt;Objective-C-Bridging-Header 3. 导入OC头文件(*.h)到桥接文件 如：#import \u0026quot;Log.h\u0026quot;\n4. 完成调用，在Swift文件中直接调用 注：在Swift项目中第一次创建OC文件，Xcode会自动提示创建桥接文件\n第二种场景，Framework 中实现混编 1. 创建Famework 创建完成后会生成一个同名头文件*.h\n2. 将OC头文件(*.h)设置为公开头文件 直接拖入 project-\u0026gt;targets-\u0026gt;Build Phases-\u0026gt;Headers-\u0026gt;Public 3. 导入OC头文件(*.h)到同名头文件 如：#import \u0026quot;Log.h\u0026quot;\n4. 完成调用 在对外的Swift文件中直接调用\n注：对外的类和方法必须 public 标示才可访问\n第三种场景，Pod 包中实现混编 在完成第二种场景后，添加*.podspec文件实现 Pod 包\n1. 生成 *.podspec 运行命令 pod spec create [name] 生成 *.podspec 文件\n2. 编辑 *.podspec 在 *.podspec 中将OC头文件(*.h)设置为公开头文件\n如：spec.public_header_files = \u0026quot;Log.h\u0026quot;\n#完整的文件信息 Pod::Spec.new do |spec| spec.name = \u0026#34;OCSwiftFramework\u0026#34; spec.version = \u0026#34;0.0.1\u0026#34; spec.summary = \u0026#34;OCSwiftFramework\u0026#34; spec.description = \u0026lt;\u0026lt;-DESC OCSWiftFramework DESC spec.homepage = \u0026#34;https://www.ichochy.com\u0026#34; spec.license = \u0026#34;MIT\u0026#34; # spec.license = { :type =\u0026gt; \u0026#34;MIT\u0026#34;, :file =\u0026gt; \u0026#34;FILE_LICENSE\u0026#34; } spec.author = { \u0026#34;MLeo\u0026#34; =\u0026gt; \u0026#34;me@ichochy.com\u0026#34; } spec.platform = :osx spec.osx.deployment_target = \u0026#34;10.10\u0026#34; spec.source = { :git =\u0026gt; \u0026#34;https://github.com/iChochy/HelloWorld.git\u0026#34;, :tag =\u0026gt; \u0026#34;#{spec.version}\u0026#34; } spec.source_files = \u0026#34;**/*.{h,m,swift}\u0026#34; spec.exclude_files = \u0026#34;Info.plist\u0026#34; spec.public_header_files = \u0026#34;Flog.h\u0026#34; spec.swift_version = \u0026#34;4.2\u0026#34; end 3. 验证 *.podspec 运行命令 pod lib lint 完成验证\n4. 完成调用 a. 运行命令 pod trunk push [NAME.podspec] 完成发布\nb. Podfile 中添加 pod \u0026quot;[name]\u0026quot;\nc. 运行命令 pod install 完成 pod 安装\nd. 安装完成后直接调用\n注：可用 pod \u0026quot;[name]\u0026quot;, :path =\u0026gt; \u0026quot;[path]\u0026quot; 本地指定\nGitHub： HelloWorld：https://github.com/iChochy/HelloWorld.git\n",
    "pubDate": "2019-09-04T10:22:33+08:00"
  }, 
  {
    "objectID": 20190901,
    "url": "https://ichochy.com/posts/swift/20190901.html",
    "title": "CocoaPods 构建自己的 Pod 库",
    "summary": "构建一个自己的库供其它人使用是不是一件很酷(苦)的事情，通过CocoaPods 可以快捷的构建自己库，并向全世界分享你的成果\n",
    "content": "构建一个自己的库供其它人使用是不是一件很酷(苦)的事情，通过CocoaPods 可以快捷的构建自己库，并向全世界分享你的成果\n一、创建 Podspec 有两种方式：\n使用命令 pod lib create mylib 创建一套完整的 Pod 库模版 使用命令 pod spec create mylib 创建 Podspec 的配置文件 二、配置 Podspec 官网说明：https://guides.cocoapods.org/syntax/podspec.html#specification\nPod::Spec.new do |spec| spec.name = \u0026#39;libminipng\u0026#39; spec.version = \u0026#39;0.0.5\u0026#39; spec.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39; } spec.homepage = \u0026#39;https://www.ichochy.com\u0026#39; spec.authors = { \u0026#39;iChochy\u0026#39; =\u0026gt; \u0026#39;me@ichochy.com\u0026#39; } spec.summary = \u0026#39;Swift library that compresses PNG\u0026#39; spec.source = { :git =\u0026gt; \u0026#39;https://github.com/iChochy/libminipng.git\u0026#39;, :tag =\u0026gt; \u0026#39;v3.1.0\u0026#39; } spec.source_files = \u0026#39;libminipng/Classes/**/*\u0026#39; spec.public_header_files = \u0026#34;libminipng/Classes/libminipng.h\u0026#34;,\u0026#34;libminipng/Classes/minipng.h\u0026#34; end spec.source：检索库的远程地址\n支持指定方式：\n:git =\u0026gt; :tag, :branch, :commit, :submodules :svn =\u0026gt; :folder, :tag, :revision :hg =\u0026gt; :revision :http =\u0026gt; :flatten, :type, :sha256, :sha1, :headers spec.source_files: 库的源代码\n通过正则方式匹配，如：\n\u0026#34;JSONKit.?\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;] \u0026#34;*.[a-z][a-z]\u0026#34; #=\u0026gt; [\u0026#34;CHANGELOG.md\u0026#34;, \u0026#34;README.md\u0026#34;] \u0026#34;*.[^m]*\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;] \u0026#34;*.{h,m}\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;] \u0026#34;*\u0026#34; #=\u0026gt; [\u0026#34;CHANGELOG.md\u0026#34;, \u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;, \u0026#34;README.md\u0026#34;] spec.public_header_files: 公共头文件\n如果OC混编，可以在公共头文件中引入OC文件，如同桥接文件\n注：如果未指定公共头文件，那么source_files中的所有文件将被视为公共头文件\n三、验证 Podspec pod lib lint //本地验证 pod spec lint //在线验证，检查外部仓库和相关标签 如果出现警告(WARN) ，可以添加--allow-warnings忽略警告\n如果出现错误(ERROR)，可以添加 --verbose，查看详情\n四、创建账号 注册账号：\npod trunk register me@ichochy.com 'iChochy' --description='macbook' 激活账号：\n完成注册后进入邮件点击激活链接进行激活操作 查看账号：\npod trunk me 五、发布 Podspec pod trunk push [NAME.podspec] 将您的Podspec部署到Trunk，并公开发布\npod repo push REPO [NAME.podspec] 将您的Podspec部署到私有仓库\n注：如果出现警告(WARN) ，可以添加--allow-warnings忽略警告\n",
    "pubDate": "2019-09-01T12:32:55+08:00"
  }, 
  {
    "objectID": 20190823,
    "url": "https://ichochy.com/posts/swift/20190823.html",
    "title": "Mac 将 App 程序打包成为 dmg",
    "summary": "用最简单的打包方式，将自己开发的App打包成为DMG，实现共享分发，快速安装\n",
    "content": "用最简单的打包方式，将自己开发的App打包成为DMG，实现共享分发，快速安装\n1. 新建DMG 打开磁盘工具，新建DMG\nFile-\u0026gt;New Image-\u0026gt;Blank Image 创建DMG\n2. 添加文件 在磁盘工上右键打开\n右键-\u0026gt;Show in Finder 创建快捷键\nln -s /Applications Applications 完成文件添加\n3. 排版，添加背景 修改排版\n右键-\u0026gt;Show View Options 自定义背景\n4. 压缩DMG 推出DMG\n转换DMG\n压缩DMG\n压缩后的文件明显小于原文件，也不可再进行编辑\n5. 完成打包 至此，完成了App打包DMG，可以进行共享发布了\n",
    "pubDate": "2019-08-23T08:32:36+08:00"
  }, 
  {
    "objectID": 20190822,
    "url": "https://ichochy.com/posts/app/20190822.html",
    "title": "iUploader 2.0 七牛云上传工具",
    "summary": " iUploader 是一个免费开源的七牛云上传工具，可直接返回上传文件的地址；可以用作图床工具，进行图片的分享，当然不仅仅是图片\n",
    "content": " iUploader 是一个免费开源的七牛云上传工具，可直接返回上传文件的地址；可以用作图床工具，进行图片的分享，当然不仅仅是图片\n软件介绍： iUploader主要功能将文件上传至七牛云，返回 Markdown 格式的链接到剪贴板\n功能介绍 图片本地压缩 图片右键上传 图片截取上传 图片复制上传 图片拖拽上传 https加密上传 开发 继承七牛云SDK，使用Swift开发，App自签上传凭证，自动选择存储区域，通过https加密上传。\n截图 菜单\n配置\n更新 剪贴板监控，截图自动上传 引入pngquant， 提高png图片的压缩比，减少流量的损失，快速完成图片的加载 添加历史记录，方便随时查看使用上传文件，保留十条 完善文件上传流程，不限于图片的上传 完善多文件上传，统一完成上传 优化进度加载展示，菜单逻辑调整 下载 iUploader.dmg-GitHub\niUploader.dmg-七牛云\nhttps://github.com/iChochy/iUploader/releases/download/2.0.5/iUploader.dmg\n",
    "pubDate": "2019-08-22T15:22:36+08:00"
  }, 
  {
    "objectID": 20190812,
    "url": "https://ichochy.com/posts/swift/20190812.html",
    "title": "libminipng 压缩png的swift-framework",
    "summary": "通过lodepng解析png图片，使用pngquant算法进行压缩的swift-framework，可实现PNG图片的压缩，并很好的保持图片的质量，完美实现其透明效果，支持Cocoapods安装使用\n",
    "content": "通过lodepng解析png图片，使用pngquant算法进行压缩的swift-framework，可实现PNG图片的压缩，并很好的保持图片的质量，完美实现其透明效果，支持Cocoapods安装使用\n方法说明 /// 通过PNG图片Data压缩 /// /// - Parameters: /// - data: PNG图片Data /// - maximum: 压缩率，0-100,100为最好 /// - Returns: 压缩后的PNG图片Data public static func data2Data(_ data:Data,_ maximum:Int) -\u0026gt; Data? /// 通过PNG图片路径压缩 /// /// - Parameters: /// - path: PNG图片路径 /// - maximum: 压缩率，0-100,100为最好 /// - Returns: 压缩后的PNG图片Data public static func path2Data(_ path:String,_ maximum:Int) -\u0026gt; Data? Cocoapods Podfile 添加 pod \u0026quot;libminipng\u0026quot;\n运行命令 pod install\n使用 引入 import libminipng\n编写代码：\nlet path:String = \u0026#34;https://images.ichochy.com/Cloud.png\u0026#34; let data:Data = try! Data.init(contentsOf: URL.init(string: path)!) let maximum:Int = 100 // 压缩率，0-100,100为最好 let result:Data? = minipng.data2Data(data,maximum) try! result?.write(to: URL.init(fileURLWithPath: \u0026#34;/Users/mleo/minipng.png\u0026#34;)) let path:String = \u0026#34;/Users/mleo/Cloud.png\u0026#34; let maximum:Int = 100 // 压缩率，0-100,100为最好 let result:Data? = minipng.path2Data(path, maximum) try! result?.write(to: URL.init(fileURLWithPath: \u0026#34;/Users/mleo/minipng.png\u0026#34;)) GitHub libminipng: https://github.com/iChochy/libminipng\npngquant: https://github.com/ImageOptim/libimagequant\nlodepng: https://github.com/lvandeve/lodepng\n",
    "pubDate": "2019-08-12T12:25:36+08:00"
  }, 
  {
    "objectID": 20190412,
    "url": "https://ichochy.com/posts/shell/20190412.html",
    "title": "通过端口号关闭当前进程",
    "summary": "使用Shell脚本的方式，通过端口号来关闭当前进程\n",
    "content": "使用Shell脚本的方式，通过端口号来关闭当前进程\n查看脚本 lsof -i TCP:9100 | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; 使用到三个命令lsof、grep、awk\nlsof 获取端口进程列表\ngrep 精准匹配进程\nawk 获取进程号\n完整示例： #!/bin/bash PROCESS=echo | lsof -i TCP:9100 | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; if [ $PROCESS ]; then kill -9 $PROCESS echo kill $PROCESS fi ",
    "pubDate": "2019-04-12T12:25:36+08:00"
  }, 
  {
    "objectID": 20190410,
    "url": "https://ichochy.com/posts/software/20190410.html",
    "title": "持续集成和持续交付工具-jenkins",
    "summary": "打破原有的手动部署方式，实现程序自动化。通过 jenkins 来解放你的双手\n",
    "content": "打破原有的手动部署方式，实现程序自动化。通过 jenkins 来解放你的双手\njenkins说明 jenkins是一款由Java编写的开源的持续集成工具，它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令，可以通过各种手段触发构建，例如提交给版本控制系统时被触发，也可以通过类似Cron的机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。\njenkins安装 官方下载：https://jenkins.io/zh/download/\n有相应系统的安装包和通用包(.war），通过Servlet容器运行\n1､WAR包安装 将最新的稳定Jenkins WAR包 下载到您计算机上的相应目录。\n在下载的目录内打开一个终端/命令提示符窗口。\n运行命令java -jar jenkins.war\n浏览 http://127.0.0.1:8080 ，并等到Unlock Jenkins页面出现。\n2､brew安装 Mac下执行brew install jenkins-lts 命令安装\nMacBook-Pro:~ mleo$ brew install jenkins-lts Updating Homebrew... ==\u0026gt; Auto-updated Homebrew! Updated 2 taps (homebrew/core and homebrew/cask). ==\u0026gt; New Formulae zabbix-cli ==\u0026gt; Downloading http://mirrors.jenkins.io/war-stable/2.164.1/jenkins.war ==\u0026gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/2.164.1/jenkins.war ######################################################################## 100.0% ==\u0026gt; jar xvf jenkins.war ==\u0026gt; Caveats Note: When using launchctl the port will be 8080. To have launchd start jenkins-lts now and restart at login: brew services start jenkins-lts Or, if you don\u0026#39;t want/need a background service you can just run: jenkins-lts ==\u0026gt; Summary 🍺 /usr/local/Cellar/jenkins-lts/2.164.1: 7 files, 77.3MB, built in 26 seconds ==\u0026gt; `brew cleanup` has not been run in 30 days, running now... Removing: /Users/mleo/Library/Caches/Homebrew/java_cache... (275B) Removing: /Users/mleo/Library/Logs/Homebrew/cocoapods... (64B) 安装完成后可以执行brew services list查看安装服务\nMacBook-Pro:~ mleo$ brew services list Name Status User Plist jenkins-lts stopped 启动jenkins，执行brew services start jenkins-lts 关闭jenkins，执行brew services stop jenkins-lts\nMacBook-Pro:~ mleo$ brew services start jenkins-lts ==\u0026gt; Successfully started `jenkins-lts` (label: homebrew.mxcl.jenkins-lts) 直接访问：http://127.0.0.1:8080\n第一次进行需解锁\n通过cat /Users/mleo/.jenkins/secrets/initialAdminPassword 查看密码\n推荐插件安装中\n创建第一个管理员\n实例配置\n进入系统\njenkins使用 部署项目 一、创建任务 左上角点击新建任务\n选择自由风格项目进入配置\n配置任务主要分下面几步：\n项目说明 源代码管理 构建触发 构建准备 构建操作 构建完后操作 二、执行任务 进入任务，点击立即构建\n三、查看日志 进入构建进程，查看控制台输出 可以查看构建日志\n",
    "pubDate": "2019-04-10T12:20:32+08:00"
  }, 
  {
    "objectID": 20190403,
    "url": "https://ichochy.com/posts/app/20190403.html",
    "title": "七牛云图床上传工具-iUploader",
    "summary": "iUploader主要功能将图片上传至七牛云，返回 Markdown 格式的链接到剪贴板\n",
    "content": "iUploader主要功能将图片上传至七牛云，返回 Markdown 格式的链接到剪贴板\n功能介绍\n图片本地压缩 图片右键上传 图片复制上传 图片拖拽上传 https加密上传 开发\n继承七牛云SDK，使用swift开发，App自签上传凭证，自动选择存储区域，通过https加密上传。\n下载\nhttps://github.com/iChochy/iUploader/releases/download/1.0.1/App.dmg\n",
    "pubDate": "2019-04-03T08:20:05+08:00"
  }, 
  {
    "objectID": 20190309,
    "url": "https://ichochy.com/posts/blog/20190309.html",
    "title": "加速你的博客永无止境-七牛云存储",
    "summary": "将自己的静态博客直接部署到七牛云存储，由七牛云托管运行，你说快不快，还没有注册七牛云的看这里，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y，哈哈！\n",
    "content": "将自己的静态博客直接部署到七牛云存储，由七牛云托管运行，你说快不快，还没有注册七牛云的看这里，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y，哈哈！\n一、创建七牛云存储 登录进入管理中心，菜单进入：对象存储=\u0026gt;新建存储空间，设置好空间名称就可以直接创建，完成后会分配一个测试域名，有效期只有30天，当然可以自定义域名，长期使用\n二、静态博客文件构建 我使用的是jekyll管理博客， 通过命令jekyll build构建\nMacBook-Pro:iChochy mleo$ jekyll build Configuration file: /Users/mleo/Develop/GitHub/iChochy/_config.yml Source: /Users/mleo/Develop/GitHub/iChochy Destination: /Users/mleo/Develop/GitHub/iChochy/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 1.121 seconds. Auto-regeneration: disabled. Use --watch to enable. 构建成功后，生成的静态文件都在_site目录中，直接上传到云空间就可以了\n三、同步静态博客文件到云存储 这里使用到七牛云官方工具qshell\n工具介绍：https://github.com/qiniu/qshell\n工具下载：http://devtools.qiniu.com/qshell-v2.3.6.zip\n选择安装：\n文件名 描述 shell_linux_x86 Linux 32位系统 shell_linux_x64 Linux 64位系统 shell_linux_arm Linux ARM CPU shell_windows_x86.exe Windows 32位系统 shell_windows_x64.exe Windows 64位系统 shell_darwin_x64 Mac 64位系统，主流的系统 1､安装\n以Mac为例，安装shell_darwin_x64\n运行复制命令：cp qshell_darwin_x64 /usr/local/bin/qshell，将shell_darwin_x64复制到 bin目录下，运行qshell -v检测是否安装成功\nMacBook-Pro:qshell-v2.3.6 mleo$ qshell -v qshell version v2.3.6 2､添加账号\n运行命令qshell account\nqshell account \u0026lt;AK\u0026gt; \u0026lt;SK\u0026gt; \u0026lt;Your Name\u0026gt; 参数 说明 \u0026lt;AK\u0026gt;、\u0026lt;SK\u0026gt; 可以到个人中心 =\u0026gt; 密钥管理中查看 \u0026lt;Your Name\u0026gt; 为用户的唯一标识，自定义，如iChochy 3､同步文件\n使用命令qshell qupload \u0026lt;LocalUploadConfig\u0026gt; 其中LocalUploadConfig参数配置文件\n本人的LocalUploadConfig文件信息：\nMacBook-Pro:iChochy mleo$ cat .LocalUploadConfig { \u0026#34;src_dir\u0026#34; : \u0026#34;/Users/mleo/Develop/GitHub/iChochy/_site\u0026#34;, \u0026#34;bucket\u0026#34; : \u0026#34;blog\u0026#34;, \u0026#34;ignore_dir\u0026#34; : false, \u0026#34;overwrite\u0026#34; : true, \u0026#34;check_exists\u0026#34; : true, \u0026#34;check_hash\u0026#34; : true, \u0026#34;check_size\u0026#34; : true, \u0026#34;rescan_local\u0026#34; : true, \u0026#34;skip_file_prefixes\u0026#34; : \u0026#34;test,demo,\u0026#34;, \u0026#34;skip_path_prefixes\u0026#34; : \u0026#34;hello/,temp/\u0026#34;, \u0026#34;skip_fixed_strings\u0026#34; : \u0026#34;.svn,.git,.log\u0026#34;, \u0026#34;skip_suffixes\u0026#34; : \u0026#34;.DS_Store,.exe\u0026#34;, \u0026#34;log_file\u0026#34; : \u0026#34;/Users/mleo/.qshell/upload.log\u0026#34;, \u0026#34;log_level\u0026#34; : \u0026#34;info\u0026#34;, \u0026#34;log_rotate\u0026#34; : 1, \u0026#34;log_stdout\u0026#34; : false, \u0026#34;file_type\u0026#34; : 0 } 主要参数说明：\n参数 说明 src_dir 本地同步目录 bucket 云空间名称 log_file 日志文件 命令参数详细说明：https://github.com/qiniu/qshell/blob/master/docs/qupload.md\nMacBook-Pro:iChochy mleo$ qshell qupload .LocalUploadConfig Writing upload log to file /Users/mleo/.qshell/upload.log Uploading /Users/mleo/Develop/GitHub/iChochy/_site/404.html =\u0026gt; 404.html [1/67, 1.5%] ... ………… See upload log at path /Users/mleo/.qshell/upload.log 通过日志查看详情\ncat /Users/mleo/.qshell/upload.log 至此：文件已经同步到了云空间，修改文件后再次运行qshell qupload \u0026lt;LocalUploadConfig\u0026gt;命令及可完成同步\n四、自定义域名 1､云空间绑定域名\n菜单进入对象存储=\u0026gt;空间概览=\u0026gt;融合 CDN 加速域名=\u0026gt;立即绑定一个域名 创建域名\n2､域名解析\n创建成功后七牛云会为每个域名分配一个CNAME，如：www.ichochy.com.qiniudns.com\n登录域名商的管理系统，将域名解析到CNAME\n五、设置存储空间 菜单进入对象存储=\u0026gt;空间设置 设置空间信息\n如：开启默认首页index.html，自定义404页面等\n现在可以通过域名直接访问自己的博客了，是不是非常快快快………………\n如：https://www.ichochy.com\n",
    "pubDate": "2019-03-09T16:10:00+08:00"
  }, 
  {
    "objectID": 20190306,
    "url": "https://ichochy.com/posts/blog/20190306.html",
    "title": "加速你的博客永无止境-七牛云CDN",
    "summary": "个人的博客是通过jekyll构建，通过GitHub Pages搭建，可是在国内访问速度慢，百度还无法检索，网上找到的就是通CDN来加速博客。于是开始了折腾………………\n",
    "content": "个人的博客是通过jekyll构建，通过GitHub Pages搭建，可是在国内访问速度慢，百度还无法检索，网上找到的就是通CDN来加速博客。于是开始了折腾………………\n先了解下什么是CDN：\nCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN的关键技术主要有内容存储和分发技术\n个人的简单理解：将源站的内容分散缓存，形成多个接点，当用户访问，将最快的接点返回给用户，达到想要的提速效果\n1.开启CDN 使用七牛云CDN，个人用户可以免费使用10G的流量；使用七牛云CDN加速有个必要条件，有自己的域名，并通过国家的域名备案，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y\n直接开干，先注册个人用户，并实名(国家的优待)\n菜单进入：融合 CDN =\u0026gt;域名管理=\u0026gt;添加域名\n标题 填写的内容 加速域名 自己的域名，如：www.ichochy.com 通信协议 http/https，注：https没有免费的流量 源站配置 选择源站域名,写下github pages的地址，如：ichochy.github.io 源站配置 源站测试：添加一个源站能访问的地址，如：index.html，完成源站测试 填写完相关信息后可以直接创建了，创建好后需要等待几分钟，让七牛云完成实例化，七牛云会为每个域名分配一个CNAME，如：www.ichochy.com.qiniudns.com。\n2.修改域名解析 现在还差最后一步，也是最关键的，登录域名商的管理系统，修改域名解析，将域名指向七牛云生成的CNAME，完成解析\n标题 填写的内容 记录类型 选择CNAME 主机记录 如：www 记录值 如：www.ichochy.com.qiniudns.com 所有的操作完成后，可以看到七牛云上域名状态是成功\n3.测试成果 通过dig命令可以查看到域名解析的过程：\nMacBook-Pro:_posts mleo$ dig www.ichochy.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.ichochy.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 24019 ;; flags: qr rd ra; QUERY: 1, ANSWER: 11, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;www.ichochy.com.\tIN\tA ;; ANSWER SECTION: www.ichochy.com.\t600\tIN\tCNAME\twww.ichochy.com.qiniudns.com. www.ichochy.com.qiniudns.com. 600\tIN\tCNAME\tdaliupnew.china.qiniudns.com. daliupnew.china.qiniudns.com. 456 IN\tCNAME\ttinychinacdndownload.qiniu.com.w.kunlunea.com. 直此，完成了CDN的加速\n4.问题 快也缓存，慢也缓存，因为有缓存的存在，导致新更新的内容不能及时推送给用户，这里就要手动去刷新\n菜单进入：融合 CDN =\u0026gt;刷新预取=\u0026gt;刷新文件根据自己的情况进行提交，如图：\n",
    "pubDate": "2019-03-06T15:25:00+08:00"
  }, 
  {
    "objectID": 20190213,
    "url": "https://ichochy.com/posts/blog/20190213.html",
    "title": "Jekyll+GitHub Pages部署自己的静态Blog",
    "summary": "混了这么久，一直想拥有自己的博客，通过jekyll和GitHub Pages捣腾出了自己的博客(https://www.ichochy.com)\n",
    "content": "混了这么久，一直想拥有自己的博客，通过jekyll和GitHub Pages捣腾出了自己的博客(https://www.ichochy.com)\n一、安装jekyll 首先有安装Ruby的开发环境\n运行gem install jekyll bundler安装jekyll和bundler\n运行jekyll new myBlog创建默认的blog\n文件目录：\n-rw-r--r-- 1 mleo staff 35 2 13 15:02 .gitignore -rw-r--r-- 1 mleo staff 398 2 13 15:02 404.html -rw-r--r-- 1 mleo staff 1039 2 13 15:02 Gemfile -rw-r--r-- 1 mleo staff 1686 2 13 15:03 Gemfile.lock -rw-r--r-- 1 mleo staff 1652 2 13 15:02 _config.yml drwxr-xr-x 3 mleo staff 96 2 13 15:02 _posts -rw-r--r-- 1 mleo staff 539 2 13 15:02 about.md -rw-r--r-- 1 mleo staff 175 2 13 15:02 index.md 运行cd myBlog进入blog目录，运行bundler exec jelly serve启动 MacBook-Pro:myBlog mleo$ bundler exec jekyll serve Configuration file: /Users/mleo/Develop/Coding/myBlog/_config.yml Source: /Users/mleo/Develop/Coding/myBlog Destination: /Users/mleo/Develop/Coding/myBlog/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 0.862 seconds. Auto-regeneration: enabled for \u0026#39;/Users/mleo/Develop/Coding/myBlog\u0026#39; Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. 通过http://127.0.0.1:400就可以访问blog了 如下图：\n二、了解jekyll jekyll目录结构：\n文件/目录 描述 _config.yml 常量配置信息，网站的基础信息 _drafts 未发布的草稿帖子 _includes 模块化页面，使用： include default.html _layouts 布局模板页面，使用: layout: default _posts 发布的blog，固定格式： YEAR-MONTH-DAY-title.MARKUP。 _data 文件数据（.yml、 .yaml、.json、.csv或.tsv格式） _sass 定义站点使用的样式 _site Jekyll build 后生成的站点静态文件 .jekyll-metadata Jekyll build 日志信息 index.html或index.md其他HTML，Markdown文件 将由Jekyll转换，生成首页 其他文件/文件夹 例如 css、images和favicon.ico文件等 通过Gemfile文件配置 jekyll 主题\n从Jekyll 3.2开始，jekyll new使用Gemfile文件来定义网站的主题，使默认目录结构更简单。默认情况下_layouts，_includes和_sass存储在Ruby中。\nminima 是默认主题，运行 bundle show minima 显示主题文件位置\nMacBook-Pro:myBlog mleo$ bundle show minima /Library/Ruby/Gems/2.3.0/gems/minima-2.5.0 自定义站点信息\n通过自定义_config.yml文件，改变 blog 网站信息，\n常量 说明 title 标题 email 作者邮箱 description 网站信息 baseurl 网站路径 url 网站地址，如：https://www.ichochy.com twitter_username 媒体账号，如：iChochy github_username 媒体账号，如：iChochy 注：修改_config.yml需要重启服务\n三、书写Blog 进入_post目录，开始你的创作吧，注意文件的格式必须为YEAR-MONTH-DAY-title.MARKUP，如：2019-02-13-blog.md 。\n开始写作吧，直接使用md语法来书写你的文章\n--- --指定模板 title: \u0026#34;blog\u0026#34; --标题 date: 2019-02-13 15:02:11 +0800 --时间 tags: blog --分类 --- --内容 1. 开始 内空 2. 写作 内容 3. 完成 内容 如下图：\n四、创建GitHub Pages项目 新建一个项目，项目名必须为\u0026lt;username\u0026gt;.github.io,如：我的用户名为iChochy，项目名为iChochy.github.io 如下图：\n五、将Blog接交到GitHub 将本地写好的的blog pull到github上，在项目设置中打开GitHub Pages 如下图：\n选择master branch并保存，就完成了部署 六、运行Blog 直接访问项目名(\u0026lt;username\u0026gt;.github.io)就可以看你blog了，如：iChochy.github.io\n七、自定义域名 自定义域名需要有自己的域名，没有可以注册购买个心意的域名：阿里云\n进入域名配置中心，配置域名解析 如下图：\n进入github项目设置，设置自己的域名并保存，就完成了自定义域名设置 如下图： 八、开启HTTPS 进入github项目设置，开启Enforce HTTPS就完成了\n不过，如果是自定义域名，会需要等待几分钟，github需要申请证书并部署\n完成开启后，如下图：\n",
    "pubDate": "2019-02-13T11:45:00+08:00"
  }, 
  {
    "objectID": 20190212,
    "url": "https://ichochy.com/posts/shell/20190212.html",
    "title": "通过shell查看SVN的版本信息",
    "summary": "实现原理：通过svn info查看svn信息，使用grep获取版本信息，用awk获取版本号，然后对比版本号是否需要更新\n",
    "content": "实现原理：通过svn info查看svn信息，使用grep获取版本信息，用awk获取版本号，然后对比版本号是否需要更新\n#!/bin/sh revision=`svn info |grep \u0026#34;Last Changed Rev:\u0026#34; |awk \u0026#39;{print $4}\u0026#39;` echo \u0026#34;the revision is $revision\u0026#34; URL=`svn info |grep ^URL: |awk \u0026#39;{print $2}\u0026#39;` echo \u0026#34;the url is $URL\u0026#34; svnRevision=`svn info $URL |grep \u0026#34;Last Changed Rev:\u0026#34; |awk \u0026#39;{print $4}\u0026#39;` echo \u0026#34;the revision in svn is $svnRevision\u0026#34; if [[ $revision \u0026lt; $svnRevision ]] ; then echo \u0026#34;need svn up\u0026#34; svn up echo \u0026#34;svn up finish\u0026#34; else echo \u0026#34;no need svn up\u0026#34; fi ",
    "pubDate": "2019-02-12T08:20:05+08:00"
  }, 
  {
    "objectID": 20181212,
    "url": "https://ichochy.com/posts/app/20181212.html",
    "title": "倍速音乐",
    "summary": "学习需要，有太多的音频文件要听，可是常用的播放器只能常速播放。所以有了后面的想法，自己开发一款App，来实现倍速播放的需求，加快学习进度，提高效率，节省时间。\n",
    "content": "学习需要，有太多的音频文件要听，可是常用的播放器只能常速播放。所以有了后面的想法，自己开发一款App，来实现倍速播放的需求，加快学习进度，提高效率，节省时间。\n优点： 简单、便捷、快速 倍速播放，能快也能慢，让您学习随心所欲 支持后台播放，让您不间断学习，加快学习进度 软件截图： 锁屏播放\n锁屏播放\n播放界面\n",
    "pubDate": "2018-12-12T18:30:00+08:00"
  }, 
  {
    "objectID": 20181202,
    "url": "https://ichochy.com/posts/life/20181202.html",
    "title": "开篇",
    "summary": "说说生活 生活总是有太多的磨炼，让你一步步的成长，可传奇的背后都是些艰辛的故事。\n我坚信，每个人都有自己的生活方式，但只要认真一点点，再坚持一点点，就会有不一样的生活。\n很多时候，被现实生活所迫，总是难以突破自己，不敢尝试。\n若想改变就必须不断的尝试新事物，越是让自己害怕就越要尝试，熟悉后害怕也就消失了，自己才有新高度，看待问题的方式又改变了。\n",
    "content": "说说生活 生活总是有太多的磨炼，让你一步步的成长，可传奇的背后都是些艰辛的故事。\n我坚信，每个人都有自己的生活方式，但只要认真一点点，再坚持一点点，就会有不一样的生活。\n很多时候，被现实生活所迫，总是难以突破自己，不敢尝试。\n若想改变就必须不断的尝试新事物，越是让自己害怕就越要尝试，熟悉后害怕也就消失了，自己才有新高度，看待问题的方式又改变了。\n",
    "pubDate": "2018-12-02T18:32:03+08:00"
  }
]