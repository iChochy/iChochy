[
  {
    "objectID": 20210418,
    "url": "https://ichochy.com/posts/20210418/",
    "title": "Elasticsearch, Kibana, Logstash, Filebeat 实现日志的自动采集、搜索和分析",
    "summary": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化",
    "content": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎\nKibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化管理和展示\nLogstash 是一个免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中\nBeats 是一个免费且开放的平台，集合了多种单一用途数据采集器，将数据发送给 Logstash 或 Elasticsearch\nBeats 系列 全品类采集器，搞定所有数据类型，如下：\n  Filebeat：日志文件\n  Metricbeat：指标\n  Packetbeat：网络数据\n  Winlogbeat：Windows 事件日志\n  Auditbeat：审计数据\n  Heartbeat：运行时间监控\n  Functionbeat：无需服务器的采集器\n  一、下载镱像(image) Docker映像和标签的列表：https://www.docker.elastic.co\n搜索镱像(image)\ndocker search elasticsearch docker search kibana docker search logstash 获取镱像(image)\ndocker pull elasticsearch:7.6.0 #镜像名称:Tag docker pull kibana:7.6.0 #镜像名称:Tag docker pull logstash:7.6.0 #镜像名称:Tag docker pull docker.elastic.co/beats/filebeat:7.6.0 #镜像名称:Tag 注：版本要统一\n二、创建 ELK.yml ELK.yml\nversion: \u0026#34;3.5\u0026#34; services: elasticsearch: container_name: elasticsearch image: elasticsearch:7.6.0 #镱像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana image: kibana:7.6.0 #镱像(image) restart: always #重启方式 environment: I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 logstash: container_name: logstash image: logstash:7.6.0 restart: always ports: - \u0026#34;5044:5044\u0026#34; - \u0026#34;9600:9600\u0026#34; filebeat: container_name: filebeat image: filebeat:7.6.0 restart: always command: filebeat -e -strict.perms=false #禁用严格权限检查 volumes: #文件夹映射，本地:容器 - \u0026#34;/Users/ichochy/beats/filebeat.yml:/usr/share/filebeat/filebeat.yml\u0026#34; 注：\n 注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败 读取文件权限问题是软件自身的权限验证，可使用--strict.perms=false，禁用严格权限验证  # 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here # 错误息信 Exiting: error loading config file: config file (\u0026#34;{beatname}.yml\u0026#34;) can only be writable by the owner but the permissions are \u0026#34;-rw-rw-r--\u0026#34; (to fix the permissions use: \u0026#39;chmod go-w /etc/{beatname}/{beatname}.yml\u0026#39;) 三、运行容器 宿主机hosts中添加\n127.0.0.1 elasticsearch 命令启动\ndocker-compose -f ELK.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 四、检查容器的运行状态 elasticsearch 访问：http://127.0.0.1:9200\nlogstash 访问：http://127.0.0.1:9600\nKibana 访问：http://127.0.0.1:5601，进入 Kibana\n运行docker ps查询容器运行状态，可以查看到容器的ID\nmleo$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4d53b3ab9772 filebeat:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 days ago Up 8 minutes 1b8cb2effede logstash:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 hours ago Up About an hour 0.0.0.0:5044-\u0026gt;5044/tcp, 0.0.0.0:9600-\u0026gt;9600/tcp logstash 69b8bc678e4e kibana:7.6.0 \u0026#34;/usr/local/bin/dumb…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:5601-\u0026gt;5601/tcp kibana 8c655f5b7493 elasticsearch:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp elasticsearch 运行docker logs id查看容器运行日志\n例：持续查看`filebeat`日志 docker logs 4d53b3ab9772 -f 五、修改 filebeats 配置 filebeat.inputs: - type: log paths: - /usr/share/filebeat/logs/file/*.log #output.elasticsearch: # hosts: [\u0026#34;http://elasticsearch:9200\u0026#34;] # index: \u0026#34;ichochy\u0026#34; output.logstash: hosts: [\u0026#34;logstash\u0026#34;] 注：容器中，服务间访问可以通过服务名直接访问（协议+服务名+端口），如：http://logstash:5044\n六、修改 logstash 配置  运行docker exec -it 1b8cb2effede bash进入logstash 运行vi pipeline/logstash.conf修改logstash默认配置  input { beats { port =\u0026gt; 5044 } } output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;http://elasticsearch:9200\u0026#34;] #elasticsearch请求地址 index =\u0026gt; \u0026#34;ichochy\u0026#34; #索引名称 } }  运行docker restart 1b8cb2effede重启 logstash  七、模拟采集日志 在filebeat的监控的文件路径下动态添加日志文件，日志就可以自动采集发送到logstash，过虑处理后发送到elasticsearch\n运行docker exec -it 4d53b3ab9772 bash进入filebeat，在logs文件夹添加web.log文件\ntouch web.log #创建日志文件 echo \u0026quot;https://ichochy.com\u0026quot; \u0026gt; web.log #添加日志信息 查看logstash日志信息可以看到打印的日志，监控来自filebeat发来的信息\n{ \u0026#34;ecs\u0026#34; =\u0026gt; { \u0026#34;version\u0026#34; =\u0026gt; \u0026#34;1.4.0\u0026#34; }, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2021-04-18T02:26:42.851Z, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;https://ichochy.com\u0026#34;, \u0026#34;tags\u0026#34; =\u0026gt; [ [0] \u0026#34;beats_input_codec_plain_applied\u0026#34; ], \u0026#34;input\u0026#34; =\u0026gt; { \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;log\u0026#34; }, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;agent\u0026#34; =\u0026gt; { \u0026#34;ephemeral_id\u0026#34; =\u0026gt; \u0026#34;cf2ff9ee-294a-4ac9-9ee7-3da65a3c5beb\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;4d53b3ab9772\u0026#34;, \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;897d2be6-5aa2-4a5d-a824-a440a4d19d73\u0026#34;, \u0026#34;version\u0026#34; =\u0026gt; \u0026#34;7.6.0\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;filebeat\u0026#34; }, \u0026#34;host\u0026#34; =\u0026gt; { \u0026#34;name\u0026#34; =\u0026gt; \u0026#34;4d53b3ab9772\u0026#34; }, \u0026#34;log\u0026#34; =\u0026gt; { \u0026#34;file\u0026#34; =\u0026gt; { \u0026#34;path\u0026#34; =\u0026gt; \u0026#34;/usr/share/filebeat/logs/file/web.log\u0026#34; }, \u0026#34;offset\u0026#34; =\u0026gt; 0 } } 例：持续查看`logstash`日志 docker logs 1b8cb2effede -f 八、管理、搜索、分析日志 访问：http://127.0.0.1:5601，进入 Kibana\n在设置管理（management）中创建索引：\n在Discover可以看到刚刚添加进来的日志数据，开始你的表演…………\n引用   Beats配置文件权限问题：https://www.elastic.co/guide/en/beats/libbeat/current/config-file-permissions.html\n  Compose网络访问：https://docs.docker.com/compose/networking/\n  Docker映像和标签的列表：https://www.docker.elastic.co\n  ",
    "pubDate": "2021-04-18T10:22:45+08:00"
  }, 
  {
    "objectID": 20210315,
    "url": "https://ichochy.com/posts/20210315/",
    "title": "Java 递归实例操作-查询层级菜单",
    "summary": "递归 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。",
    "content": "递归 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。\n递归的运用 系统中总会有菜单和权限的操作，会出现无限层级的操作，就需要用到递归。运用其调用自身的特性，实现无限层级迭代，通过父子节点展示数据。\n递归的实例操作 以查询所有菜单为例\n数据结构    字段 名称     id ID   fatherId 父ID   name 名称   …… ……    数据实体 /* * File:Menus.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2021 * Date:2021/03/16 14:12:16 */ package com.ichochy.entity; import java.util.List; public class Menu { private int id; private int fatherId; private String name; private List\u0026lt;Menu\u0026gt; childs; //…………  } 数据查询 通过 fatherId 查询子菜单信息\n/** * 查询菜单信息-模拟方法 * @param fatherId * @return */ public List\u0026lt;Menu\u0026gt; getMenuByFatherId(int fatherId) { int value = new Random().nextInt(fatherId); if (value % 2 != 0) { List\u0026lt;Menu\u0026gt; menus = new ArrayList\u0026lt;\u0026gt;(value); for (int i = 1; i \u0026lt;= value; i++) { Menu menu = new Menu(); menu.setId(i); menu.setFatherId(fatherId); menu.setName(\u0026#34;menu-\u0026#34; + fatherId+\u0026#34;-\u0026#34;+i); menus.add(menu); } return menus; } return Collections.EMPTY_LIST; } 没有建表查库，写个模拟方法\n递归方法 /* * File:Recursion.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2021 * Date:2021/03/16 14:07:16 */ package com.ichochy.recursion; import com.ichochy.entity.Menu; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; public class Recursion { /** * 获取菜单 * @param fatherId * @return */ public List\u0026lt;Menu\u0026gt; getAllMenus(int fatherId) { List\u0026lt;Menu\u0026gt; menus = getMenuByFatherId(fatherId); for (Menu menu : menus) { fatherId = menu.getId(); //自己调用自己  List\u0026lt;Menu\u0026gt; childMenus = getAllMenus(fatherId); //跳出递归  if (childMenus.isEmpty()) { continue; } menu.setChilds(childMenus); } return menus; } 构成递归需具备的条件：\n 子类问题与父类问题相同 不能无限制地调用自身，须有跳出出口，边界返回  递归数据 [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-1\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-2\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;menu-2-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 3, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-3\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;menu-3-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 4, \u0026#34;fatherId\u0026#34;: 15, \u0026#34;name\u0026#34;: \u0026#34;menu-15-4\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-1\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-2\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;menu-2-1\u0026#34; } ] }, { \u0026#34;id\u0026#34;: 3, \u0026#34;fatherId\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;menu-4-3\u0026#34;, \u0026#34;childs\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;fatherId\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;menu-3-1\u0026#34; } ] } ] } ] ",
    "pubDate": "2021-03-15T10:11:35+08:00"
  }, 
  {
    "objectID": 20201010,
    "url": "https://ichochy.com/posts/20201010/",
    "title": "Java JSON数据实战操作",
    "summary": "JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。 JSON 采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等），这些特性使JSON成为理想的数据交换语言。",
    "content": "JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。 JSON 采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等），这些特性使JSON成为理想的数据交换语言。\n引入GSON Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。\n功能\n 提供简单的toJson()和fromJson()方法，将Java对象到JSON，反之亦然 允许将已有的不可修改的对象与JSON相互转换 Java泛型的广泛支持 允许对象的自定义表示 支持任意复杂的对象（具有深层继承层次结构和泛型类型的广泛使用）  Maven \u0026lt;dependencies\u0026gt; \u0026lt;!-- Gson: Java to Json conversion --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.code.gson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.6\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; } 创建 GSON 默认创建 Gson gson = new Gson() 指定创建 Gson gson = new GsonBuilder() //自定义序列化或反序列化  .registerTypeAdapter(Id.class, new IdTypeAdapter()) //启用复杂的 Map 键序列化  .enableComplexMapKeySerialization() //序列化空字段  .serializeNulls() //设定时间格式  .setDateFormat(DateFormat.LONG) //设定字段命名策略  .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE) //设定打印样式  .setPrettyPrinting() //设定版本号  .setVersion(1.0) //创建 GSON  //...  .create(); 使用 GSON 对象实例 对象 User /* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 10:18:31 */ package com.ichochy.entity; public class User { private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } toJson 方法将对象转换成 JSON 字符串 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.ichochy.example.User; public class Example { public static void main(String[] args) { //创建 GSON 对象  Gson gson = new Gson(); //toJson 将对象转换成 JSON 字符串  String json = gson.toJson(new User()); //{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;}  System.out.println(json); } } fromJson 方法将 JSON 字符串转换成对象 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.ichochy.example.User; public class Example { public static void main(String[] args) { //创建 GSON 对象  Gson gson = new Gson(); // JSON 字符串  String json = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;MLeo\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:35,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;https://ichochy.com\\\u0026#34;}\u0026#34;; //fromJson 将 JSON 字符串转换成对象  User user = gson.fromJson(json,User.class); //Name:MLeo  //Age:35  //URL:https://ichochy.com  } } 集合实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import com.ichochy.example.User; import java.util.ArrayList; import java.util.Collection; import java.util.List; public class Example { public static void main(String[] args) { //创建 GSON 对象  Gson gson = new Gson(); //toJson 将集合转换成 JSON 字符串  List\u0026lt;User\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.add(new User()); data.add(new User()); String json = gson.toJson(data); //[{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;}]  System.out.println(json); //fromJson 将 JSON 字符串转换成集合  //通过 TypeToken 指定类型  List\u0026lt;User\u0026gt; users = gson.fromJson(json, new TypeToken\u0026lt;Collection\u0026lt;User\u0026gt;\u0026gt;(){}.getType()); System.out.println(users); } } 泛型实例 TypeToken 泛型对象 Result /* * File:Result.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/24 10:59:24 */ package com.ichochy.entity; public class Result\u0026lt;T\u0026gt; { private String code = \u0026#34;0000\u0026#34;; private String message = \u0026#34;OK\u0026#34;; private T data; //... } TypeToken 指定泛型 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import com.ichochy.entity.Result; import com.ichochy.entity.User; import java.util.ArrayList; import java.util.List; public class Example { public static void main(String[] args) { //创建 GSON 对象  Gson gson = new Gson(); //toJson 将对象转换成 JSON 字符串  Result result = new Result(); List\u0026lt;User\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.add(new User()); data.add(new User()); result.setData(data); String json = gson.toJson(result); //{\u0026#34;code\u0026#34;:\u0026#34;0000\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;OK\u0026#34;,\u0026#34;data\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;iChochy\u0026#34;,\u0026#34;age\u0026#34;:35,\u0026#34;url\u0026#34;:\u0026#34;https://ichochy.com\u0026#34;}]}  System.out.println(json); //fromJson 将 JSON 字符串转换成对象  //通过 TypeToken 指定类型  Result\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; values = gson.fromJson(json, new TypeToken\u0026lt;Result\u0026lt;List\u0026lt;User\u0026gt;\u0026gt;\u0026gt;(){}.getType()); System.out.println(values); } } SerializedName 注解重命名属性 属性添加注解SerializedName，实现自定义属性名\n对象 User /* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 12:49:22 */ package com.ichochy.entity; import com.google.gson.annotations.SerializedName; public class User { @SerializedName(\u0026#34;userName\u0026#34;) private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.ichochy.entity.User; public class Example { public static void main(String[] args) { //创建 GSON 对象  Gson gson = new Gson() String json = gson.toJson(new User()); /** * { * \u0026#34;userName\u0026#34;: \u0026#34;iChochy\u0026#34;, * \u0026#34;age\u0026#34;: 35, * \u0026#34;url\u0026#34;: \u0026#34;https://ichochy.com\u0026#34; * } */ System.out.println(json); } } FieldNamingPolicy 指定命名规则 配置GSON（setFieldNamingPolicy） Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.IDENTITY).create();    枚举常量 枚举常量和描述     IDENTITY 字段名称不变   LOWER_CASE_WITH_DASHES 字段名称从其驼峰式的形式修改为小写的字段名称，其中每个单词都用短划线（-）分隔   LOWER_CASE_WITH_DOTS 字段名称从其驼峰大小写形式修改为小写的字段名称，其中每个单词都用点（.）分隔   LOWER_CASE_WITH_UNDERSCORES 字段名称从其驼峰式的形式修改为小写的字段名称，其中每个单词都用下划线（_）分隔   UPPER_CAMEL_CASE 字段名称的第一个字母在序列化为JSON格式时大写   UPPER_CAMEL_CASE_WITH_SPACES 字段名称的第一个字母在序列化为JSON格式时大写，并且单词之间将用空格分隔    时间格式 配置GSON（setDateFormat） Gson gson = new GsonBuilder().setDateFormat(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;).create(); /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/12/22 11:48:22 */ package com.ichochy.gson; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import java.util.Date; public class Example { public static void main(String[] args) { //创建 GSON 对象，指定时间格式  Gson gson = new GsonBuilder().setDateFormat(\u0026#34;yyy-MM-dd HH:mm:ss\u0026#34;).create(); String json = gson.toJson(new Date()); //2020-12-24 11:40:45  System.out.println(json); //fromJson 将 JSON 字符串转换成对象  //通过 TypeToken 指定类型  Date values = gson.fromJson(json, Date.class); //Thu Dec 24 11:40:45 CST 2020  System.out.println(values); } } Expose 注解显示属性 配置GSON（excludeFieldsWithoutExposeAnnotation） Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation.create(); 属性添加注解 Expose，显示属性 package com.ichochy.entity; import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; public class User { @Expose private String name = \u0026#34;iChochy\u0026#34;; private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } Since 注解版本支持 配置GSON（setVersion） Gson gson = new GsonBuilder().setVersion(1.0).create(); 属性添加注解 Since，添加版本 package com.ichochy.entity; import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; public class User { @Since(1.1) private String name = \u0026#34;iChochy\u0026#34;; @Since(1.0) private int age = 35; private String url = \u0026#34;https://ichochy.com\u0026#34;; //... } 注：高版本会显示低版本信息\n",
    "pubDate": "2020-10-10T22:22:35+08:00"
  }, 
  {
    "objectID": 20200902,
    "url": "https://ichochy.com/posts/20200902/",
    "title": "MacOS 或 Linux 软件包管理器 Homebrew",
    "summary": "Homebrew 可以方便、快捷的安装第三方软件包，不再需要手动编译安装，通过brew install命令就可以完成软件的安装，包括相关的依赖包。甚至使用brew cask安装macOS应用程序、字体和插件以及其他非开源软件。",
    "content": "Homebrew 可以方便、快捷的安装第三方软件包，不再需要手动编译安装，通过brew install命令就可以完成软件的安装，包括相关的依赖包。甚至使用brew cask安装macOS应用程序、字体和插件以及其他非开源软件。\n安装 Homebrew 终端运行脚体就可以一步安装，非常简单。\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 同时支持MacOS、Linux或Windows的子系统WSL，并不需要管理员（sudo）权限。\n使用 Homebrew 常用命令 brew 搜索可用的软件包\nbrew search [TEXT|/REGEX/] 查看软件包的信息\nbrew info [FORMULA...] 安装软件包\nbrew install FORMULA...  Homebrew会将软件包安装到独立目录/usr/local/Cellar，并将其文件软链接至/usr/local\n 更新brew索引信息\nbrew update 更新软件包\nbrew upgrade [FORMULA...] 卸载软件包\nbrew uninstall FORMULA... 查询本机安装的软件包\nbrew list [FORMULA...] 常用命令 brew cask 查看程序信息\nbrew cask info 安装程序\nbrew cask install 查看程序列表\nbrew cask list 卸载程序\nbrew cask uninstall 更新程序\nbrew cask upgrade 常用命令 brew services 查看当前服务列表\n[sudo] brew services [list]: 运行服务\n[sudo] brew services run (formula|--all): 启动服务，并注册自启动加载\n[sudo] brew services start (formula|--all): 停用服务，并取消自启动加载\n[sudo] brew services stop (formula|--all): 重启服务\n[sudo] brew services restart (formula|--all): 清理无用服务\n[sudo] brew services cleanup: 替换国内源 因为国外网络访问的问题，brew update会出现一直等待中或中断的问题，可以考虑替换国内源，来加快访问速度。下面介绍替换国内源，如：清华大学镜像源、中国科学技术大学镜像源、阿里云镜像源\n清华大学镜像源 https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/\nbrew 替换 git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git Homebrew 替换 # 以下针对 mac OS 系统上的 Homebrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git git -C \u0026#34;$(brew --repo homebrew/cask-fonts)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git git -C \u0026#34;$(brew --repo homebrew/cask-drivers)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/linuxbrew-core.git Homebrew-bottles 替换 临时替换\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles 长期替换\n如果你使用 bash:\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 如果你使用 zsh:\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc Linuxbrew-bottles 替换 临时替换\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/linuxbrew-bottles 长期替换\necho \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/linuxbrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 中国科学技术大学镜像源 https://mirrors.ustc.edu.cn/help/brew.git.html\nBash 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git # 替换homebrew-cask.git: cd \u0026#34;$(brew --repo)\u0026#34;/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile Zsh 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git # 替换homebrew-cask.git: cd \u0026#34;$(brew --repo)\u0026#34;/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc 阿里云镜像源 https://developer.aliyun.com/mirror/homebrew\nBash 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile Zsh 终端配置 # 替换brew.git: cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git # 替换homebrew-core.git: cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git # 应用生效 brew update # 替换homebrew-bottles: echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc 恢复镜像源 brew 恢复 git -C \u0026#34;$(brew --repo)\u0026#34; remote set-url origin https://github.com/Homebrew/brew.git Homebrew 恢复 # 以下针对 mac OS 系统上的 Homebrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-core.git git -C \u0026#34;$(brew --repo homebrew/cask)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask.git git -C \u0026#34;$(brew --repo homebrew/cask-fonts)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask-fonts.git git -C \u0026#34;$(brew --repo homebrew/cask-drivers)\u0026#34; remote set-url origin https://github.com/Homebrew/homebrew-cask-drivers.git # 以下针对 Linux 系统上的 Linuxbrew git -C \u0026#34;$(brew --repo homebrew/core)\u0026#34; remote set-url origin https://github.com/Homebrew/linuxbrew-core.git Homebrew-bottles 恢复 删除~/.bash_profile或~/.zshrc中的HOMEBREW_BOTTLE_DOMAIN环境变量，并执行source，重新加载环境变量。\nsource ~/.bash_profile source ~/.zshrc ",
    "pubDate": "2020-09-02T16:22:35+08:00"
  }, 
  {
    "objectID": 20200828,
    "url": "https://ichochy.com/posts/20200828/",
    "title": "Java 正则表达式实例操作",
    "summary": "Regular Expression正则表达式，简称RegExp，常规通用的表达式，在多个开发语言中都有它的实现，可以通过正则表达式来快速的检索、匹配、查找、替换字符串中的文本。",
    "content": "Regular Expression正则表达式，简称RegExp，常规通用的表达式，在多个开发语言中都有它的实现，可以通过正则表达式来快速的检索、匹配、查找、替换字符串中的文本。\n简单实例 匹配网址\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;https://ichochy.com\u0026#34;; //正则表达式，(.+)代表一个或多个字符  String regex = \u0026#34;https://.+.com\u0026#34;; Boolean flag = Pattern.matches(regex,input); System.out.println(flag); //全文匹配返回：true  } } Matches 方法 Matcher.matches方法，为整块全匹配，字符串完全匹配返回true。\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;https://ichochy.com\u0026#34;; //正则表达式，(.+)代表一个或多个字符  String regex = \u0026#34;https://.+.com\u0026#34;; Pattern pattern = Pattern.compile(regex);//编译表达式  Matcher matcher = pattern.matcher(input);//匹配表达式  System.out.println(matcher.matches());//全文匹配返回：true  } } Find 方法 Matcher.find方法，为查找模式匹配，匹配到就返回true。\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;我的网站是：https://ichochy.com，你知道吗？\u0026#34;; //正则表达式，(.+)代表一个或多个字符  String regex = \u0026#34;https://.+.com\u0026#34;; Pattern pattern = Pattern.compile(regex);//编译表达式  Matcher matcher = pattern.matcher(input);//匹配表达式  System.out.println(matcher.find());//查找匹配返回：true  System.out.println(matcher.matches());//全文匹配返回：false  System.out.println(matcher.find());//再次查找匹配返回：false  matcher.reset();//重置匹配器  System.out.println(matcher.find());//重置查找返回：true  } } find方法多次调用，出现结果不相同的问题：\nThis method starts at the beginning of this matcher's region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match. Matcher.find方法第一次查找匹配成功后，如果Matcher没有重置(Matcher.reset())，则从上一次匹配成功位置的后面开始查找，所以会出现，再次匹配不成功，返回false。\nGroup 分组 正则表达式通过括号分组进行匹配，matcher.group(int group)：通过组序号获取匹配信息\n/* * File:RegExp.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/07 18:11:07 */ package com.ichochy.example; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegExp { public static void main(String[] args) { String input = \u0026#34;我的网站是：https://ichochy.com，你知道吗？\u0026#34;; String regex = \u0026#34;(https://)(.+)(.com)\u0026#34;;//分组表达式  Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(input); if(matcher.find()){//查找匹配成功  //匹配的信息：https://ichochy.com  System.out.println(matcher.group().toString()); //groupCount 组数  for (int i = 0; i \u0026lt; matcher.groupCount(); i++) { //每组匹配的信息，注意：序号是从 1 开始  System.out.println(matcher.group(i+1)); } } } } 正则表达式规则 字符    构造 匹配     x 字符 x   \\ 反斜线字符   \\0n 带有八进制值 0 的字符 n (0 \u0026lt;= n \u0026lt;= 7)   \\0nn 带有八进制值 0 的字符 nn (0 \u0026lt;= n \u0026lt;= 7)   \\0mnn 带有八进制值 0 的字符 mnn（0 \u0026lt;= m \u0026lt;= 3、0 \u0026lt;= n \u0026lt;= 7）   \\xhh 带有十六进制值 0x 的字符 hh   \\uhhhh 带有十六进制值 0x 的字符 hhhh   \\t 制表符('\\u0009')   \\n 新行（换行）符 ('\\u000A')   \\r 回车符 ('\\u000D')   \\f 换页符 ('\\u000C')   \\a 报警 (bell) 符 ('\\u0007')   \\e 转义符 ('\\u001B')   \\cx 对应于 x 的控制符    字符类    构造 匹配     [abc] a、b 或 c（简单类）   [^abc] 任何字符，除了 a、b 或 c（否定）   [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围）   [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集）   [a-z\u0026amp;\u0026amp;[def]] d、e 或 f（交集）   [a-z\u0026amp;\u0026amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去）   [a-z\u0026amp;\u0026amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去）    预定义字符类    构造 匹配     . 任何字符（与行结束符可能匹配也可能不匹配）   \\d 数字：[0-9]   \\D 非数字： [^0-9]   \\s 空白字符：[ \\t\\n\\x0B\\f\\r]   \\S 非空白字符：[^\\s]   \\w 单词字符：[a-zA-Z_0-9]   \\W 非单词字符：[^\\w]    POSIX 字符类（仅 US-ASCII）    构造 匹配     \\p{Lower} 小写字母字符：[a-z]   \\p{Upper} 大写字母字符：[A-Z]   \\p{ASCII} 所有 ASCII：[\\x00-\\x7F]   \\p{Alpha} 字母字符：[\\p{Lower}\\p{Upper}]   \\p{Digit} 十进制数字：[0-9]   \\p{Alnum} 字母数字字符：[\\p{Alpha}\\p{Digit}]   \\p{Punct} 标点符号：!\u0026quot;#$%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?@[]^_`{|}~|   \\p{Graph} 可见字符：[\\p{Alnum}\\p{Punct}]   \\p{Print} 可打印字符：[\\p{Graph}\\x20]   \\p{Blank} 空格或制表符：[ \\t]   \\p{Cntrl} 控制字符：[\\x00-\\x1F\\x7F]   \\p{XDigit} 十六进制数字：[0-9a-fA-F]   \\p{Space} 空白字符：[ \\t\\n\\x0B\\f\\r]    java.lang.Character 类（简单的 java 字符类型）    构造 匹配     \\p{javaLowerCase} 等效于 java.lang.Character.isLowerCase()   \\p{javaUpperCase} 等效于 java.lang.Character.isUpperCase()   \\p{javaWhitespace} 等效于 java.lang.Character.isWhitespace()   \\p{javaMirrored} 等效于 java.lang.Character.isMirrored()    Unicode 块和类别的类    构造 匹配     \\p{InGreek} Greek 块（简单块）中的字符   \\p{Lu} 大写字母（简单类别）   \\p{Sc} 货币符号   \\P{InGreek} 所有字符，Greek 块中的除外（否定）   [\\p{L}\u0026amp;\u0026amp;[^\\p{Lu}]] 所有字母，大写字母除外（减去）    边界匹配器    构造 匹配     ^ 行的开头   $ 行的结尾   \\b 单词边界   \\B 非单词边界   \\A 输入的开头   \\G 上一个匹配的结尾   \\Z 输入的结尾，仅用于最后的结束符（如果有的话）   \\z 输入的结尾    Greedy 数量词    构造 匹配     X? X，一次或一次也没有   X* X，零次或多次   X+ X，一次或多次   X{n} X，恰好 n 次   X{n,} X，至少 n 次   X{n,m} X，至少 n 次，但是不超过 m 次    Reluctant 数量词    构造 匹配     X?? X，一次或一次也没有   X*? X，零次或多次   X+? X，一次或多次   X{n}? X，恰好 n 次   X{n,}? X，至少 n 次   X{n,m}? X，至少 n 次，但是不超过 m 次    Possessive 数量词    构造 匹配     X?+ X，一次或一次也没有   X*+ X，零次或多次   X++ X，一次或多次   X{n}+ X，恰好 n 次   X{n,}+ X，至少 n 次   X{n,m}+ X，至少 n 次，但是不超过 m 次    Logical 运算符    构造 匹配     XY X 后跟 Y   X Y   (X) X，作为捕获组    Back 引用    构造 匹配     \\n 任何匹配的 nth 捕获组    引用    构造 匹配     \\ Nothing，但是引用以下字符   \\Q Nothing，但是引用所有字符，直到 \\E   \\E Nothing，但是结束从 \\Q 开始的引用    特殊构造（非捕获）    构造 匹配     (?:X) X，作为非捕获组   (?idmsux-idmsux) Nothing，但是将匹配标志i d m s u x on - off   (?idmsux-idmsux:X) X，作为带有给定标志 i d m s u x on - off   (?=X) X，通过零宽度的正 lookahead   (?!X) X，通过零宽度的负 lookahead   (?\u0026lt;=X) X，通过零宽度的正 lookbehind   (?\u0026lt;!X) X，通过零宽度的负 lookbehind   (?\u0026gt;X) X，作为独立的非捕获组    总结 可以看到，通过灵活的规则，设计出你想的表达式，来匹配复杂的字符串，从而快速便捷的操作。\n",
    "pubDate": "2020-08-28T15:25:35+08:00"
  }, 
  {
    "objectID": 20200825,
    "url": "https://ichochy.com/posts/20200825/",
    "title": "简述 Cookie、Token、JWT、Session",
    "summary": "早期互联网只是用来访问查看，不需要关心谁在访问查看。HTTP是一种无状态的协议，每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，为了标示用户，就出现了Cookie，而Cookie、Token、JWT 都是用来标示用户的。",
    "content": "早期互联网只是用来访问查看，不需要关心谁在访问查看。HTTP是一种无状态的协议，每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，为了标示用户，就出现了Cookie，而Cookie、Token、JWT 都是用来标示用户的。\nCookie 如：iChochy用户发起访问，服务端为了进行会话跟踪，会为当前用户的访问会话（Session）生成一个会话ID(Session ID)，并通过Set Cookie方式，将Session ID发送给用户的客户端浏览器。客户端自动识别服务端发来的Cookie信息，就会存储在客户端。再次请求时，都带上这个Cookie信息来标示当前用户，服务端自动识别到Cookie信息，就可以判断具体是哪个用户了。\nToken Token是一个令牌，用户登录成功后服务端会生成一个令牌，用来关联会话（Session）信息，如同Cookie，只是需要手动传递。\nJWT JWT是JSON Web Token的简称，可以理解为是Token的升级版本，用户登录成功后服务端会生成的一个很长的字符串，中间用点（.）分隔成三个部分，内容包含Header.Payload.Signature。JWT的不同点就是可以携带具体的用户信息，不再只是标示ID。\nSession Session就是服务端生成的用户会话信息，一般就是用户信息，存储在服务端。\n对比Cookie、Token、JWT    不同点 Cookie Token JWT     标准 系统默认 自定义 自定义   用户标示 包含 包含 包含   跨域 不支持 支持 支持   具信信息 不包含 不包含 包含    关系 关系如下图： 总结 Cookie、Token、JWT都是请求无状态的一种补充，用来标示用户，只是侧重点不同。Cookie是最原始的系统默认标准，前后端都会自动处理Cookie信息，不需要过多的干预。而Token、JWT都是标准的升级和自定义，Token出现解决了Cookie不能跨域的问题，而JWT可以携带具体的用户信息，将用户信息存储在客户端，解决了分布式用户信息存储。\n**Session**是用户会话的具体信息，一般就是用户信息，如ID、Role、Auth等。\n",
    "pubDate": "2020-08-25T11:25:35+08:00"
  }, 
  {
    "objectID": 20200824,
    "url": "https://ichochy.com/posts/20200824/",
    "title": "Java 方法代理实例操作，静态代理、JDK动态代理、CGLIB动态代理",
    "summary": "方法的代理可以在调用方法时进行其它的相关操作，并减少代码的入侵和偶合。很多框架都用到了动态代理，并提供了减化代理操作，如：Spring 的 AOP。",
    "content": "方法的代理可以在调用方法时进行其它的相关操作，并减少代码的入侵和偶合。很多框架都用到了动态代理，并提供了减化代理操作，如：Spring 的 AOP。\n静态代理 以电脑为模型，我们都知道，电脑是由 CPU、GPU、DISK 多个设备组装的，它们都是通过接口相连接。现在模拟一台电脑（Computer）通过接口设备(Device)，代理（Proxy）组装不同的设备（CPU、GPU），并运行（run）。\n接口设备Device /* * File:Device.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:49:31 */ package com.ichochy.proxy; public interface Device { public void run(); } 设备 CPU /* * File:CPU.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:52:31 */ package com.ichochy.proxy; public class CPU implements Device { @Override public void run() { System.out.println(\u0026#34;Game\u0026#34;); } } 设备 GPU /* * File:GPU.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:52:31 */ package com.ichochy.proxy; public class GPU implements Device { @Override public void run() { System.out.println(\u0026#34;Display\u0026#34;); } } 电脑Computer Computer的start方法代理执行接口类方法\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; public class Computer { private Device device; public Device start(){ System.out.println(\u0026#34;Start Computer\u0026#34;); device.run(); return device; } public Device getDevice() { return device; } public void setDevice(Device device) { this.device = device; } } 运行电脑 通过类Computer的start方法代理执行接口类方法\npackage com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import com.ichochy.proxy.GPU; public class App { public static void main(String[] args) { Computer proxy = new Computer(); proxy.setDevice(new CPU()); proxy.start(); proxy.setDevice(new GPU()); proxy.start(); } } 运行情况 Start Computer Game Start Computer Display 小结 静态代理可以代理某个方法，实现AOP操作，代理需求变更只需修改代理类，实现了解偶的效果。但不同的接口多个方法就要重复的编写代理类，来实现方法代理操作。\nJDK动态代理 实现接口InvocationHandler的invoke方法，通过Proxy的newProxyInstance方法，构建代理接口实例。相比静态代理更加灵活，动态代理不同的接口和接口中的方法。\n改进电脑Computer 实现接口InvocationHandler的invoke方法，运用反射，动态执行代理方法\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class Computer implements InvocationHandler { private Device device; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;Start...\u0026#34;); //运用反射，动态执行代理方法，并返回方法执行结果  Object result = method.invoke(device, args); System.out.println(\u0026#34;End\u0026#34;); return result; } public Device getDevice() { return device; } public void setDevice(Device device) { this.device = device; } } 动态运行电脑 通过类Proxy的newProxyInstance方法构建代理接口类，实现方法的代理执行\n/* * File:App.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/01 12:46:01 */ package com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import com.ichochy.proxy.Device; import java.lang.reflect.Proxy; public class App { public static void main(String[] args) throws Exception { CPU cpu = new CPU(); Computer computer = new Computer(); computer.setDevice(cpu); //获取代理接口实例  Device device = (Device) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), cpu.getClass().getInterfaces(), computer); device.run(); } } 运行情况 Start... Game End 小结 运用反射，动态代理可以代理不同的接口的多个方法，不必修改代码。但只能用于接口方法的代理，无法实现所有类方法。\nCGLIB动态代理 CGLIB库是用于生成和转换Java字节码的高级API，它允许运行时对字节码进行修改和动态生成，通过继承方式实现动态代理。\n引入CGLIB库 通过Maven库管理引入第三方CGLIB库\n\u0026lt;!-- https://mvnrepository.com/artifact/cglib/cglib --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 改进电脑Computer 实现接口MethodInterceptor的intercept方法，运用反射，动态执行代理方法（原父类方法）\n/* * File:SimpleProxy.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 17:54:31 */ package com.ichochy.proxy; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class Computer implements MethodInterceptor { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;Start...\u0026#34;); //运用反射，动态执行代理方法，并返回方法执行结果  Object result = methodProxy.invokeSuper(obj, args); System.out.println(\u0026#34;End\u0026#34;); return result; } } 动态运行电脑 通过类Enhancer的create方法构建代理类，实现方法的代理执行\n/* * File:App.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/09/01 12:46:01 */ package com.ichochy; import com.ichochy.proxy.CPU; import com.ichochy.proxy.Computer; import net.sf.cglib.proxy.Enhancer; public class App { public static void main(String[] args) throws Exception { Computer computer = new Computer(); Enhancer enhancer = new Enhancer(); //设置要代理超类  enhancer.setSuperclass(CPU.class); //设置回调处理类  enhancer.setCallback(computer); //构建代理类  CPU cpu = (CPU)enhancer.create(); cpu.run(); } } 运行情况 Start... Game End 小结 通过CGLIB库可以很方便的实现方法的动态代理，实现AOP操作。CGLIB库构建代理类的子类，并重写代理父类的方法，通过执行子类方法实现动态代理操作。\n总结 当我们要对一类方法或所有方法进行相同操作时，运用方法代理可以很好实现我们的需求，并不用去重写以前的业务方法，如：事务处理、日志监控、权限管理、异常捕捉及处理。\n总结：方法代理，实现AOP操作。\n",
    "pubDate": "2020-08-24T16:45:35+08:00"
  }, 
  {
    "objectID": 20200823,
    "url": "https://ichochy.com/posts/20200823/",
    "title": "Java 反射实例操作",
    "summary": "反射可以在代码运行时，动态的获取对象、调用方法、设置属性。动态操作，降低代码偶合性，提高灵活度。其JDBC库就是通过反射加载。",
    "content": "反射可以在代码运行时，动态的获取对象、调用方法、设置属性。动态操作，降低代码偶合性，提高灵活度。其JDBC库就是通过反射加载。\n实例操作 以操作User对象为例:\n/* * File:User.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/31 10:18:31 */ package com.ichochy.example; public class User { private String name = \u0026#34;iChochy\u0026#34;; private int age = 32; private String url = \u0026#34;https://ichochy.com\u0026#34;; public void display(){ System.out.println(\u0026#34;Name:\u0026#34;+name); System.out.println(\u0026#34;Age:\u0026#34;+age); System.out.println(\u0026#34;URL:\u0026#34;+url); } } 正常调用 User user = new User(); user.display(); 获取对象 类动态获取\n//获取类 Class\u0026lt;?\u0026gt; clazz = User.class; //获取对象 Object obj = clazz.newInstance(); 类路径获取\n//获取类 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.ichochy.example.User\u0026#34;); //获取对象 Object obj = clazz.newInstance(); 获取属性 获取全部\nField[] fields = clazz.getDeclaredFields(); for (Field field: fields) { System.out.println(field.getName());//name、age、url } 属性名获取\nField field = clazz.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(field.getName());//age 设置属性 Object obj = clazz.newInstance(); Field field= clazz.getDeclaredField(\u0026#34;age\u0026#34;);//获取私用属性 field.setAccessible(true);//设置反射访问权限检查 System.out.println(field.get(obj)); //32 field.set(obj,18);//设置属性 System.out.println(field.get(obj));//18 获取方法 获取全部\nMethod[] methods = clazz.getMethods(); for(Method method:methods){ System.out.println(method.getName()); //display } 方法名获取\nMethod method = clazz.getMethod(\u0026#34;display\u0026#34;); System.out.println(method.getName()); //display 调用方法 Object obj = clazz.newInstance(); Method[] methods = clazz.getMethods(); for(Method method:methods){ //调用 display 方法  if(\u0026#34;display\u0026#34;.equals(method.getName())){ method.invoke(obj); } } 方法名调用\nObject obj = clazz.newInstance(); Method method = clazz.getMethod(\u0026#34;display\u0026#34;); method.invoke(obj); ",
    "pubDate": "2020-08-23T16:45:35+08:00"
  }, 
  {
    "objectID": 20200822,
    "url": "https://ichochy.com/posts/20200822/",
    "title": "Vercel 上自动部署你的个人博客 Hugo",
    "summary": "Vercel 可以依托 Git仓库 ，在线自动构建和发布Web静态项目，支持自定义域名，可以自动签发SSL证书，开启HTTPS，还有一个特点，拥有全球CDN，国内速度不错。",
    "content": "Vercel 可以依托 Git仓库 ，在线自动构建和发布Web静态项目，支持自定义域名，可以自动签发SSL证书，开启HTTPS，还有一个特点，拥有全球CDN，国内速度不错。\n支持多套框架和模版，如：Hugo、Jekyll、Hexo、Next、Vue\u0026hellip;\n注册账号 通过Git仓库账号关联注册，如果注册中出现错误，检查下账号是不是QQ邮箱。 Vercel不支持QQ邮箱，以GitHub为例，可以修改GitHub的默认邮箱。\nGitHub -\u0026gt; Settings -\u0026gt; Emails -\u0026gt; Primary email address 导入项目 输入你的项目地址 选择你的账户 在线安装Vercel 授权Vercel，选择授权项目\nGitHub -\u0026gt; Settings -\u0026gt; Applications -\u0026gt; Vercel -\u0026gt; Configure 导入项目，选择项目框架 部署项目 导入项后会自动构建、发布项目，直接访问: https://ichochy.com/\n下次提交代码到Git仓库，Vercel不用任何操作，就可以直接自动构建和发布项目\n自定义域名 直接添加已有的域名，域名商管理系统配置域名记录，等待生效。\nVercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Domains 生效后会自动签发SSL证书，开启HTTPS 指定 Hugo 版本 在项目的环境变量中添加Hugo版本\nVercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Environment Variables HUGO_VERSION 0.74.2 完成后重新发布\nBuild Logs 12:21:18.550 Cloning github.com/iChochy/iChochy.github.io (Branch: master, Commit: a169de0) 12:21:19.212 Cloning completed in 662ms 12:21:19.213 Analyzing source code... 12:21:19.799 Installing build runtime... 12:21:20.194 Build runtime installed: 394.753ms 12:21:20.575 Looking up build cache... 12:21:20.638 Build cache found. Downloading... 12:21:20.647 Build cache downloaded [206.00 B]: 8.14ms 12:21:21.022 Installing Hugo version 0.74.2 12:21:23.078 Installing dependencies... 12:21:23.290 yarn install v1.22.4 12:21:23.302 info No lockfile found. 12:21:23.306 [1/4] Resolving packages... 12:21:23.306 [2/4] Fetching packages... 12:21:23.309 [3/4] Linking dependencies... 12:21:23.312 [4/4] Building fresh packages... 12:21:23.315 success Saved lockfile. 12:21:23.316 Done in 0.03s. 12:21:23.515 Building sites … 12:21:23.515 | EN 12:21:23.515 -------------------+------ 12:21:23.515 Pages | 109 12:21:23.515 Paginator pages | 4 12:21:23.515 Non-page files | 0 12:21:23.515 Static files | 13 12:21:23.515 Processed images | 0 12:21:23.515 Aliases | 1 12:21:23.515 Sitemaps | 1 12:21:23.515 Cleaned | 0 12:21:23.515 Total in 162 ms 12:21:23.776 Uploading build outputs... 12:21:31.360 Build completed. Populating build cache... 12:21:31.457 Uploading build cache [220.00 B]... 12:21:31.614 Build cache uploaded: 156.776ms 12:21:31.620 Done with \u0026quot;config.toml\u0026quot; ",
    "pubDate": "2020-08-22T13:22:35+08:00"
  }, 
  {
    "objectID": 20200820,
    "url": "https://ichochy.com/posts/20200820/",
    "title": "Java 中的重写(Override)与重载(Overload)",
    "summary": "Java 是一个面向对象编程的语言，我们就以面向对象的方式来解释下重写(Override)与重载(Overload)。子类存在父类名字相同的方法，而参数的个数与类型一样，返回值也一样的方法，就称为方法的重写（Override）。同类中定义了多个名字相同的方法，但他们的参数数量不同或数量相同而类型和次序不同，则称为方法的重载(Overload)。",
    "content": "Java 是一个面向对象编程的语言，我们就以面向对象的方式来解释下重写(Override)与重载(Overload)。子类存在父类名字相同的方法，而参数的个数与类型一样，返回值也一样的方法，就称为方法的重写（Override）。同类中定义了多个名字相同的方法，但他们的参数数量不同或数量相同而类型和次序不同，则称为方法的重载(Overload)。\n重写(Override) 重写出现在继承中，子类重新编写父类的方法，改写父类现有的方法，方法相同而不相似。如：你继承了你爸的房子，用来装修婚房，按照自己想法去装修，完成后外表起来没有什么变化，可内部的格局已经发生了变化。\n重写代码实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/25 22:33:25 */ package com.ichochy.example; public class Example { public static class Father{ public void house(){ System.out.println(\u0026#34;father house\u0026#34;); } } public static class Child extends Father{ /** * 重写父类方法，方法名、参数完全相同 */ @Override public void house() { super.house();//调用父类 house 方法  System.out.println(\u0026#34;child house\u0026#34;); } } public static void main(String[] args) { new Father().house(); System.out.println(\u0026#34;################\u0026#34;); new Child().house(); } } 重载(Overload) 重载出现在同类中，重新编写一个新的方法，改进现有的方法，方法相似而不相同。如：你要修建一套房子，可以借鉴别人建房子的经验来建造自己的房子，格局相似而不相同。\n重载代码实例 /* * File:Example.java * User:iChochy * URL:https://ichochy.com * Copyright (c) 2020 * Date:2020/08/25 22:33:25 */ package com.ichochy.example; public class Example { public void house(){ System.out.println(\u0026#34;house\u0026#34;); } /** * 重载同类方法，方法名相同，而参数不相同 * @param name */ public void house(String name) { this.house(); System.out.println(name+\u0026#34; house\u0026#34;); } public static void main(String[] args) { new Example().house(); System.out.println(\u0026#34;################\u0026#34;); new Example().house(\u0026#34;iChochy\u0026#34;); } } 对比    对比 重写 重载     方法名字 相同 相同   方法参数 相同 不相同   返回值 相同 可以不相同   范围 子类中 同类或子类中    总结 方法的重写是有严格的定义，子类重写父类的方法，是自我型态表达，形成 Java 中多态的特性。而方法的重载没有严格的定义，就是个不同的方法，只是名字相同而已。\n",
    "pubDate": "2020-08-20T11:22:35+08:00"
  }, 
  {
    "objectID": 20200819,
    "url": "https://ichochy.com/posts/20200819/",
    "title": "免费申请 JetBrains 开源开发许可证，包含 IDEA",
    "summary": "如果您是开源项目的负责人或核心贡献者，就可以申请 JetBrains 所有产品的License，用于您的项目开发。",
    "content": "如果您是开源项目的负责人或核心贡献者，就可以申请 JetBrains 所有产品的License，用于您的项目开发。\n免费许可计划 开源项目：\n 符合Open Source 定义。 正在积极开发中，即在过去3个月内定期提交新的代码提交。 请勿在开源项目周围提供付费版本的开源软件或任何商业服务（例如，付费支持，咨询等）。 不由商业公司或组织（非政府组织，教育，研究或政府）资助。 不付钱给他们的核心项目开发商。  支持条款：\n 许可证仅提供给项目负责人和核心项目提交者。 许可证的有效期为一年，如果您的项目仍符合支持计划的要求，则可以续签。 您可以将免费许可证仅用于开发非商业性开源项目。 您不得与任何第三方共享免  说明：有个公开项目，并添加开源License，近三个月有代码的提交和维护。\n申请开发许可 申请地址：https://www.jetbrains.com/shop/eform/opensource\n填写开源项目信息和个人信息，提交审核后，等待一周左右的时间，审核结果会有邮件回复。通过会有License信息，如果没有通过也会有相关说明。\n",
    "pubDate": "2020-08-19T22:22:25+08:00"
  }, 
  {
    "objectID": 20200818,
    "url": "https://ichochy.com/posts/20200818/",
    "title": "重疾保险理赔的亲身经历，分享下流程和套路",
    "summary": "相信很多人都为自己和家人购买过保险，特别是重疾险。常说保险就是一种保障，可以让你的家庭不会因为高昂的医药费而操心，有病没钱治。",
    "content": "相信很多人都为自己和家人购买过保险，特别是重疾险。常说保险就是一种保障，可以让你的家庭不会因为高昂的医药费而操心，有病没钱治。\n购买保险时，都会很轻松，交钱，签字就完事了。可是到了理赔时就会发现没有那么轻松了，在国内保险都是一种宽进严出的处理方式，购买时什么都赔，理赔时给人感觉这也不赔那也不赔。前段时间看到网上很多退保的，买十万，保五万，所以购买时要看清条款和健康告知。\n理赔经历 下面就来说说我的理赔经历：\n首先是提交理赔申请，将个人信息和诊断证明提交，通过初审。\n然后会有专门的理赔员上门对接审查，购买时轻松带过的健康告知，现在开始认真审查起来了，看有没有不符合条款的。询问你的病情的起因，条款一条一条的询问，细细审查，全程录音，并做好笔录签字确认，犹如审判一样，反正给人的感觉不太好（有个很大的疑问：为什么购买保险前不去细细的审查，看看是否符合购买保险的条款，不符合就直接拒保，就没有后面什么事情了）。\n随后会要求调取你的医保流水记录，并配合去各个医院调取你近年来的就医记录，并详细询问就医情况、用药情况，不明确的要找主治医生确认，不漏掉每一个细节，没有什么隐私可言，只能说理赔审查还是很严苛，骗保的可能性不大。\n接下来就开始总结和理赔，不管你是不是初次确诊，只要你之前有相关症状可以人为判断的，就可以不赔，如：长期感冒，感染可能就是某重疾的症状，可以不赔，或协商赔偿，这其中就没有明确的界限，哈哈。\n确认好理赔方案后，签字确认，等待审核，然后就是漫长的等待赔款。\n总结 购买保险时一定要看清条款和如实的健康告知，不然理赔时就可能拒绝赔付。衷心希望大家不需要理赔，合理的安排作息和饮食，有个健康的体魄。\n",
    "pubDate": "2020-08-18T12:22:25+08:00"
  }, 
  {
    "objectID": 20200815,
    "url": "https://ichochy.com/posts/20200815/",
    "title": "Java 开发环境的搭建，开启你的编程之旅",
    "summary": "Java 是一门跨平台的高级程序设计语言，可运行在linux、Windows、Mac OS及其他多种UNIX版本的系统。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等",
    "content": "Java 是一门跨平台的高级程序设计语言，可运行在linux、Windows、Mac OS及其他多种UNIX版本的系统。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等\nJava 版本 Java Platform, Standard Edition (Java SE) Java SE 使您可以在台式机和服务器上开发和部署Java应用程序。Java SE和组件技术提供了当今应用程序所需的丰富的用户界面，性能，多功能性，可移植性和安全性。\nJava Platform, Enterprise Edition (Java EE) Java EE 提供了一个API和运行时环境，用于开发和运行大型，多层，可靠且安全的企业应用程序，这些应用程序具有可移植性和可伸缩性，并且可以轻松地与旧版应用程序和数据集成。\nJava Embedded Java ME Embedded 专为资源受限的设备而设计，例如用于M2M的无线模块，工业控制，智能电网基础设施，环境传感器和跟踪等。\nJRE 与 JDK 1、JRE（Java Runtime Environment） JRE顾名思义是Java运行时环境，包含了Java虚拟机，Java基础类库。是使用Java语言编写的程序运行所需要的软件环境，是提供给想运行Java程序的用户使用的。JRE根据不同操作系统（如：Windows，Linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本，最常用的是Oracle公司收购Sun公司的JRE版本。\n2、JDK（Java Development Kit） JDK顾名思义是java开发工具包，是程序员使用Java语言编写Java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译Java源码的编译器javac，还包含了很多Java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了Java程序编写所需的文档和demo例子程序。如果你需要运行Java程序，只需安装JRE就可以了。如果你需要编写Java程序，需要安装JDK。\n安装步骤 下载 JDK Java 官网：https://www.oracle.com/java/\n在Java下载页面 选择Java版本，然后选择自己系统的安装包下载，并完成安装\n配置环境变量 JAVA_HOME:JDK安装路径位置\nPATH：JDK命令目录位置（jdk\\bin)\nCLASSPATH：类库文件位置（jdk\\lib）\nJava 版本查询 运行 Java 版本命令，检查是否安装成功\njava -version # java 版本信息 java version \u0026#34;1.8.0_162\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode) 运行代码 创建文件 touch HelloWorld.java 写入代码 /** * 通过 Class 定义类 * https://ichochy.com */ public class HelloWorld{ //编写 main 方法，程序中唯一的入口方法  public static void main(String args[] ){ //打印输出 Hello World  System.out.println(\u0026#34;Hello World\u0026#34;); System.out.println(\u0026#34;https://ichochy.com\u0026#34;); } } 编译代码 使用编译器javac命令，对源代码文件进行编译操作，产生.class文件。\n该文件是 Java 的字节码文件，Java 虚拟机执行文件，与系统平台无关\njavac HelloWorld.java 运行代码 使用 java命令对.class文件进行解释运行。\njava HelloWorld # 运行结果 Hello World https://ichochy.com 注意：使用java解释时，不需要带.class后缀\n",
    "pubDate": "2020-08-15T11:13:25+08:00"
  }, 
  {
    "objectID": 20200810,
    "url": "https://ichochy.com/posts/20200810/",
    "title": "HUGO 目录详解，创建自己的网站系统",
    "summary": "HUGO 是一套模版静态化的系统，了解其目录结构有助于创建我们的网站系统",
    "content": "HUGO 是一套模版静态化的系统，了解其目录结构有助于创建我们的网站系统\n目录结构 以Hyde主题为例，完整的目录结构如下：\niChochy ├── archetypes 内容模版目录 │ └── default.md 模版文件 ├── config.toml 配置文件 ├── content 内容目录 ├── data 数据目录 ├── layouts 网站模版目录 ├── static 静态文件目录 └── themes 主题目录 └── hyde Hyde主题目录 ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes 内容模版 │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts 网站模版 │ ├── 404.html 404面目模版 │ ├── _default 默认模版目录 │ │ ├── baseof.html 基础模版 │ │ ├── list.html 列表页面模版 │ │ └── single.html 单页面模版 │ ├── index.html 首页模版 │ └── partials 模块模版目录 │ ├── head.html HEAD模块模版 │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static 静态目录 │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 主题配置文件 archetypes 内容模版目录，通过内容模版，使用hugo new命令创建新的内容文件\ndefault.md 内容模版\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} categories: - iChochy tags: - iChochy --- 使用命令：hugo new posts/iChochy.md，生成内容文件 content/posts/iChochy.md\n--- title: \u0026#34;iChochy\u0026#34; date: 2020-08-10T18:13:25+08:00 categories: - iChochy tags: - iChochy --- config.toml 项目的配置文件，列举些常用的参数。如下：\n# 基础参数，通过.Site.xxxx获取参数 # 网站标题 title = \u0026#34;回忆中的明天\u0026#34; # 域名地址 baseURL = \u0026#34;https://ichochy.com/\u0026#34; # 主题名称 theme = \u0026#34;hyde\u0026#34; # 网站的语言代码 languageCode = \u0026#34;zh_CN\u0026#34; # 启用以将相对URL变为绝对URL canonifyURLs = false # Hugo 生成静态站点的目录 publishDir = \u0026#34;docs\u0026#34; # 启用生成robots.txt文件 enableRobotsTXT = false # 启用自动检测内容中的中文/日语/韩语，让.Summary和.WordCount对于CJK语言正确运行 hasCJKLanguage = false # 指定.Summary 的长度 summaryLength = 70 # 默认分页数 paginate = 10 # 启用.html后缀地址，默认URL为/filename/，启用为/filename.html uglyurls = false # 自定义参数，通过.Site.Params.xxxx获取参数 [params] postDir = \u0026#34;posts\u0026#34; layoutReverse = false copyright = \u0026#34;iChochy\u0026#34; description = \u0026#34;码农小站，写点Java、Swift和感悟\u0026#34; # 菜单参数，通过.Site.Menus.main获取参数 # Name为菜单名称、Weight为菜单排序参数、URL为菜单名称 [Menus] main = [ {Name = \u0026#34;Categories\u0026#34;, Weight = 1, URL = \u0026#34;/categories/\u0026#34;}, {Name = \u0026#34;Tags\u0026#34;, Weight = 2, URL = \u0026#34;/tags/\u0026#34;}, {Name = \u0026#34;Links\u0026#34;, Weight = 3, URL = \u0026#34;/links/\u0026#34;}, {Name = \u0026#34;About\u0026#34;, Weight = 4, URL = \u0026#34;/about/\u0026#34;}, {Name = \u0026#34;Feedback\u0026#34;, Weight = 5, URL = \u0026#34;/feedback/\u0026#34;} ] content 内容目录，网站的MD源文件，通过对应的模版生成静态文件\ndata 数据目录，存储结构数据，可以用YAML，JSON或TOML格式编写数据文件，可用.Site.Data.xxxx的方式来获取数据\nlayouts 模版目录，以.html文件形式存储模板，这些模板指定如何将内容目录中的源文件呈现到静态网站中\n模版包括：主页模版、单页模板、列表模版、分类模版、模块模版等\nstatic 静态文件目录，存储所有静态内容，如：Image，CSS，JavaScript等\n当Hugo建立您的网站时，静态目录内的所有文件均按原样复制生成，可有来存储效验文件、CNAME文件等\n",
    "pubDate": "2020-08-10T18:13:25+08:00"
  }, 
  {
    "objectID": 20200807,
    "url": "https://ichochy.com/posts/20200807/",
    "title": "了解 JS 的加载顺序和方式，实现 Ready 方法",
    "summary": "页面加载 JS 顺序或方式不同，可能会导致功能失效、错误的产生或加载解析时间过长，拖慢整个页面展示。",
    "content": "页面加载 JS 顺序或方式不同，可能会导致功能失效、错误的产生或加载解析时间过长，拖慢整个页面展示。\n了解 JS 的加载顺序 了解页面元素的加载顺序，找到 JS 执行失败原因。有时明明没有问的代码，可就获取不到元素值或信息，这可能是JS执行时间过早或过晚，而导致的 JS 执行失败。\n我们来看一幅图，了解defer、async属性对JS下载、执行顺序的影响  默认情况下，浏览器解析到JS文件就会立即下载文件，并执行文件，JS提前执行，获取不到页面元素，并导致页面解析中断，拖慢整个页面的加载。 添加async属性后，就会异步下载JS文件并执行，执行时间不可控，JS执行时间过早或过晚，而导致的 JS 执行错误或失败。 添加defer属性后，就会异步下载JS文件，等页面解析完成后再执行JS  Ready方法的实现 很多时候我们不把JS放在head中，而把JS放到body的最后面也就很好解释了？\n 首先，JS的下载和执行会中断页面的解析，拖慢整个页面展示， 然后，放在head中，页面元素还没有加载，JS方法就无法获取或处理页面上的元素，这一点很容易忽视， 但是，我们还有ready方法。  jQuery中的ready方法会在页面解析后运行，语法如下：\n//语法 1 $(document).ready(function) //语法 2 $().ready(function) //语法 3 $(function) 自定义方法，通过监听DOMContentLoaded实现ready方法\n/** * 页面解析后执行 fn * https://ichochy.com  * / function ready(fn) { if (window.addEventListener) { window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { //注销时间，避免重复触发  document.removeEventListener(\u0026#39;DOMContentLoaded\u0026#39;, arguments.callee, false); fn(); //运行函数  }, false); } else if (document.attachEvent) { //IE浏览器  document.attachEvent(\u0026#39;onreadystatechange\u0026#39;, function () { if (document.readyState == \u0026#39;complete\u0026#39;) { document.detachEvent(\u0026#39;onreadystatechange\u0026#39;, arguments.callee); fn(); //函数运行  } }); } } 当然还有我的onload方法，可以在页面完成所有加载后再执行\n//window 的 onload window.onload = function(){ //load https://ichochy.com  //some things …… } //body 的 onload \u0026lt;body onload=\u0026#34;load()\u0026#34;\u0026gt; 总结 可以看到，JS的执行顺序决定着程序是否正常工作。加载过早，可能无法获取到页面元素，而太晚，页面元素无法交互。对于执行的顺序，要以当前的程序功能而定。\n",
    "pubDate": "2020-08-07T16:13:25+08:00"
  }, 
  {
    "objectID": 20200802,
    "url": "https://ichochy.com/posts/20200802/",
    "title": "免费创建属于自己的博客，Hugo+Github Pages",
    "summary": "Hugo 拥有超快的速度，强大的内容管理和强大的模版语言，使其非常适合各种静态网站。可以轻松安装在macOS，Linux，Windows等平台上，在开发过程中使用LiveReload可即时渲染更改",
    "content": "Hugo 拥有超快的速度，强大的内容管理和强大的模版语言，使其非常适合各种静态网站。可以轻松安装在macOS，Linux，Windows等平台上，在开发过程中使用LiveReload可即时渲染更改\n一、安装 Hugo Mac 上安装 HUGO，很简单，通过 brew 可以快速安装\nbrew install hugo 检查安装版本信息\nhugo version 二、使用 Hugo 1、创建网站 hugo new site iChochy 创建\n 其中 iChochy 为你的博客目录\n 目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 2、添加主题 a、下载主题 以 hyde主题为例 https://github.com/spf13/hyde\n直接下载主题，放到themes目录中，或通过 git 方式添加主题\ngit submodule add https://github.com/spf13/hyde.git themes/hyde b、修改配置 echo \u0026#39;theme = \u0026#34;hyde\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml config.toml 文件内容\nbaseURL = \u0026#34;https://ichochy.com/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;hyde\u0026#34; 目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 3、编写内容 新建文章 hugo new posts/HelloWorld.md 新建\n注：以 archetypes/default.md为模版创建\n编写文章 vim content/posts/HelloWorld.md HelloWorld.md 文件内容\n--- title: \u0026#34;HelloWorld\u0026#34; date: 2020-08-02T21:47:48+08:00 draft: true --- ### HelloWorld  https://ichochy.com 预览文章 hugo server -D 启动服务，访问 http://localhost:1313\n目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content │ └── posts │ └── HelloWorld.md ├── data ├── layouts ├── resources │ └── _gen │ ├── assets │ └── images ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 部署 修改部署目录 修改 config.toml 文件\n1、修改 bashURL 的部署域名\n2、添加 publishDir = \u0026quot;docs\u0026quot;，指定部署目录为 docs\nconfig.toml 文件内容\nbaseURL = \u0026#34;https://ichochy.com/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;hyde\u0026#34; publishDir = \u0026#34;docs\u0026#34; 生成静态文件 hugo -D 生成静态文件\n目录结构\niChochy ├── archetypes │ └── default.md ├── config.toml ├── content │ └── posts │ └── HelloWorld.md ├── data ├── docs │ ├── 404.html │ ├── apple-touch-icon-144-precomposed.png │ ├── categories │ │ ├── index.html │ │ └── index.xml │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ ├── favicon.png │ ├── index.html │ ├── index.xml │ ├── posts │ │ ├── helloworld │ │ │ └── index.html │ │ ├── index.html │ │ └── index.xml │ ├── sitemap.xml │ └── tags │ ├── index.html │ └── index.xml ├── layouts ├── resources │ └── _gen │ ├── assets │ └── images ├── static └── themes └── hyde ├── CHANGELOG.md ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── go.mod ├── images │ ├── screenshot.png │ └── tn.png ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ └── single.html │ ├── index.html │ └── partials │ ├── head.html │ ├── head_fonts.html │ ├── hook_head_end.html │ └── sidebar.html ├── static │ ├── apple-touch-icon-144-precomposed.png │ ├── css │ │ ├── hyde.css │ │ ├── poole.css │ │ ├── print.css │ │ └── syntax.css │ └── favicon.png └── theme.toml 部署 GitHub Pages 将整个项目推送到 GitHub，然后在项目的 Settings 中开启的 GitHub Pages，并指定分支和目录 docs 就是可以直接在线访问了，如：https://ichochy.github.io\n总结 Hugo 简单、易用、快速\n模版化强大，只需要关心文章的编写\n默认开启 LiveReload，修改后可以实时预览，免去手去刷新操作\n还有很多强大的功能，如：摘要(Summary)、文章目录(TableOfContents)、相关推荐(Related)、多语言支持(i18n)、列表分页(Pagination)、简码(Shortcodes)等。\n",
    "pubDate": "2020-08-02T13:13:25+08:00"
  }, 
  {
    "objectID": 20200710,
    "url": "https://ichochy.com/posts/20200710/",
    "title": "Elastic Stack 实现日志的自动采集、搜索和分析",
    "summary": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化",
    "content": "Elastic Stack 包括 Elasticsearch、Kibana、Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎\nKibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化管理和展示\nBeats 是一个免费且开放的平台，集合了多种单一用途数据采集器，将数据发送给 Logstash 或 Elasticsearch\nLogstash 是一个免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中\n一、下载镱像(image) 搜索镱像(image)\ndocker search elasticsearch docker search kibana docker search logstash 获取镱像(image)\ndocker pull elasticsearch:7.6.0 #镜像名称:Tag docker pull kibana:7.6.0 #镜像名称:Tag docker pull logstash:7.6.0 #镜像名称:Tag 注：版本要统一\n二、创建 ELK.yml ELK.yml\nversion: \u0026#34;3.5\u0026#34; services: elasticsearch: container_name: elasticsearch image: elasticsearch:7.6.0 #镱像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana image: kibana:7.6.0 #镱像(image) restart: always #重启方式 environment: I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 logstash: container_name: logstash image: logstash:7.6.0 restart: always volumes: #文件夹映射，本地:容器 - \u0026#34;/Users/iChochy/logs:/usr/share/logstash/logs\u0026#34; ports: - \u0026#34;5044:5044\u0026#34; - \u0026#34;9600:9600\u0026#34;  volumes自定义监控的文件夹\n**注：**注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败\n # 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here 三、运行容器 宿主机hosts中添加\n127.0.0.1 elasticsearch 命令启动\ndocker-compose -f ELK.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 四、检查容器的运行状态 elasticsearch 访问：http://127.0.0.1:9200\nlogstash 访问：http://127.0.0.1:9600\nKibana 访问：http://127.0.0.1:5601，进入 Kibana\n运行docker ps查询容器运行状态，可以查看到容器的ID\nmleo$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b8cb2effede logstash:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 2 hours ago Up About an hour 0.0.0.0:5044-\u0026gt;5044/tcp, 0.0.0.0:9600-\u0026gt;9600/tcp logstash 69b8bc678e4e kibana:7.6.0 \u0026#34;/usr/local/bin/dumb…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:5601-\u0026gt;5601/tcp kibana 8c655f5b7493 elasticsearch:7.6.0 \u0026#34;/usr/local/bin/dock…\u0026#34; 3 weeks ago Up 2 hours 0.0.0.0:9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp elasticsearch 运行docker logs id查看容器运行日志\n例：持续查看logstash日志 docker logs 1b8cb2effede -f 五、修改logstash配置，监控日志文件  运行docker exec -it 1b8cb2effede bash进入logstash 运行vi pipeline/logstash.conf修改logstash默认配置  input { beats { port =\u0026gt; 5044 } file { path =\u0026gt; \u0026#34;/usr/share/logstash/logs/*\u0026#34; #监控的文件路径 } } output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;http://elasticsearch:9200\u0026#34;] #elasticsearch请求地址 index =\u0026gt; \u0026#34;ichochy\u0026#34; #索引名称 } }  运行docker restart 1b8cb2effede重启 logstash  六、采集日志 在logstash的监控的文件路径下动态添加日志文件，日志就可以自动采集到 elasticsearch\ntouch web.log #创建日志文件 echo \u0026quot;www.ichochy.com\u0026quot; \u0026gt; web.log #添加日志信息 查看 logstash 日志信息可以看到打印的日志\n{ \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;path\u0026#34; =\u0026gt; \u0026#34;/usr/share/logstash/logs/web.log\u0026#34;, \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;1b8cb2effede\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2020-07-10T14:07:16.633Z, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;www.ichochy.com\u0026#34; } 七、搜索、分析日志 访问：http://127.0.0.1:5601，进入 Kibana\n在Discover可以看到刚刚添加进来的日志数据，开始表演…………\n",
    "pubDate": "2020-07-10T15:28:45+08:00"
  }, 
  {
    "objectID": 20200622,
    "url": "https://ichochy.com/posts/20200622/",
    "title": "个人站长的加速器 - 百度云加速",
    "summary": "免费申请20个SSL证书，支持HTTPS；多CDN节点，国内外加速，每天10G流量；3条特定页面规则；等",
    "content": "免费申请20个SSL证书，支持HTTPS；多CDN节点，国内外加速，每天10G流量；3条特定页面规则；等\n套餐对比：https://su.baidu.com/plan.html#compare\n一、域名接入   NS接入方式（推荐）\n一劳永逸，NS方式可以使用百度高智能DNS服务\n  CNAME接入方式\n简单快捷、生效迅速，每个子域名都需要单独设置CNAME解析\n  二、管理子域名，开启CDN 添加子域名解析，默认开启小云朵\n三、申请SSL证书 百度云加速为方便用户使用HTTPS服务，联合知名CA证书厂商，推出了证书申请服务。证书申请成功后可以直接部署到CDN节点，实现一键HTTPS加密。\n云加速为用户提供了两类证书：\n  专有证书： 可以为指定的域名申请独享的证书，在用户侧证书显示的是网站真实的域名。目前只要您的域名接入云加速，即可以免费为域名申请此类SSL证书。单个域名最多可以申请20个子域证书（包括在其他渠道申请的数量，不支持泛域申请），每个证书的有效期为1年。\n  通用证书： 可以为主域的所有子域名申请SSL证书，在用户侧证书显示的是统一的非本域名名称。此类证书可申请的子域名证书个数没有限制，仅限收费版套餐使用。\n  四、开启全站HTTPS  关闭：暂停HTTPS访问和加速，支持HTTP访问和加速。 半程加密：仅在网民到CDN节点的访问采用HTTPS服务。 全程加密：网民到CDN节点和CDN节点到源站都采用HTTPS服务。但是不校验源站证书。\n须源站开通并支持SSL，同时支持自签名证书和受信任的CA签发的证书。 严格加密：网民到CDN节点和CDN节点到源站都采用HTTPS服务。且校验源站证书。\n须源站开通并支持SSL，只支持受信任的CA签发的证书。  五、其它，跳转HTTPS 特定页面规则-实现跳转HTTPS，*为通配符，$为变量\n六、总结 对于个人来说，已经基本够用了，就是个人认证需要手持身份证，多节点CDN速度很稳定，全国有7个节点\n送上邀请地址：https://su.baidu.com/?ic=1dR4jc\n",
    "pubDate": "2020-06-22T12:22:45+08:00"
  }, 
  {
    "objectID": 20200605,
    "url": "https://ichochy.com/posts/20200605/",
    "title": "Office 批量激活的命令工具 slmgr",
    "summary": "软件许可证管理器脚本用于配置和检索 Office KMS 主机和 Windows 主机的批量激活信息。",
    "content": "软件许可证管理器脚本用于配置和检索 Office KMS 主机和 Windows 主机的批量激活信息。\n适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\nslmgr.vbs 脚本 您可以在目标计算机上以本地方式运行脚本，或从另一台计算机中以远程方式运行。您必须是管理员才能使用此脚本。如果标准用户运行 slmgr.vbs，则某些许可证数据可能缺失或不正确，并且许多操作将被禁止。\nslmgr.vbs 脚本可以使用基于 Windows 的脚本主机 wscript.exe 或基于命令的脚本主机 cscript.exe，管理员可以指定要使用的脚本引擎。如果未指定脚本引擎，slmgr.vbs 将使用默认脚本引擎 wscript.exe 运行。我们建议使用 cscript.exe 脚本引擎。\n您必须重新启动软件授权服务才能使任何更改生效。若要重新启动软件授权服务，请使用 Microsoft 管理控制台 (MMC) 服务管理单元或运行以下命令：\nnet stop sppsvc \u0026amp;\u0026amp; net start sppsvc slmgr.vbs 脚本需要至少一个参数。如果您运行不带任何参数的脚本，则会显示帮助信息。下表列出了 slmgr.vbs 的命令行选项以及每个选项的说明。该表中的大多数参数都用于配置 KMS 主计算机。不过，参数 /sai 和 /sri 是在 KMS 客户端与 KMS 主计算机联系后才传递给 KMS 客户端。\nslmgr.vbs 的常规语法如下所示（假定所使用的脚本引擎为 cscript.exe）： cscript slmgr.vbs /parameter cscript slmgr.vbs [ComputerName] [User] [Password] [Option] ComputerName ：远程计算机的名称。如果您不提供计算机名称，则使用本地计算机。\nUser：远程计算机上具有所需权限的帐户。\nPassword ：帐户的密码。如果您不提供用户帐户和密码，则使用当前凭据。\nOption：选项显示在下表中。\nSlmgr.vbs 命令选项    选项 说明     / ipk [ProductKey] 为 Windows（默认设置）或由产品密钥标识的其他应用程序安装产品密钥。   / ato [ActivationID] 激活 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主机。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。   / dti [ActivationID] 显示用于 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主计算机的电话激活的安装 ID。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 在电话中输入安装 ID 以接收确认 ID，该 ID 用于使用 /atp 参数激活 KMS 主机。   / atp [ConfirmationID][ActivationID] 收到确认 ID 后，激活 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的 KMS 主机。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。   / dlv [ActivationID] 显示有关 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的详细许可证信息。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。例如，在提升的命令符处运行以下命令，在 C:\\windows\\system32 文件夹中获取 Office KMS 主机的状态：cscript slmgr.vbs /dlv 70512334-47B4-44DB-A233-BE5EA33B914C   / dli [ActivationID] 显示有关 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的许可证信息。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。   / upk [ActivationID] 卸载 Windows（默认设置）或由激活 ID（如果提供）标识的应用程序的产品密钥。 Office 2019 激活 ID 为 70512334-47B4-44DB-A233-BE5EA33B914C，Office 2016 激活 ID 为 98EBFE73-2084-4C97-932C-C0CD1643BEA7。 警告： 如果打算卸载 Office 产品密钥，并且忘记要输入激活 ID，则所有已安装的产品密钥将被卸载。 这包括 Windows 产品密钥。   / xpr [ActivationID] 显示当前许可证状态的到期日期。   / sprt [PortNumber] 在 KMS 主计算机上设置 TCP 通信端口。此操作会将 PortNumber 替换为要使用的 TCP 端口号。默认设置为 1688 。   / cdns 禁止通过 KMS 主计算机自动发布 DNS。   / sdns 启用通过 KMS 主计算机自动发布 DNS。   / cpri 降低 KMS 主计算机进程的优先级。   / sai [ActivationInterval] 更改当 KMS 客户端找不到 KMS 主计算机时尝试激活其自身的频率。此操作会将 ActivationInterval 替换为一个分钟数。默认设置为 120 分钟。   / sri [RenewalInterval] 更改 KMS 客户端尝试通过联系 KMS 主计算机来续订其激活状态的频率。此操作会将 RenewalInterval 替换为一个分钟数。默认设置为 10080 分钟（7 天）。此设置将替代本地 KMS 客户端设置。    Slmgr.vbs 命令选项 基于 Active Directory 的激活    选项 说明     / ad-activation-online [ProductKey] 通过用户提供的产品密钥激活 AD DS 林。   / ad-activation-apply-get-iid [ProductKey] 显示用于 AD DS 林的安装 ID。   / ad-activation-apply-cid [ProductKey][ConfirmationID] 通过用户提供的产品密钥以及确认 ID 激活 AD DS 林。    ",
    "pubDate": "2020-06-05T19:22:45+08:00"
  }, 
  {
    "objectID": 20200602,
    "url": "https://ichochy.com/posts/20200602/",
    "title": "Office 批量激活的命令工具 ospp",
    "summary": "Office 软件保护平台脚本使你能够配置 Office 产品（包括 Project 和 Visio）的批量许可版本。",
    "content": "Office 软件保护平台脚本使你能够配置 Office 产品（包括 Project 和 Visio）的批量许可版本。\nospp.vbs 脚本 opss.vbs 脚本位于 Program Files\\Microsoft Office\\Office16 或 Program Files (x86)\\Microsoft Office\\Office16 文件夹。\n适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\n运行 ospp.vbs 需要 cscript.exe 脚本引擎\n若要查看帮助文件，请键入以下命令，然后按 Enter：\ncscript ospp.vbs /? 常规语法如下所示：\ncscript ospp.vbs [Option:Value] [ComputerName] [User] [Password] Option：指定用于执行以下操作的选项和值：激活产品、安装或卸载产品密钥、安装和显示许可证信息、设置 KMS 主机名和端口，以及删除 KMS 主机名和端口。本节中的表中列出了这些选项和值。\nComputerName：远程计算机的名称。如果不提供计算机名称，则使用本地计算机。\nUser：在远程计算机上拥有所需权限的帐户。\nPassword：帐户的密码。如果不提供用户帐户和密码，则使用当前凭据。\nospp.vbs 的全局选项    全局选项 说明     /act 激活已安装的 Office 产品密钥。   /inpkey:value 使用用户提供的产品密钥安装产品密钥（取代现有密钥）。Value 选项为必需。   /unpkey:value 卸载安装的产品密钥（包含要卸载的产品密钥的最后五位数，如 /dstatus 选项显示）。Value 参数必需。   /inslic:value 使用用户提供的 .xrm-ms 许可证路径安装许可证。Value 参数必需。   /dstatus 显示已安装产品密钥的许可证信息。   /dstatusall 显示所有已安装许可证的许可证信息。   /dhistoryacterr 显示 MAK/零售激活的失败历史记录。   /dinstid 显示用于脱机激活的安装 ID。   /actcid:value 使用用户提供的确认 ID 激活产品。Value 参数必需。   /rearm 重置所有已安装 Office 产品密钥的许可状态。   /rearm:value 重置具有用户提供的 SKUID 值的 Office 许可证的许可状态。 Value 参数必需。   /ddescr:value 显示用户提供的错误代码的说明。Value 参数必需。    ospp.vbs 的 KMS 客户端选项    KMS 客户端选项 说明     /dhistorykms 显示 KMS 客户端激活历史记录。   /dcmid 显示 KMS 客户端计算机 ID (CMID)。   /sethst:value 使用用户提供的主机名设置 KMS 主机名。Value 参数为必需。这将设置 HKLM\\Software\\Microsoft\\OfficeSoftwareProtectionPlatform\\KeyManagementServiceName (REG_SZ) 。   /setprt:value 使用用户提供的端口号设置 KMS 端口。默认端口号为 1688。Value 参数为必需。这将设置 HKLM\\Software\\Microsoft\\OfficeSoftwareProtectionPlatform\\KeyManagementServicePort (REG_SZ) 。   /remhst 删除 KMS 主机名并将端口设置为默认值。默认端口为 1688。   /cachst:value 允许或拒绝 KMS 主机缓存。Value 参数必需（TRUE 或 FALSE）。   /actype:value 设置批量激活类型。Value 参数必需。值：1（表示基于 Active Directory），2（表示 KMS），0（表示二者）。   /skms-domain:value 设置可在其中找到所有 KMS SRV 记录的特定 DNS 域。如果特定的一个 KMS 主机名是由 /sethst 选项设置的，则此设置不起作用。Value 参数是完全限定的域名 (FQDN) 并且必需。   /ckms-domain 清除可在其中找到所有 KMS SRV 记录的特定 DNS 域。如果特定 KMS 主机是由 /sethst 选项设置的，则会使用该主机。否则，将使用 KMS 主机的自动发现。    使用 ospp.vbs 的方案 在远程计算机上将产品密钥更改为 MAK 密钥  如果远程计算机名为 contoso1，请运行以下命令输入产品密钥。此操作假定您在远程计算机上拥有管理员凭据。如果您在远程计算机上的凭据与您的登录名和密码不同，则必须在命令行中键入您的登录名和密码，然后按 Enter：  cscript ospp.vbs /inpkey:xxxxx-xxxxx-xxxxx-xxxxx-xxxxx contoso1 若要激活远程计算机，请键入以下命令，然后按 Enter：  cscript ospp.vbs /act contoso1 诊断 KMS 激活错误  如果计算机安装了 KMS 客户端密钥，请检查授权状态。为此，请键入以下命令，然后按 Enter：  cscript ospp.vbs /dstatusall 若要检查 KMS 激活历史记录，请键入以下命令，然后按 Enter：  cscript ospp.vbs /dhistorykms 若要触发激活，请键入以下命令，然后按 Enter：  cscript ospp.vbs /act 检查错误消息中是否有错误代码 0xC004F042。如果在通知对话框中看到向用户显示的错误代码，您也可以使用该代码来检查错误消息。为此，请键入以下命令，然后按 Enter：  cscript ospp.vbs /ddescr:0xC004F042 打开或关闭 KMS 客户端上的 KMS 主机缓存  在 KMS 客户端计算机上，若要打开缓存，请键入下面的命令，然后按 Enter：  cscript ospp.vbs /cachst:TRUE 在 KMS 客户端计算机上，若要关闭缓存，请键入下面的命令，然后按 Enter：  cscript ospp.vbs /cachst:FALSE 测试 KMS 主机名，然后设置为自动发现  如果在测试名为 kmstest.contoso.com 的 KMS 主机，并且要在 KMS 客户端中指定该主机，请键入以下命令，然后按 Enter：  cscript ospp.vbs /sethst:kmstest.contoso.com 若要触发激活，请键入以下命令，然后按 Enter：  cscript ospp.vbs /act 若要检查 KMS 激活历史记录以查看是否成功连接主机，请键入以下命令，然后按 Enter：  cscript ospp.vbs /dhistorykms 现在，您希望此 KMS 客户端使用域名系统 (DNS) 自动发现生产 KMS 主机。若要移除 KMS 主机名，请键入以下命令，然后按 Enter：  cscript ospp.vbs /remhst ",
    "pubDate": "2020-06-02T19:22:45+08:00"
  }, 
  {
    "objectID": 20200528,
    "url": "https://ichochy.com/posts/20200528/",
    "title": "KMS 激活 Office 批量许可证密钥 KEY",
    "summary": "在配置为支持 Office 批量激活的 KMS 主计算机上，你只需安装和启用一个 KMS 主机密钥，即可激活 Office 的所有批量许可版本。",
    "content": "在配置为支持 Office 批量激活的 KMS 主计算机上，你只需安装和启用一个 KMS 主机密钥，即可激活 Office 的所有批量许可版本。\nOffice 的所有批量许可版本（包括 Project 和 Visio）都预安装了通用批量许可密钥 (GVLK)。\nGVLK 支持通过密钥管理服务 (KMS) 激活和基于 Active Directory 的激活。\nOffice 2019 的 GVLK    Product GVLK     Office 专业增强版 2019 NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP   Office 标准版 2019 6NWWJ-YQWMR-QKGCB-6TMB3-9D9HK   Project 专业版 2019 B4NPR-3FKK7-T2MBV-FRQ4W-PKD2B   Project 标准版 2019 C4F7P-NCP8C-6CQPT-MQHV9-JXD2M   Visio 专业版 2019 9BGNQ-K37YR-RQHF2-38RQ3-7VCBB   Visio 标准版 2019 7TQNQ-K3YQQ-3PFH7-CCPPM-X4VQ2   Access 2019 9N9PT-27V4Y-VJ2PD-YXFMF-YTFQT   Excel 2019 TMJWT-YYNMB-3BKTF-644FC-RVXBD   Outlook 2019 7HD7K-N4PVK-BHBCQ-YWQRW-XW4VK   PowerPoint 2019 RRNCX-C64HY-W2MM7-MCH9G-TJHMQ   Publisher 2019 G2KWX-3NW6P-PY93R-JXK2T-C9Y9V   Skype for Business 2019 NCJ33-JHBBY-HTK98-MYCV8-HMKHJ   Word 2019 PBX3G-NWMT6-Q7XBW-PYJGG-WXD33    Office 2016 的 GVLK    Product GVLK     Office 专业增强版 2016 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99   Office Standard 2016 JNRGM-WHDWX-FJJG3-K47QV-DRTFM   Project Professional 2016 YG9NW-3K39V-2T3HJ-93F3Q-G83KT   Project Standard 2016 GNFHQ-F6YQM-KQDGJ-327XX-KQBVC   Visio Professional 2016 PD3PC-RHNGV-FXJ29-8JK7D-RJRJK   Visio Standard 2016 7WHWN-4T7MP-G96JF-G33KR-W8GF4   Access 2016 GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW   Excel 2016 9C2PK-NWTVB-JMPW8-BFT28-7FTBF   OneNote 2016 DR92N-9HTF2-97XKM-XW2WJ-XW3J6   Outlook 2016 R69KK-NTPKF-7M3Q4-QYBHW-6MT9B   PowerPoint 2016 J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6   Publisher 2016 F47MM-N3XJP-TQXJ9-BP99D-8837K   Skype for Business 2016 869NQ-FJ69K-466HW-QYCP2-DDBV6   Word 2016 WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6    适用于： Office 2019 和 Office 2016（包括 Project 和 Visio）的批量许可版本\n",
    "pubDate": "2020-05-28T12:12:45+08:00"
  }, 
  {
    "objectID": 20200506,
    "url": "https://ichochy.com/posts/20200506/",
    "title": "慢性髓系白血病（CML）的临床分期",
    "summary": "慢性髓细胞白血病的分期是目前指导治疗的主要依据，也是预后判断的参考标准。CML可分为慢性期、加速期、急变期。",
    "content": "慢性髓细胞白血病的分期是目前指导治疗的主要依据，也是预后判断的参考标准。CML可分为慢性期、加速期、急变期。\n慢性期  临床表现：无症状或有低热、乏力、多汗、体重减轻等症状。 血象：白细胞总数增高，主要为中性晚幼和杆状核粒细胞，原始粒细胞（Ⅰ型+Ⅱ型）≤5%～10%，嗜酸性和嗜碱性粒细胞增多，可有少数有核红细胞。 骨髓：增生明显活跃或极度活跃，以粒系增生为主，中、晚幼粒和杆状核粒细胞增多，原始粒细胞（Ⅰ型+Ⅱ型）≤10%。 染色体：有Ph染色体。 CFU-GM培养：集落或集簇较正常明显增加。  加速期 具有下列之二者可考虑为本期。\n 不明原因的发热、贫血、出血加重、骨骼疼痛。 脾脏进行性肿大。 不是因药物引起的血小板进行性降低或增高。 原粒细胞（Ⅰ型+Ⅱ型）外周血和（或）骨髓中10%～19%。 外周血中嗜碱性粒细胞＞20%。 骨髓中有明显的胶原纤维增生。 出现Ph染色体以外的染色体核型异常。 对传统的抗慢性髓细胞白血病药物治疗无效。 CFU-GM增殖和分化缺陷，集簇增多，集簇和集落的比值增高。  急变期 具有下列之一者可诊断为本期。\n 外周血或骨髓中的原始粒细胞（Ⅰ型+Ⅱ型）或原淋+幼淋或原单+幼单≥20%。 外周血中原始粒+早幼粒细胞≥30%。 骨髓中原始粒+早幼粒细胞≥50%。 有髓外原始细胞浸润。 CFU-GM培养呈小簇生长或不生长。  源文出处：https://www.tsu.tw/edu/12025.html\n",
    "pubDate": "2020-05-06T22:12:45+08:00"
  }, 
  {
    "objectID": 20200526,
    "url": "https://ichochy.com/posts/20200526/",
    "title": "移植物抗宿主病详解",
    "summary": "移植物抗宿主病（graft versus host disease，GVHD）是allo- HSCT最常见的并发症，分为急性和慢性2种类型。",
    "content": "移植物抗宿主病（graft versus host disease，GVHD）是allo- HSCT最常见的并发症，分为急性和慢性2种类型。\naGVHD是供者T细胞识别不匹配的宿主多态性组织相容性抗原而发生的免疫应答； cGVHD也是由供者T细胞引发，但是参与应答的抗原特性、细胞类型以及发生机制尚未明了。\n移植物抗宿主病发病机制 GVHD发生条件 异基因HCT后，即便是人类白细胞抗原（human leukocyte antigen，HLA）完全匹配的亲缘供者移植、尽管受者接受严格的免疫抑制预防，仍无法完全避免发生GVHD，这是由于供受者间存在病理生理学差异造成的。早年Billingham就提出GVHD发病必备3个条件：移植物含有免疫活性细胞、供受者之间存在组织不相容性、受者不排斥或灭活输注或植入的细胞。\naGVHD发生机制 HLA是主要组织相容性复合物（major histocompatibility complex，MHC）编码的高度多态性蛋白，次要组织相容性抗原（minor histocompatibility antigen，miHA）是MHC以外的多态性基因编码的多肽。它们是在异基因HCT宿主引发GVH反应的最重要的免疫原性蛋白。这些组织不相容的宿主多态性抗原经来自受者和（或）供者的APC提呈，被供者同种反应性T细胞识别，最终造成aGVHD的靶器官损伤；同时一些非特异性炎症介质进一步加重这种损伤。根据实验动物研究结果，aGVHD的发生可以理解为连续的3个阶段：抗原提呈细胞（antigen presenting cells，APC）活化；供者T细胞活化、增殖、分化和迁移；靶器官损伤。\ncGVHD发生机制 一直以来，未能建立一个实验动物模型恰当地模拟临床cGVHD特征，这种状况一定程度上使得对cGVHD发病机制的理解远不如aGVHD清楚。可能的机制是供者反应性供者型Th细胞逃逸胸腺阴性选择，识别MHC抗原肽复合物后活化增殖，继而协助自身反应性B细胞合成自身抗体，最终产生类似自身免疫病的cGVHD征象。\n移植物抗宿主病临床分型 根据GVHD发生时间在移植后100天之内或之外，传统分类法将之分为急性和慢性2种类型。急性或慢性GVHD事实上存在本质差别。这种分类法是基于发病时间，而非疾病的临床或病理生理特征，在临床应用中存在一定局限性。比如，接受减低强度预处理的患者可在移植90天以后发生aGVHD；供者淋巴细胞输注后很快可以发生cGVHD征象，移植后100天以内也可再出现cGVHD的典型症状；此外某些常见征象在急性或慢性GVHD均可出现。为此，NIH根据特异征象而非发生时间提出了aGVHD和cGVHD的定义，其中aGVHD亚型包括经典、迁延、复发、迟发型，cGVHD亚型包括经典型和重叠综合征（overlap syndrome）。\nGVHD分类标准\n注：DLI，供者淋巴细胞输注\n组织病理学 病变脏器细胞凋亡是aGVHD典型的组织学特征，受累细胞是与组织增殖和再生有关的上皮细胞，包括表皮或上皮组织的基底细胞和基底上细胞、小肠上皮细胞和肝胆管上皮细胞。凋亡细胞周边出现免疫细胞浸润——即所谓的“卫星细胞坏死”——是aGVHD受损脏器的一个共同病理特征。皮肤GVHD病变在真皮表皮交界处最为严重，可见表皮细胞和基底细胞空泡变性、表皮细胞角化不良、嗜酸小体形成以及黑素细胞增生。最严重的皮肤GVHD表现为表皮坏死（Lyell综合征），活检见整个基底层角化细胞卫星坏死，导致表皮上层与基底层分离。肠道GVHD的病理特征是紧邻上皮内淋巴细胞出现隐窝上皮基底细胞凋亡。肝脏GVHD的靶细胞是胆管上皮细胞，淋巴细胞浸润主要发生在汇管区。有时可见肝细胞灶性坏死，但在GVHD急性期不出现肝硬化。肝小胆管可见节段性损伤、胆管周围上皮细胞损伤、胆管变形和细胞变性。\ncGVHD的组织学表现通常为苔藓样改变、干燥、管腔狭窄（stricture）或硬化。累及脏器较aGVHD更为广泛，包括皮肤（硬皮病）、口腔（口腔干燥症）、眼（干眼症）、阴道、食管、肝、肺（阻塞性细支气管炎）、筋（肌）膜炎、浆膜炎（心包或胸腔积液），而肾脏（肾病综合征）较少累及。根据病变严重程度不同，有时可出现多血质病理特征；但是器官纤维化是cGVHD不同于aGVHD的最具特征的病理学表现。\n移植物抗宿主病临床表现及分型  1.急性移植物抗宿主病临床表现  有明显临床征象的aGVHD（Ⅱ～Ⅳ度）的发病率因移植种类不同而在10%～80%不等，平均约为40%。aGVHD典型征象一般出现在清髓性异基因HCT后20～40天内，或在减低强度预处理异基因HCT后更迟的时候。主要累及皮肤、胃肠道和肝脏。\n手掌、脚底皮肤斑丘疹往往成为aGVHD先发征象。皮损可伴有痒觉和（或）痛觉，随之波及颜面，乃至全身皮肤；严重者形成水疱或发生表皮剥脱。皮肤aGVHD需与预处理皮损、植入综合征等鉴别。预处理毒性造成的皮损常发生于移植后3周以内（抑制期），病理特征为表皮淋巴细胞浸润，损伤细胞发生坏死而非凋亡；植入综合征发生在移植后粒细胞重建72小时内，特征表现为非感染性发热、皮疹、肺浸润/低氧血症；皮肤活检可以确诊aGVHD，表现为电镜发现卫星细胞坏死、抗TNF抗体标记上皮内激活淋巴细胞。\n肝脏病变表现为胆汁淤积性肝炎，可以出现黄疸；淤胆性指标升高，而转氨酶的变化没有特异性。肝脏aGVHD有时很难与治疗相关性肝炎、感染、肝静脉闭塞症鉴别。药物性或感染性肝炎可以找寻明确的病因，病变最初表现为肝实质细胞损伤，以转氨酶升高为主；肝静脉闭塞症发生于移植后早期（35～40天），特征表现为黄疸、肝大和水钠潴留，典型病理特征是肝内小静脉腔向心性非血栓性狭窄，血清纤维蛋白原活化抑制物（PAI- 1）水平增高。\n胃肠道aGVHD起病常表现为恶心呕吐和绿色水样便，腹泻量与肠道累及程度正相关，严重者伴有剧烈腹痛、鲜血便；极轻型仅累及上消化道，仅表现为食欲减退和恶心，对免疫抑制剂治疗有效。肠道GVHD需与病毒感染，尤其是CMV感染鉴别，典型GVHD病理改变容易加以区分，而且感染上皮细胞可以清晰见到病毒包涵体，抗CMV抗体染色（+）；但是GVHD早期病理改变易与CMV感染混淆，而且二者常可伴发，因此有必要采用针对CMV早期蛋白的治疗加以区分。\n 2.急性移植物抗宿主病分级和分度  1974年Glucksberg等首次提出aGVHD分类标准。将皮肤、肝脏、胃肠道3个主要累及脏器的功能指标分为0～4级（stage）（表153- 5），综合这些客观指标以及临床功能状态的主观评定将aGVHD分为Ⅰ～Ⅳ度（grade）（表153-6）。习惯上将aGVHD分为临床征象不明显的0～Ⅰ度和征象明显的Ⅱ～Ⅳ度。鉴于这个分度法中主观评定的局限性，1995年NIH的Consensus Workshop在此基础上做出一些改良，摒弃了“临床状况”这一主观参数（表153- 7）。\n表153-5　aGVHD脏器累及分级\n表153-6　Glucksberg aGVHD分度系统（1974年）\n表153-7　NIH aGVHD分度系统（1995年）\n 3.慢性移植物抗宿主病临床表现  cGVHD是异基因HCT晚期最主要的并发症，是造成晚期非复发死亡的主要原因。cGVHD临床表现多样，累及脏器较aGVHD更多。疾病特征类似许多自身免疫性疾病或其他免疫性疾病，如硬皮病、Sjǎgren综合征、原发性胆汁性肝硬化、Wasting综合征、阻塞性细支气管炎、免疫性血细胞减少和慢性免疫缺陷病等。\ncGVHD通常在HCT后3年内起病，存在三种病理过程：aGVHD的延续（progressive）、在aGVHD停止一段时间后发病（quiescent）、发病前无aGVHD征象（de novo），以前两种常见。\n 4.慢性移植物抗宿主病分型  自1980年沿用至今的西雅图标准将cGVHD分为局限型和广泛型2类。此标准来自于1个仅20例患者的回顾性观察，近年多有建议使用NIH提出的cGVHD器官积分系统来分型。这个总体积分系统是从患者功能状况上来综合反映cGVHD的病变程度，将cGVHD分为轻、中、重三型（表153- 8）。\n表153-8　2005年NIH Consensus Development Project推荐的cGVHD器官评分和总体评价系统\n注：AKP =alkaline phosphatase，ALT=alanine aminotransferase，AST=aspartate aminotransferase；FEV1=forced expiratory volume in 1s；LFS=lung function score（includes FEV1and diffusion capacity of the lung for CO）\n*当症状与肺功能试验积分不符时，以高积分者为准\nGVHD相关肺损伤 移植后非感染性肺部并发症与GVHD密切相关，是HCT相关死亡的一个主要原因。在GVHD的致病过程中，是否引起肺的同种反应性损伤，目前还很难定论，因为支持GVHD肺损伤的实验数据还很少。许多肺部并发症被认为是GVHD反应的表现，主要依据仅是基于肺部改变与GVHD同时出现而不存在感染因素，而并没有发现GVHD的特征性病理损伤。不过，许多移植后早期或晚期发生的肺损伤综合征都与GVHD有着密切的临床联系，如特发性肺炎综合征（idiopathic pneumonia syndrome，IPS）、植入综合征、阻塞性细支气管炎（bronchiolitis obliterans，BO）、阻塞性细支气管炎伴肌化性肺炎（bronchiolitis obliterans organizing pneumonia，BOOP）等。\nBO多发生于移植后3个月，几乎常与cGVHD相关，1/3以上的cGVHD患者可能发生呼吸道结构异常，其中大部分为BO，组织学特征是呼吸性和膜性细支气管内腔纤维性阻塞。表现为干咳、呼吸困难和喘息，胸部X线可能漏诊，高分辨CT常可见到呼气性气阱（air trapping）、纹理稀薄（hypoattenuation）和支气管扩张。HCT后气道阻塞的病因不清，由于cGVHD与初次发生的气道阻塞之间关系密切，因此推测免疫机制是造成支气管上皮细胞损伤的原因，推测BO可能是cGVHD在肺部的表现。\nBOOP非常少见，病例对照研究（n = 49）提示，经组织学诊断的移植后BOOP的临床表现类似于特发性BOOP或其他疾病伴发的BOOP。GVHD与随之发生的BOOP存在关联，如BOOP患者多有累及皮肤的aGVHD或累及肠道和口腔的cGVHD。BOOP病因不明，肺损伤可能与免疫反应、非典型感染或不典型IPS有关。\n移植物抗宿主病危险因素 无关供者、多次妊娠的女性供者、老龄受者、移植物类型（CB发生率低于、PB发生率高于BM）、某些预处理方案均可增加aGVHD风险（表153- 9）。cGVHD风险因素与之相仿，只是移植物类型的预测效果不同。CB移植能降低aGVHD风险，但不影响cGVHD的发生；PB移植对aGVHD影响不大，但能增加cGVHD的发生。\n在众多危险因素中，HLA匹配程度是aGVHD最直接的相关因素。HLA相合移植受者aGVHD发生率约40%，无关供者或HLA 1个位点不合移植受者aGVHD发生率增高到60%～80%。与aGVHD不同，只有少数研究涉及MHC不合cGVHD实验动物模型。MHC不合移植aGVHD小鼠模型显示，将受鼠体内出现的供者反应性供者型T细胞过继转移至供型小鼠可导致严重“自身免疫性”大肠炎，而过继至受型小鼠则不发生。虽然这项研究提示MHC不合在急、慢性GVHD的诱发中均有关键作用，但是并不清楚对于cGVHD而言，哪些特定的MHC不合更为重要。\n表153-9　GVHD风险因素\n移植物抗宿主病预防和治疗 GVHD以及为之进行的免疫抑制治疗造成异基因HCT受者处于严重的免疫缺陷状态，机会性感染和疾病复发或第二肿瘤的发生风险增高。目前很难找到有效措施将“坏”的GVHD和“好”的移植物抗白血病（graft versus leukemia，GVL）效应区别处理，即难以制定一个最佳方案在防治GVHD的同时，又能促进免疫重建和维护正常免疫功能。\n移植物抗宿主病预防 钙调磷酸酶抑制剂如环孢素（cyclosporin，Cs）或他克莫司（FK506）联合短疗程甲氨蝶呤（MTX）是目前常用的预防方案。被认为是清髓性、HLA相合亲缘供者HCT获得GVHD/GVL理想平衡的标准方案。钙调磷酸酶抑制剂通过抑制IL- 2生成来干扰T细胞的活化和功能。主要毒性作用包括血压升高、肾毒性、神经毒性和胆汁淤积性肝炎。若无GVHD发生则在移植后180天或更迟的时候停用。一项前瞻性研究比较他克莫司+短疗程MTX或Cs+短疗程MTX在成人无关供者移植中的预防效果，发现tacrolimus组Ⅱ～Ⅳ度aGVHD发生率明显减低，而两组cGVHD发生率无差异，毒性作用发生率、白血病复发率和总生存率也无差异。另一项前瞻性研究比较Cs+mycophenolate mofetil（MMF）与Cs+MTX在清髓性移植中的预防效果，MMF组黏膜炎发生率极少、造血重建更快，而两组aGVHD发生率、100天生存率无差异，似乎MMF可以代替MTX，避免MTX相关不良事件如影响植入、黏膜炎和其他脏器毒性。\n对于高风险受者，如HLA不相合供者、无关供者或减低强度预处理移植的受者以及老龄受者，很难制定一个最佳方案，可以使用其他的一些免疫抑制剂如MMF、抗人胸腺细胞球蛋白（anti- thymocyte globulin，ATG）等（表153- 10）。\n表153-10　常用GVHD预防用药\nHLA不相合移植应该采取更强的免疫抑制措施，如体外TCD（如移植物CD34细胞分选）或受者体内TCD（如使用ATG或CD52单克隆抗体）。虽然这些措施可以减轻aGVHD，却增加了感染、肿瘤复发/发生的风险。HLA相合移植无需体外TCD，因为（虽然GVHD发生率明显下降）总生存、无病生存和移植相关死亡率并未得到改善；而3个抗原不合的移植，体外TCD很有必要，需要保证移植物中T细胞＜5×104/kg。T细胞抗体的体内TCD对于植入具有双重效应，一方面通过抑制宿主应答促进供者细胞植入，另一方面由于抗体的较长半衰期可能影响移植物中的成熟T细胞。\n急性移植物抗宿主病的治疗 GVHD的初始治疗反应是判断GVHD预后的最重要指标，因为二线治疗的总体疗效仍然令人沮丧。甲泼尼龙（methyl- prednisolone，MP）联合钙调磷酸酶抑制剂是aGVHD首选初治方案。MP每日剂量2mg/kg，连续7～14天，在获得完全治疗反应后缓慢减停。主要毒副作用包括血糖升高、骨质疏松和影响发育等，这是制约糖皮质激素长期使用的主要因素。\nBlazar认为糖皮质激素不适合用于治疗严重的aGVHD。而且一些前瞻性研究显示，更强的方案（较标准方案）不宜用于一线治疗。MP高剂量10mg/（kg•d）和低剂量2mg/（kg•d）之间、或者ATG治疗和MP平均剂量5mg/（kg•d）治疗之间的移植相关死亡率均无差异；此外，对低剂量糖皮质激素治疗早期有效者移植相关死亡率显著降低，而早期无效者应该选择其他免疫抑制治疗方案，因为增高剂量的MP治疗并不能阻止aGVHD的进展。\n初始给予“糖皮质激素+钙调磷酸酶”联合治疗时，当出现下列情况之一者被认为是治疗无效：①治疗3天病情仍进展；②治疗7天病情无改善；③治疗14天病情未完全缓解。这些患者接受二线挽救治疗。\nCs难治性aGVHD可以选择tacrolimus+MP。一项回顾性研究提示换用tacrolimus后有效率为10% （2/20）。糖皮质激素难治性aGVHD可以选择其他免疫抑制治疗（表153- 11）。单克隆抗体如IL- 2R抗体、TNF-α抗体、CD3抗体的Ⅰ～Ⅱ期临床试验有显示一定的疗效，但还需要随机对照试验加以证实。\n表153-11　糖皮质激素难治性aGVHD的二线治疗\n慢性移植物抗宿主病的治疗 cGVHD是造血干细胞移植后晚期最主要的并发症和致死原因。Cs联合泼尼松是治疗cGVHD的标准方案。泼尼松起始给予1～1. 5mg/（kg•d）至少2周，再根据治疗反应缓慢减停，服药通常持续1年。治疗相关并发症包括骨坏死、糖尿病、感染、高血压、体型改变、皮肤萎缩、白内障、骨质疏松症、情绪波动、睡眠障碍和儿童发育迟缓等。有研究提示外周血血小板＞100×109/L患者似乎可以单用泼尼松，因为Cs+泼尼松或泼尼松单用的免疫抑制治疗终止率、需要二线免疫抑制治疗率以及死亡率差异无显著性。\n标准方案疗效为50%～55%，其中25%～50%需经免疫抑制剂延长治疗达4年以上。然而cGVHD自身以及长期免疫抑制将增加并发症的发生率和死亡率。为此，一些研究致力于使用新药作为首选治疗或者用于治疗激素难治性或依赖性患者。\ncGVHD还没有一种标准的二线治疗方案。许多药物在临床试验中都能不同程度改善难治性cGVHD的治疗现状。MMF治疗激素难治性cGVHD的有效率在46%～75%，疗效与MMF血清谷浓度正相关。主要不良事件是机会性感染。针对B细胞的利妥昔单抗（rituximab）的Ⅰ/Ⅱ期临床试验显示，难治性cGVHD能取得70%的有效率，感染是仅有的不良事件。西罗莫司（sirolimus）的Ⅱ期临床试验显示，联合使用sirolimus、tacrolimus和糖皮质激素的有效率为63%。大剂量糖皮质激素临床试验报道严重难治性cGVHD（n = 61）给予甲泼尼龙10mg/ （kg•d）连续4天，主要及次要反应率分别为48% 和27%，治疗耐受性良好，没有严重不良事件。\n间充质干细胞（mesenchymal stem cell，MSC） MSC是免疫隔离性细胞，在特定条件下才具备免疫抑制效应。小鼠非清髓异基因移植实验提示，受者MSC能支持长期植入和供受者抗原的耐受；而供者MSC却与异基因供者骨髓排斥增加有关。虽然如此，MSC在治疗GVHD上却带来了希望。瑞典的研究组报道，8例激素难治性Ⅲ～Ⅳ度aGVHD平均输注MSC 1×106/kg，结果完全有效率为6/8。临床扩大试验正在欧洲实施。\n体外光疗（extracorporeal photopheresis，ECP） 采集受者5×109白细胞，经光活性化合物（8-methoxypsoralen）和紫外A光处理后，细胞发生凋亡，这些凋亡细胞回输后被受者APC俘获，从而触发某种耐受机制，移植前受者接受ECP处理可能有助于减少GVHD的发生。奥地利Ⅱ期临床试验提示，激素难治性aGVHD接受ECP治疗后，完全缓解率在皮肤、肠道、肝脏分别是82%、61%、61%，完全缓解者预期生存率（59%）显著高于其他患者（11%）。\n不相合的供者NK细胞 小鼠实验提示供者不相合NK细胞能杀伤宿主APC。Aversa等报道，移植时同时输注体外扩增的不相合供者NK细胞通过杀伤宿主APC减少GVHD的发生，同时通过杀伤白血病细胞发挥抗肿瘤效应。\n源文出处：https://www.tsu.tw/edu/12523.html\n",
    "pubDate": "2020-05-06T22:12:45+08:00"
  }, 
  {
    "objectID": 20200504,
    "url": "https://ichochy.com/posts/20200504/",
    "title": "急性髓系白血病（AML）的治疗",
    "summary": "白血病患者骨髓中存在着正常的多克隆造血和白血病性单克隆造血两类细胞群，急性白血病治疗目的是杀灭白血病克隆恢复持久的正常多克隆造血。",
    "content": "白血病患者骨髓中存在着正常的多克隆造血和白血病性单克隆造血两类细胞群，急性白血病治疗目的是杀灭白血病克隆恢复持久的正常多克隆造血。\n白血病疗效的改善起自20世纪60年代末。随着肿瘤治疗新药的不断发现，支持治疗的加强（包括高效抗生素、成分输血和造血生长因子的应用）以及对白血病生物学特性的认识提高，人们逐步探索出一套以联合用药、大剂量、早期强化为主要策略的治疗方法。目前儿童和60岁以下成人AML的CR率均为60%～85%，5年DFS儿童可达50%，成人约30%～40%。\nAML的治疗应分阶段进行：  第一阶段是诱导治疗，目的是杀灭白血病细胞，达到骨髓常规检查（骨髓涂片分类或活检）恢复正常（完全缓解，CR）； 第二阶段是缓解后治疗（包括巩固、强化、维持治疗和髓外白血病防治以及造血干细胞移植等），目的是清除残余的、常规检查方法不能发现的白血病细胞，以减少复发、争取长期生存。  缓解后治疗可以人为地分成几个阶段：  第一阶段为巩固治疗，通常是重复使用原诱导方案1～2个疗程，亦可有所改变； 第二阶段为强化治疗，不仅用药剂量比诱导化疗更大，而且经常要在原诱导方案基础上增添或换用不同的药物，治疗一至数个疗程； 最后阶段是维持治疗，即应用剂量较小、不引起明显骨髓抑制的化疗，通常持续时间较长，但其价值尚有较大争议。随着中、大剂量阿糖胞苷的应用（一般早期应用），目前AML的缓解后治疗已不再是这个规律。 AML的缓解后治疗还包括干细胞移植的应用（包括自体干细胞移植和异基因干细胞移植）。  急性白血病患者开始治疗前应进行基本的评估，评估的内容有两个：  ①确定疾病本身的特点，如既往毒性物质接触史、骨髓增生异常情况、细胞遗传学或分子学异常； ②患者本身的情况，如并发症等影响患者对化疗耐受的因素。评估的最终目的是决定个体化的治疗方案。  源文出处：https://www.tsu.tw/edu/11966.html\n",
    "pubDate": "2020-05-04T16:12:45+08:00"
  }, 
  {
    "objectID": 20200502,
    "url": "https://ichochy.com/posts/20200502/",
    "title": "骨髓增生异常综合征（MDS）的病程与预后",
    "summary": "骨髓增生异常综合征（MDS）的病程大致有以下三种主要演变模式： 第一种模式，患者病情稳定，骨髓中原始细胞不增多或轻微增多，而不超过5%，随诊中迄未发生白血病转变，仅靠一般支持治疗可活存数年甚至十多年。",
    "content": "骨髓增生异常综合征（MDS）的病程大致有以下三种主要演变模式： 第一种模式，患者病情稳定，骨髓中原始细胞不增多或轻微增多，而不超过5%，随诊中迄未发生白血病转变，仅靠一般支持治疗可活存数年甚至十多年。\n第二种模式，患者初期病情稳定，与第一种相似，骨髓中原始细胞不增多或轻度增多，但一般＜10%。经过一段时间以后，骨髓中原始细胞突然迅速增多，转变为AML。\n第三种模式，患者骨髓中原始细胞缓渐地进行性增多，临床病情随之进展，直至转变为AML。MDS发生白血病转变时几乎全是转变为急性髓系白血病（AML），以M1、M2、M4、M6亚型为多。也有报道说个别病例转变为急性淋巴细胞白血病或髓淋混合型白血病。\n对MDS诸多参数的预后意义进行分析的结果表明，最主要的预后因素是骨髓中原始细胞比例，比例愈高，预后愈差。染色体异常（尤其是-7/7q-、+8或复杂核型异常）也具有非常重要的意义。其他具有独立不良预后意义的因素尚有：外周血细胞显著减少，尤其是血小板减少和全血细胞减少，高龄（＞60岁），ALIP（+），巨核细胞异常（特别是有淋巴细胞样小巨核细胞），伴有骨髓纤维化，SCD （-）等。\n1997年国际MDS危险分析专题讨论会综合一些大系列的MDS预后资料，经过对各个重要预后因素的逐个分析，确定骨髓原始细胞比例、骨髓造血细胞染色体核型和外周血细胞减少系列数最具有预后意义。据此提出一个MDS国际预后积分系统（International Prognostic Scoring System，IPSS）将MDS分为低危、中危-Ⅰ、中危-Ⅱ和高危四个危度组（下表），对提示患者的生存期及白血病转变具有肯定意义（下表2）。IPSS提出后，很快得到一些作者的验证和认同，已取代其他的预后积分系统，而被广泛接受，现已将它视为提示预后和指导治疗的临床MDS分型方案。\n*预后良好核型：正常核型，-Y，5q-，20q-。预后不良核型：复杂核型异常（≥3种异常），7号染色体异常。预后中间核型：除上述两类以外的其他核型异常\n△血细胞减少的标准：血红蛋白＜100g/L；中性粒细胞绝对数＜1. 8×109/L；血小板数＜100×109/L\n2001年WHO造血组织肿瘤分类提出WHO分型后，但按照FAB分类制定的IPSS中骨髓原始细胞比例分组不能充分发挥其预后作用，因而2005年德国学者基于WHO分型标准提出了WPSS积分系统（下表）。该积分系统将MDS患者划分为极低危、低危、中危、高危和极高危组，属于这些危度分组的患者中位生存期分别为141、66、48、26、9个月，2年转白率分别为3%、6%、21%、38%、80%，5年转白率分别为3%、14%、33%、54%、84%。与IPSS预后积分系统相比，WPSS系统最大的优点是：IPSS是基于原发初治患者提出的，仅适合原发初治患者的预后判断，而WPSS适合于MDS患者病程演进过程中任一时点的预后判断，此外还适合继发性MDS患者的预后判断。\n*预后良好核型：正常核型，-Y，5q-，20q-。预后不良核型：复杂核型异常（≥3种异常），7号染色体异常。预后中间核型：除上述两类以外的其他核型异常\n目前采用WPSS作为我国MDS患者预后判断标准尚存在以下主要问题：  ①染色体核型分析（常规染色体核型分析及FISH）在我国尚未普及，并且即使在进行了染色体检查的MDS患者中结果可供分析者（达到判断正常核型或克隆性异常核型所需分裂象）不足50%；另外WPSS中染色体核型的预后分组延用了IPSS中的分组，某些染色体单一异常被划分至中危组，但有研究证明并非如此（例如1号染色体长臂异常、8-三体预后较中危组差；12号染色体短臂缺失预后较中危组好）； ②红细胞输注的原则在我国由于经济条件限制或认识不足尚未得到规范实施，导致对输血依赖的判断欠客观。鉴于此，我们通过COX模型从MDS常规实验室检查指标中筛选出具有独立预后意义的参数：MCV、是否存在有淋巴样小巨核细胞（MEGly），据此提出了一个改良的WPSS积分系统（下表）。该系统简便、实用，可望提供适合我国基层单位目前使用的MDS预后判断标准。  *MEGly：淋巴样小巨核细胞\nMDS患者的死亡原因:  约半数是由于骨髓无效造血加重，外周血中血细胞进行性减少而招致的出血和感染， 30%～40%是由于发生白血病转变， 10%～20%是由于与MDS无直接关系的其他疾病。  源文出处：https://www.tsu.tw/edu/12013.html\n",
    "pubDate": "2020-05-02T14:18:45+08:00"
  }, 
  {
    "objectID": 20200430,
    "url": "https://ichochy.com/posts/20200430/",
    "title": "急性白血病的临床表现",
    "summary": "急性白血病的临床表现主要与白血病细胞无控性增殖引起骨髓正常造血受抑制和髓外组织器官浸润有关。某些独特的临床表现对急性白血病的诊断和分型有重要提示作用。",
    "content": "急性白血病的临床表现主要与白血病细胞无控性增殖引起骨髓正常造血受抑制和髓外组织器官浸润有关。某些独特的临床表现对急性白血病的诊断和分型有重要提示作用。\n起病 急性白血病一般起病急骤，但老年病人、低增生性急性白血病以及红白血病的患者起病可以相对较缓。急性起病的患者往往以感染、出血或骨痛等为首要表现，而起病慢时则以贫血为主，进行性加重。起病前多有疲乏、不适和食欲缺乏等类似“感冒”症状，或皮肤破损后难愈、感染或出血不止等。病前数周可有关节肿痛（大关节常见），少数骨痛剧烈，与髓腔内压力增高或白血病骨膜浸润有关；也可以抽搐、视物不清、牙龈肿胀或胸痛等为首发表现。Sweet综合征又称急性中性粒细胞皮肤血管炎，是急性白血病并发的皮肤副癌综合征，主要见于急性髓系白血病（AML）；患者的上、下肢末端皮肤出现红色软性斑块或结节，病理检查可见中、上真皮层以成熟中性粒细胞为主的密集炎性细胞浸润，不具有特异性，可能与白血病细胞释放生长因子和抗原刺激有关；皮肤改变可先于白血病数月出现，与白细胞多少无关，皮质激素治疗有效。\n发热和感染 急性白血病起病时多有感染，化疗后的骨髓抑制期感染也很常见。感染部位多样，以口腔、牙龈、鼻咽、肺、消化道、肛门及泌尿道等开放部位为主，可迅速发展为菌血症或败血症。白细胞减少、中性粒细胞功能异常、皮肤黏膜屏障功能减低、长期使用广谱抗生素导致菌群失调、自身免疫功能低下和应用免疫抑制剂增加机会感染等是引起感染的主要原因。以细菌感染最为多见，初期多为革兰阳性球菌，治疗期间则以革兰阴性杆菌（包括假单孢菌、大肠杆菌和奇异变形杆菌等）为主；真菌感染以白色念珠菌、曲霉菌和毛霉菌多见；还可见单纯或带状疱疹病毒、巨细胞病毒和EB病毒等感染。病情、感染部位和用药情况对判断病源微生物有一定提示作用。\n出血 出血是急性白血病常见的临床表现，主要为皮肤和黏膜出血，如皮肤出血点、瘀斑、鼻出血、牙龈渗血及口腔血疱等；也可见消化道、呼吸道、泌尿道、眼底甚至中枢神经系统出血，严重时威胁生命。AMLM3和M5型患者初诊时出血相对较重。血小板减少和功能异常、凝血异常（原发性纤维蛋白溶解、弥散性血管内凝血和肝功受损致凝血因子合成减少）和血管壁白血病细胞浸润等是引起出血的主要原因。\n贫血 少数急性白血病患者早期可无贫血，但随着疾病进展，必然发生红细胞和血红蛋白进行性减少。化疗期间也可有短暂贫血。表现为苍白、头晕、疲乏、耳鸣、心悸、胸闷、消化不良和多尿等表现，严重时可见双下肢水肿。贫血主要原因是由于白血病细胞浸润和化疗致骨髓红细胞造血抑制，失血、溶血、造血原料缺乏和EPO生成减少等也可加重贫血。\n肝、脾、淋巴结及胸腺肿大 肝、脾肿大见于70%以上的急性淋巴细胞白血病（ALL）和50%以上的AML，AML尤以M4和M5更为明显。原发性AL的肝脾肿大一般为轻、中度，脾肿大显著（超过肋下5cm）的患者需考虑继发于慢性粒细胞白血病（CML）。ALL常有淋巴结和胸腺肿大，胸腺肿大见于7%～10%的儿童和15%的成人患者，并可引起上腔静脉阻塞综合征；而AML的淋巴结肿大罕见，一般不发生胸腺白血病细胞浸润。\n皮肤损害 约10%的AML可出现皮肤局限性或弥漫性紫色突起硬结或斑块，以M4和M5较为多见，病理检查可见白血病细胞浸润；而ALL仅1%有皮肤浸润。也可见瘀斑、荨麻疹、瘙痒和多形性红斑等非特异性皮肤损害，还可有皮肤疖、痈、丹毒、蜂窝织炎或疱疹等皮肤感染性表现。\n中枢神经系统及神经根浸润 ALL的中枢神经系统浸润明显多于AML，儿童多于成人。约1/3的儿童ALL初诊时有中枢神经系统白血病（CNSL），以Burkitt淋巴瘤/白血病和T 系ALL多见。而仅5%～7%的AML在常规脑脊液检查时发现有CNSL，且以M4和M5多见。高白血病症和乳酸脱氢酶增高者易患CNSL。病程中如未经CNSL预防，约70%以上的ALL和30%～50%的AML可出现CNSL；轻者无症状，或仅轻微头痛，重者可出现头痛加剧、喷射性呕吐、视物模糊和精神改变，甚至发生脑疝、出现呼吸和心血管中枢抑制等。检眼镜检查可见视盘水肿和视盘苍白；腰穿检查可发现脑脊液压力增高，白细胞数和蛋白质增加，糖和氯化物可减低，还可能发现白血病细胞。\n外周血原始细胞超过50×109/L时易发生颅内白血病细胞淤滞，表现为弥漫性头痛和疲乏，可迅速发展为精神错乱或昏迷。主要是因为WBC增高增加血黏度，使颅内小血管出现白血病细胞淤滞和栓塞；白血病细胞也浸润动脉血管，可引起颅内出血。白血病细胞淤滞在白髓和软脑膜较明显。降低白细胞数和血黏度并不能有效改善症状。\nWBC＞50×109/L也易发生神经根鞘的白血病细胞浸润，可致脑神经根麻痹，以第5、7对脑神经损害较多见。主要见于ALL，而AML罕见。患者可突然面肌无力，迅速面瘫。视神经浸润表现为视盘水肿、眼痛和视物模糊，或突然单眼盲。视网膜浸润降低视力。脑神经浸润可发生于无明显CNSL表现者，脑脊液可找不到白血病细胞，但MRI或CT可见神经鞘增厚，提示白血病细胞浸润；及时局部放疗以及降低WBC可避免脑神经功能永久性丧失。\n呼吸系统 呼吸系统改变的主要原因是肺感染。约5%的患者初诊时因WBC增高可出现肺内白血病细胞淤滞。此时肺内微血管栓塞、麻痹和体液渗漏，患者咳嗽、突然气短和进行性呼吸窘迫，可有发热，双肺广泛水泡音，胸部X线片可见弥漫性肺间质渗漏和胸腔积液，严重时出现呼吸功能衰竭。肺白血病细胞淤滞在单核细胞白血病和M3v较为多见。肺白血病细胞淤滞的表现也可类似于肺细菌或真菌感染。也可见弥漫性或局限性（肺段或叶）肺出血，表现为突然气短，可有咯血，胸部X线片可明确出血的部位。\n骨和关节疼痛 急性白血病体检常可发现胸骨压痛。骨和关节疼痛在ALL多于AML，尤以儿童ALL多见，甚至成为初诊时的主要表现。骨和关节疼痛与白血病细胞大量增殖致骨髓腔内压力增高和白血病侵蚀骨实质、骨膜和关节腔有关。\n消化道 急性白血病常因感染、白血病细胞侵蚀和化疗等损伤胃肠道，出现口咽部黏膜溃烂、吞咽困难、恶心、呕吐、腹痛、腹泻或出血等。食管念珠菌病可致胸骨下疼痛、“烧心”感和吞咽困难。长期应用广谱抗生素和化疗引起的黏膜损伤增加了胃肠道真菌的感染机会。少数患者食道和小肠内可形成绿色瘤或粒细胞肉瘤，引起梗阻。国外报道约10%的患者强化治疗期间出现阑尾炎和急性坏死性结肠炎，表现为突发性腹痛、发热、腹胀、腹肌紧张和肠鸣音减低，腹透常见不完全性小肠梗阻或可疑的右下腹包块以及积气，CT有助于诊断；并发阑尾炎的患者多数预后较差；治疗包括肠道休息、应用针对肠道厌氧菌、真菌的广谱抗生素及静脉营养等，少数需手术治疗，术式常采用部分结肠切除术。肛周感染较常见，最初表现为排便时痛，肛周发硬、有触痛，但无明显红肿，可发展为肛周脓肿。肛周感染应早发现、早处理。粒细胞缺乏期患者一般应避免做肛门指诊或直肠镜检；便秘者应注意及时通便，防止黏膜撕裂而继发感染。\n口腔、眼部及耳鼻咽喉 白血病细胞浸润可致牙龈增生和肿胀，多见于分化较好的单核细胞白血病。口腔溃疡与感染、浸润和化疗损伤黏膜有关。舌或软、硬腭等处是口腔念珠菌感染好发部位。鼻窦炎和中耳炎偶见。视盘和视神经浸润可致突然失明，也有脉络丛和视网膜等其他眼组织浸润的报道。绿色瘤可见于眼的任何部位。检眼镜检查发现视盘水肿和视盘苍白时应考虑白血病眼部浸润，高度提示脑膜白血病。\n乳腺 少数患者在疾病初期或白血病复发时出现乳腺局限性或弥漫性增生，应与乳腺癌或乳腺炎相鉴别。\n髓细胞肉瘤 髓细胞肉瘤包括粒细胞肉瘤和单核细胞肉瘤两种，是原始细胞髓外浸润的表现。可为单个皮下包块，以颅骨、眼眶或硬脊膜等部位多见，也可见于乳腺、肝、肾或肌肉等处，易与原发性肿瘤或转移瘤混淆。粒细胞肉瘤内原始细胞含较多的髓过氧化物酶颗粒，使瘤体切片在空气中易被氧化而呈绿色，又称绿色瘤。粒细胞肉瘤易见于t（8；21）/AML、inv （16）/AML和白细胞显著增多的患者。t（8；21）/ AML年龄越小粒细胞肉瘤越易见到。\n心血管 心功能改变通常是肺功能障碍、代谢和电解质紊乱的结果。白血病细胞浸润心脏和大血管较为罕见。原始单核细胞可浸润心传导系统、心包、心肌和动脉血管壁，动脉血管壁浸润可继发动脉瘤。化疗毒性是心功能改变的主要原因，蒽环类药物可致急、慢性心脏毒性，且与其他药物有协同作用。应在开始化疗前评估心脏功能及左、右室射血分数。\n泌尿生殖器 因白血病细胞浸润可致肾肿大、蛋白尿、血尿和少尿等。也可因高尿酸血症导致尿酸性肾病、肾结石、甚至急性肾衰竭。极少数情况下白血病细胞浸润前列腺可导致尿路梗阻。可并发泌尿系统感染。应用大剂量环磷酰胺治疗时因环磷酰胺代谢产物丙烯醛损伤膀胱黏膜，可致出血性膀胱炎。单、双侧睾丸浸润多见于ALL，尤其是儿童和T系ALL，且经常是复发的最早表现。极少数患者阴茎异常勃起，与海绵体白血病细胞浸润和栓塞有关。女性亦可有子宫和卵巢浸润。\n电解质与代谢紊乱 急性白血病的代谢和电解质紊乱较为常见。大量白血病细胞破坏可致高尿酸血症，大量尿酸盐结晶可损害肾小管和输尿管，引起急性肾衰竭，应及时给予水化、碱化和别嘌呤醇治疗。发生肾衰竭也与白血病细胞浸润肾皮质、髓质和肾间质有关。一般AML的肾功能损害较ALL少见。\n白血病细胞迅速杀灭可致高钾血症，但临床以低钾血症更为多见，且主要见于M4和M5。单核细胞白血病细胞的溶菌酶浓度较高，大量溶菌酶释放可损伤近端肾小管，使肾钾丢失；白血病细胞合成的肾素样因子及抗生素、化疗药物、腹泻、呕吐和低镁血症等也与低钾血症形成有关。高钙血症可由骨质浸润、破骨细胞活化和继发性溶骨引起，也可能与白血病细胞释放甲状旁腺素或甲状旁腺素样物质有关。低钙血症时同出现手足抽搐和致命的心律失常，可能与白血病细胞释放加快骨形成的因子或肾损害后血、尿中磷酸盐增多有关。\n肿瘤溶解综合征表现为快速进展的高尿酸血症、高钾血症、高磷酸盐血症和低钙血症，引起急性肾损害、致死性心律失常和手足抽搐、肌痉挛等。肿瘤溶解综合征见于原始细胞极高或迅速增高的患者，需在化疗前及时纠正代谢和电解质紊乱，早期给予别嘌呤醇和水化治疗，必要时可予血液透析。\n急性白血病可发生乳酸酸中毒，机制不明，可能与白血病细胞无氧糖原酵解有关。乳酸酸中毒主要见于极高原始细胞数和髓外浸润、白血病细胞淤滞的患者。外周血有大量原始细胞时可出现假性低血糖和动脉血氧饱和度降低，可能与白血病细胞代谢消耗氧和血糖有关。\n源文出处：https://www.tsu.tw/edu/11940.html\n",
    "pubDate": "2020-04-30T16:12:45+08:00"
  }, 
  {
    "objectID": 20200425,
    "url": "https://ichochy.com/posts/20200425/",
    "title": "慢性粒单核细胞白血病（CMML）",
    "summary": "慢性粒单核细胞白血病（chronic myelomonocytic leukemia，CMML）是一种骨髓造血干细胞的克隆性疾病",
    "content": "慢性粒单核细胞白血病（chronic myelomonocytic leukemia，CMML）是一种骨髓造血干细胞的克隆性疾病\n其特征为：\n 外周血中单核细胞持续性增多＞1×109/L； 无Ph染色体或BCR-ABL融合基因； 无PDGFRα或PDGFRβ重排（在有嗜酸性粒细胞增多的病例中要特别加以排除）； 外周血和骨髓中原始细胞＜20%（幼单核细胞也视为原始细胞）； 一系或多系髓系细胞存在发育异常。  如无肯定的发育异常，但符合CMML的其他条件，且骨髓细胞有获得性克隆性细胞遗传学或分子学异常，或单核细胞增多持续至少3个月并能除外引起单核细胞增多的其他原因，如恶性肿瘤、感染或炎症，仍可诊断为CMML。CMML的临床血液学和形态学特征是异质性的，其表现变动于从以骨髓增生异常为主到以骨髓增殖为主的病谱之间。CMML中JAK2V617F突变不常见。\n流行病学：本病主要发生于老龄人，60岁以上人群中年发病率约为3/10 000。中位发病年龄为65～75岁，男女之比为1. 5～3：1。\n病因与发病机制 病因与发病机制未明。职业性和环境致癌因素、电离辐射和细胞毒药物在某些病例可能是致病因素。有迹象表明一些细胞因子如TNF、GM-CSF、IL-3、IL-4等可能参与了粒单核系的过度增殖。RAS基因突变在初诊和病程中可达40%。克隆性染色体异常可见于20%～40%的CMML患者，但均无特异性。\n临床和血液学表现 CMML外周血象的标志性特征是单核细胞增多＞1. 0×109/L，比例超过白细胞的10%，一般为成熟单核细胞，形态无明显异常。有时可有原始细胞或幼单核细胞，但数量不会很多。约50%的患者白细胞正常或轻度减少，伴有中性粒细胞减少，且其他血液学特点与MDS基本相同。另外约50%的患者白细胞增高，伴有中性粒细胞增多，也可有不成熟粒细胞，但一般＜10%，特别是原始细胞很少超过5%，有些病例嗜酸性粒细胞增多显著。如符合CMML的诊断标准，但外周血嗜酸性粒细胞≥1. 5× 109/L，可诊断为CMML伴嗜酸性粒细胞增多。这类患者可有嗜酸性粒细胞脱颗粒相关的并发症，必须做相应的基因检测以除外髓系肿瘤伴嗜酸性粒细胞增多并有PDGFRα或PDGFRβ基因异常的患者。\n75%以上的病例骨髓有核细胞增多。骨髓活检标本中粒系细胞增殖常是最显著的表现，但也可见有红系细胞增多。单核细胞系增殖必然存在，但在骨髓活检或骨髓穿刺液涂片中可能难以认出。当疑诊为CMML时，应使用有助于确认单核细胞和不成熟单核细胞的细胞化学和免疫组化方法。大多数患者有粒系和巨核系发育异常，可看到小巨核细胞和（或）核分叶异常的巨核细胞。约30%的患者骨髓中可见轻至中度网状纤维增加。20%的患者骨髓活检可见到成熟浆细胞样树突状细胞（浆细胞样单核细胞）结节。这些细胞核圆形，染色质细致分散，核仁不明显，极少量嗜酸性胞质，胞膜常清楚。浸润的细胞呈紧密聚集的外观，常见呈星空样分布的组织细胞中的凋亡小体。近来一项研究证明这些浆细胞样树突状细胞是克隆性、肿瘤性的，与合并的髓系肿瘤密切相关。\nCMML患者可有肝脾肿大，主要见于白细胞增高者，淋巴结肿大少见。但一旦出现淋巴结肿大，可能是向更为急性期转化的信号，淋巴结可有原粒细胞弥漫性浸润。\n其他实验室检查 CMML患者外周血和骨髓细胞通常表达粒、单核细胞抗原，如CD33与CD13，以及不同程度地表达CD14、CD68、CD64。组织切片免疫组化确认单核细胞相对不够敏感。最可靠的标志为CD68R与CD163。溶菌酶与CAE染色合用也有助于确认单核细胞，粒系细胞二者均阳性，而单核细胞为溶菌酶阳性，CAE阴性。\n20%～40%的CMML病例有克隆性细胞遗传学异常，但都无特异性。最常见重现性异常包括+8，-7/del（7q）及12p结构性异常。诊断时或病程当中多达40%的患者有RAS基因点突变。目前，有孤立性17q等臂染色体的造血组织肿瘤如何分类尚未确定，尽管部分患者符合CMML的诊断标准，其他患者可能更适合归入MDS/MPN，不能分类。11q23异常在CMML中不常见，如有，则提示AML的诊断。\n相似于CMML的病例可表达p190bcr-abl1，这种应分类为慢性粒细胞白血病（CML）。因此，若细胞遗传学分析未检出t（9；22）（q34；q11），仅用PCR方法检测p210以除外CML是不够的。\n诊断 2008年WHO分类中CMML诊断标准如下：\n 外周血单核细胞持续性＞1×109/L。 无Ph染色体或BCR-ABL融合基因。 无PDGFRα或PDGFRβ重排（在有嗜酸性粒细胞增多的病例中要特别加以排除）。 外周血或骨髓中原始细胞（包括原始粒细胞和原、幼单核细胞）＜20%。 髓系细胞1系或多系发育异常，如无骨髓细胞发育异常或极微   但其他条件符合且有下述情况者，仍可诊断为CMML：\n 1. 造血细胞有获得性克隆性细胞遗传学或分子基因异常，或 2. 单核细胞增多至少已持续3个月，而且 3. 除外所有已知能引起单核细胞增多的其他原因。 CMML还应进一步分为以下两个亚型：\nCMML-1：原始细胞数（包括幼单核细胞）外周血中＜5%，骨髓中＜10%。\nCMML-2：原始细胞数（包括幼单核细胞）外周血中占5%～19%，或骨髓中占10%～19%，如见到Auer小体，则不论原始细胞（包括幼单核细胞）占多少均诊断为CMML-2。\n如外周血中嗜酸性粒细胞＞1. 5×109/L，则相应诊断为CMML-1或CMML-2伴有嗜酸性粒细胞增多。\n预后 CMML患者的生存时间各报告中相差甚大，短者仅1个月，长者可100个月，但中位生存时间多为20～40个月。15%～30%的患者进展为急性白血病。外周血和骨髓中原始细胞百分比是最重要的提示预后不良的因素。\n治疗 到目前为止，CMML尚无满意治疗方法。小剂量化疗和大剂量强烈化疗均尚不能证实有肯定的疗效，特别是强烈化疗在老年患者应当慎用。异基因造血干细胞移植（Allo-HSCT）仍是唯一有可能治愈CMML的手段，因此，年纪较轻且有合适供者的CMML患者，应首先考虑Allo-HSCT。非清髓性Allo-HSCT可选择性地实施于老年和不能耐受强烈预处理方案的患者。红细胞生成素在某些患者可减少输血需求，改善贫血。G-CSF/GM-CSF可一时性提高外周血中性粒细胞数量。单药或联合化疗适用于中危或高危的CMML患者，完全缓解率为10%（单药）～50%（AML方案联合化疗）。目前，去甲基化药物5-氮杂胞苷和地西他滨已应用于临床。靶向治疗药物如法尼基转移酶抑制剂R115777，肽模拟剂E21R，以及DT388-GM-CSF等，均尚处于临床试验中。\n源文出处：https://www.tsu.tw/edu/12015.html\n",
    "pubDate": "2020-04-25T14:16:45+08:00"
  }, 
  {
    "objectID": 20200422,
    "url": "https://ichochy.com/posts/20200422/",
    "title": "白血病的分类：髓系肿瘤和淋系肿瘤",
    "summary": "真正的白血病分型是始于1887年德国人Ehrlich发明细胞染色方法之后。基于对白血病细胞形态和疾病进程的观察，不断发现新的白血病类型。",
    "content": "真正的白血病分型是始于1887年德国人Ehrlich发明细胞染色方法之后。基于对白血病细胞形态和疾病进程的观察，不断发现新的白血病类型。\n1900年以后在Naegeli描述了原始粒细胞的基础上明确了急性粒细胞白血病的诊断。1913年Reschad和Schilling两位学者报道了单核细胞白血病。1917年Di Guglielmo区分出红白血病。1938年又报道了粒-单细胞白血病。1957年Hillested发现急性早幼粒细胞白血病。1959年中国医学科学院血液学研究所通过细胞形态首次确认了一种新的白血病类型——亚急性粒细胞白血病；患者的病程介于急性和慢性白血病之间，骨髓中幼粒细胞比例明显增多，且以异常中性中幼粒细胞为主；后来按FAB分型的基本原则更名为AML-M2b型，继而又发现这类患者多有t（8；21），并阐明这类白血病致病与AML1-ETO募集组蛋白脱乙酰基转移酶（HDAC），进而通过染色体重塑机制影响造血特异基因的表达有关。1967年WHO将白血病分为急性淋巴细胞白血病、慢性淋巴细胞白血病、急性粒细胞白血病、急性单核细胞白血病和慢性粒细胞白血病等几类。后来英国和法国的几位学者又各自提出了不同的分型方法。这使白血病分型显得较为混乱。1976年，法-英-美3国7位学者共同研究了大量的白血病患者骨髓和外周血涂片，结合细胞化学染色，在广泛征求意见的基础上，提出了白血病的FAB诊断分型标准，后经多次修订补充，成为国际通用的白血病诊断分型语言。\nFAB分型标准将白血病分为急性淋巴细胞白血病、急性髓系白血病、慢性淋巴细胞白血病和慢性粒细胞白血病四类。其中急性淋巴细胞白血病又分为L1、L2和L3三种亚型；急性髓系白血病分为M0～M7型；慢性淋巴细胞白血病分为慢性B和T细胞白血病，共14种亚型，包括B幼淋巴细胞白血病、毛细胞白血病和成人T细胞白血病/淋巴瘤等临床罕见类型。\n随着研究的深入，发现白血病具有异常的细胞膜和细胞质分子免疫标记，许多白血病类型还有特征性的染色体和分子遗传异常。将细胞免疫表型和细胞遗传学特征与细胞形态诊断结合起来，无疑会使白血病的诊断分型更加客观、科学、精确，更具可重复性。为此，1985～1986年FAB协作组专家会同免疫学家和遗传学家，共同制订了白血病新的形态学-免疫学-细胞遗传学（MIC）分型标准；后来又结合了分子遗传特征，形成了MICM诊断分型标准。经过多年的临床实践，认识到一种恶性疾病实体的定义不能仅依靠细胞形态、免疫表型和遗传特征，而应综合现在已知的所有疾病要素。1997年WHO召集了130余位世界著名的临床血液学家和病理学家，借鉴淋巴瘤的REAL分型原则，综合病因、继往病史、细胞形态、免疫表型、遗传学特征及临床、治疗和预后特点，于2001年提出了包括白血病在内的造血和淋巴组织肿瘤新的诊断分型标准；经过多年实践，结合新的研究进展，2008年WHO对该标准又作了补充修订。总的来说，WHO诊断分型标准按细胞类型将造血和淋巴组织肿瘤分为三大类：髓系、淋系和组织细胞/树突细胞肿瘤。\n髓系肿瘤包括：\n 骨髓增殖性肿瘤（如CML）； 伴嗜酸性粒细胞增多和PDGFRA、PDGFRB或FGFR1异常的髓系和淋巴肿瘤； 骨髓增生异常/骨髓增殖性肿瘤（如CMML）； 骨髓增生异常综合征； 急性髓系白血病及相关前体肿瘤； 系列模糊的急性白血病。淋系肿瘤包括：  淋系肿瘤包括：\n 前体淋巴肿瘤（如ALL）； 成熟B细胞肿瘤（如CLL、Burkitt白血病）； 成熟T和NK细胞肿瘤（如成人T细胞白血病）； 霍奇金淋巴瘤； 免疫缺陷相关的淋巴增殖性疾病。  每一种类疾病又分若干亚型。WHO的诊断分型标准是开放性的，随着更多的临床和实验资料积累，相信将来有进一步的补充、完善。\n源文出处：https://www.tsu.tw/edu/11899.html\n",
    "pubDate": "2020-04-22T16:18:45+08:00"
  }, 
  {
    "objectID": 20200222,
    "url": "https://ichochy.com/posts/20200222/",
    "title": "mysql 使用 source/mysqldump 命令导入/导出文件信息",
    "summary": "要导入/导出数据库信息，使用 mysql 的source命令可以方便快速的处理",
    "content": "要导入/导出数据库信息，使用 mysql 的source命令可以方便快速的处理\n以MAC为例：\n 一、mysqldump命令导出SQL文件 /usr/local/mysql/bin/mysqldump -u root -p test \u0026gt; ~/test.sql 输入密码导出SQL文件，其中test为数据库名称\n二、source命令导入SLQ文件 登录数据库\n/usr/local/mysql/bin/mysql -u root -p 输入密码登录数据库\n导入SQL文件\nshow databases; //查看数据库 create database test; //创建数据库 test use test; //使用数据库 test source ~/test.sql; //快速导入超大SQL文件 通过source命令可以快速导入超大SQL文件\n",
    "pubDate": "2020-02-22T22:16:45+08:00"
  }, 
  {
    "objectID": 20191107,
    "url": "https://ichochy.com/posts/20191107/",
    "title": "Docker 中运行 ElasticSearch 和 Kibana",
    "summary": "ElasticSearch 是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口；Kibana 是一个开源的分析和可视化平台，可以搜索，查看、分析存储在Elasticsearch索引中的数据",
    "content": "ElasticSearch 是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口；Kibana 是一个开源的分析和可视化平台，可以搜索，查看、分析存储在Elasticsearch索引中的数据\n一、下载镜像(image) 搜索镜像(image)\ndocker search elasticsearch docker search kibana 获取镜像(image)\ndocker pull elasticsearch:7.4.1 #镜像名称:Tag docker pull kibana:7.4.1 #镜像名称:Tag 二、创建 docker-compose.yml 构建 es.yml\nversion: \u0026#34;3.2\u0026#34; services: elasticsearch: container_name: elasticsearch #容器名称 image: elasticsearch:7.4.1 #镜像(image) restart: always #重启方式 environment: discovery.type: single-node #环境变量：运行模式 单例 ports: - \u0026#34;9200:9200\u0026#34; #端口映射 - \u0026#34;9300:9300\u0026#34; kibana: container_name: kibana #容器名称 image: kibana:7.4.1 #镜像(image) restart: always #重启方式 environment: ELASTICSEARCH_URL: \u0026#34;127.0.0.1:9200\u0026#34; #环境变量：elasticsearch 请求地址 I18N_LOCALE: \u0026#34;zh-CN\u0026#34; #指定中文 ports: - \u0026#34;5601:5601\u0026#34; #端口映射 三、运行 命令启动\ndocker-compose -f es.yml up -d docker-compose -f #指定构建文件 up #创建并启动容器 -d #后台运行容器(container)，打印容器(container)ID 启动完成后直接访问：http://127.0.0.1:5601，进入 Kibana\n*注：*注意YML文件编写，不要出现 Tab 制表符，否则导致文件解析错误，启动容器(container)失败\n# 错误信息 yaml.scanner.ScannerError: mapping values are not allowed here ",
    "pubDate": "2019-11-07T13:24:45+08:00"
  }, 
  {
    "objectID": 20191106,
    "url": "https://ichochy.com/posts/20191106/",
    "title": "初识 Docker",
    "summary": "Docker 是个容器应用，可以跨平台安装，并使容器与容器间相“独立”运行；就好比每个容器都是一个虚拟机，而 Docker 成为了个云计算机。构建的容器好比机算机系统，可以在 Docker 中直接启动运行，而无需额外的配制系统环境。",
    "content": "Docker 是个容器应用，可以跨平台安装，并使容器与容器间相“独立”运行；就好比每个容器都是一个虚拟机，而 Docker 成为了个云计算机。构建的容器好比机算机系统，可以在 Docker 中直接启动运行，而无需额外的配制系统环境。\n一、安装 Docker Docker 分为企业版和社区版，还有桌面版，可以在 Docker Hub 去下载合适的版本 桌面版就是一个应用，直接安装就可以，很便捷，其它版本官方也有详细的说明\n二、使用 Docker 1、获取容器 容器(container)是通过镜像(image)构建的，在 Docker Hub 中获取镜像(image)\n搜索\ndocker search nginx //在 Docker Hub 搜索镜像(image) 获取\ndocker pull nginx //在 Docker Hub 获取镜像(image) 2、运行容器 运行\ndocker run --name ichochy-nginx -d -p 80:80 nginx docker run //在新容器(container)中运行命令 --name string //分配一个容器(container)名称 -d, --detach //后台运行容器(container)，打印容器(container)ID -p, --publish list //端口映射，宿主机端口:容器(container)端口 3、操作容器 执行 shell\ndocker exec -it 74282d01a2fc bash //在运行容器(container)中运行命令 复制文件\ndocker cp 74282d01a2fc:/usr/share/nginx/html/index.html ~/ichochy.html 查看镜像(image)\ndocker image ls -a //查看所有 -a 查看容器(container)\ndocker container ls -a //查看所有 -a 查看容器(container)\ndocker start/stop/restart 74282d01a2fc //启动/停止/重启 容器(container) ",
    "pubDate": "2019-11-06T15:24:45+08:00"
  }, 
  {
    "objectID": 20191028,
    "url": "https://ichochy.com/posts/20191028/",
    "title": "Mac 无密码 SSH 登录服务器",
    "summary": "Mac 无密码 SSH 登录服务器，只需要简单三步，不再需要记住账号密码，快速进入服务器",
    "content": "Mac 无密码 SSH 登录服务器，只需要简单三步，不再需要记住账号密码，快速进入服务器\n第一步，生成密钥对 在当前用户下创建.ssh目录\nmkdir ~/.ssh 使用命令ssh-keygen生成密钥对,会在~/.ssh目录下生成公/私钥\nid_rsa //私钥 id_rsa.pub //公钥 第二步，上传公钥 使用命令ssh-copy-id user@hostname\nssh-copy-id admin@192.168.1.55 输入密码，操作成功\n查看服务器～/.ssh/authorized_keys，可以看到本地的公钥已经写入到authorized_keys文件中\n运行命令ssh user@hostname就可以直接无密码 SSH 登录服务器\n第三步，config 配置 在当前用户.ssh目录下创建config文件\ntouch ~/.ssh/config 通过vim编辑config，添加服务器配置信息\nHost iChochy //服务器别名 Hostname 192.168.1.55 //服务器地址 User admin //服务器用户 Identityfile ~/.ssh/id_rsa //服务器公钥对应的本地私钥 直接运行命令ssh iChochy就可以直接无密码 SSH 登录服务器\n",
    "pubDate": "2019-10-28T15:10:45+08:00"
  }, 
  {
    "objectID": 20191018,
    "url": "https://ichochy.com/posts/20191018/",
    "title": "Spring Cloud Alibaba Nacos Discovery 实战",
    "summary": "Nacos 作为服务注册中心，可以快速简单的将服务自动注册到 Nacos 服务端，并且能够动态无感知的刷新某个服务实例的服务列表，为分布式系统提供服务注册与发现功能",
    "content": "Nacos 作为服务注册中心，可以快速简单的将服务自动注册到 Nacos 服务端，并且能够动态无感知的刷新某个服务实例的服务列表，为分布式系统提供服务注册与发现功能\n一、创建服务 1、创建项目 pom.xml中添加nacos支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; bootstrap.properties加入nacos参数\nserver.port=8080 spring.application.name=service-provider spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 #如果不想 Nacos 注册和发现当前服务，可设置为false spring.cloud.nacos.discovery=true spring.cloud.nacos.discovery.server-addr：为nacos的服务器地址:端口，80端口不可省略\n通过 Spring Cloud 原生注解 @EnableDiscoveryClient 开启服务注册发现功能：\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } } 2、编写服务 package com.ichochy.nacos.service; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/service\u0026#34;) public class EchoService { @RequestMapping(\u0026#34;echo/{name}\u0026#34;) public String echo(@PathVariable String name){ System.out.println(\u0026#34;##############\u0026#34;); return \u0026#34;Hello Nacos Discovery \u0026#34;+name; } } 3、查看服务 启动项目，可以在Nacos的服务列表中查看到当前服务\n访问地址：http://127.0.0.1:8080/service/echo/ichochy\n二、调用服务 1、创建项目 创建项目和服务方项目相同，server.port和spring.application.name设置为不同\n构建RestTemplate，@LoadBalanced开启负载均衡\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } @Bean @LoadBalanced RestTemplate restTemplate(){ return new RestTemplate(); } } 2、编写远程服务调用 package com.ichochy.nacos.controller; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/result\u0026#34;) public class ResultController { @Autowired private RestTemplate restTemplate; @RequestMapping(\u0026#34;restTemplate/{name}\u0026#34;) public String restTemplate(@PathVariable String name){ String url = \u0026#34;http://service-provider/service/echo/\u0026#34;; return restTemplate.getForObject(url+name,String.class); } } 注：通过RestTemplate远程调用服务，远程调用地址为服务方项目名+请求路径\nspring.application.name=service-provider\n3、远程调用 启动项目，测试服务调用\n访问地址：http://127.0.0.1:8080/result/restTemplate/ichochy\n三、优化调用，使用FeignClient pom.xml中添加FeignClient支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1、Spring Cloud 原生注解 通过 @EnableFeignClients 开启调用\npackage com.ichochy.nacos; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class NacosApplication { public static void main(String[] args) { SpringApplication.run(NacosApplication.class, args); } } 2、编写远程服务调用接口 package com.ichochy.nacos.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; @FeignClient(value = \u0026#34;service-provider\u0026#34;) public interface ServiceInterface { @RequestMapping(\u0026#34;/service/echo/{name}\u0026#34;) public String echo(@PathVariable String name); } 3、远程调用服务 package com.ichochy.nacos.controller; import com.ichochy.nacos.service.ServiceInterface; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(\u0026#34;/result\u0026#34;) public class ResultController { @Autowired private ServiceInterface serviceInterface; @RequestMapping(\u0026#34;feignClient/{name}\u0026#34;) public String feignClient(@PathVariable String name){ return serviceInterface.echo(name); } } 访问地址：http://127.0.0.1:8080/result/feignClient/ichochy\n",
    "pubDate": "2019-10-18T16:35:45+08:00"
  }, 
  {
    "objectID": 20191017,
    "url": "https://ichochy.com/posts/20191017/",
    "title": "Spring Cloud Alibaba Nacos Config 实战",
    "summary": "Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置",
    "content": "Nacos 提供用于存储配置和其他元数据的 key/value 存储，为分布式系统中的外部化配置提供服务器端和客户端支持。使用 Spring Cloud Alibaba Nacos Config，您可以在 Nacos Server 集中管理你 Spring Cloud 应用的外部属性配置\n一、安装 Nacos 1、下载 Nacos 最新稳定版下载：https://github.com/alibaba/nacos/releases\n2、启动 Nacos 启动 Nacos (单机模式)\nsh startup.sh -m standalone 关闭 Nacos\nsh shutdown.sh 二、配置 Nacos 1、打开 Nacos 默认地址：http://127.0.0.1:8848/nacos/#/login\n默认账号：账号密码相同，都为nacos\n2、添加配置 配置数据：\nData ID: nacos-dev.properties Group : DEFAULT_GROUP 配置格式: Properties 配置内容： useLocalCache=true Data ID 的格式说明：\n${prefix}-${spring.profile.active}.${file-extension} prefix:\n默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置\nspring.profile.active:\n即为当前环境对应的 profile， 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}\nfile-exetension:\n为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型\n 实例：\n spring.application.name=nacos spring.profiles.active=dev spring.cloud.nacos.config.file-extension=properties Data ID 为：nacos-dev.properties\n三、使用 Nacos pom.xml中添加nacos支持\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; bootstrap.properties加入nacos参数\nserver.port=8080 spring.profiles.active=dev spring.application.name=nacos spring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.cloud.nacos.config.file-extension=properties spring.cloud.nacos.config.server-addr：为nacos的服务器地址:端口，80端口不可省略\nspring.cloud.nacos.config.file-extension：为nacos的支持的文件类型，如：yaml和properties\n四、调用 Nacos @Value SpEL调用\n@RefreshScope打开自动刷新\npackage com.ichochy.nacos.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;/config\u0026#34;) @RefreshScope public class ConfigController { @Value(\u0026#34;${useLocalCache:false}\u0026#34;) private boolean useLocalCache; @RequestMapping(\u0026#34;get\u0026#34;) public boolean getConfig(){ System.out.println(useLocalCache); return useLocalCache; } } ",
    "pubDate": "2019-10-17T14:10:45+08:00"
  }, 
  {
    "objectID": 20191016,
    "url": "https://ichochy.com/posts/20191016/",
    "title": "Shell 脚本重启项目",
    "summary": "每次发打包好项目后都需要手动重启项目，写个Shell脚本一键重启项目",
    "content": "每次发打包好项目后都需要手动重启项目，写个Shell脚本一键重启项目\nShell 脚本 #!/bin/bash  while getopts \u0026#34;n:p:\u0026#34; arg do case $arg in n) echo \u0026#34;NAME\u0026#39;s arg:$OPTARG\u0026#34; NAME=$OPTARG ;; p) echo \u0026#34;PORT\u0026#39;s arg:$OPTARG\u0026#34; PORT=$OPTARG ;; esac done PROCESS=echo | lsof -i TCP:$PORT | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; if [ $PROCESS ]; then kill -9 $PROCESS echo kill $NAME:$PROCESS, restart fi cd jenkins cp jar/.tmp/$NAME-0.0.1-SNAPSHOT.jar jar/ nohup java -jar -Xms128m -Xmx256m jar/$NAME-0.0.1-SNAPSHOT.jar --eureka.url=\u0026#34;127.0.0.1:9100/eureka/\u0026#34; --profile=\u0026#34;dev\u0026#34; \u0026gt;logs/$NAME.log 2\u0026gt;\u0026amp;1 \u0026amp; echo $NAME starting Shell 说明 lsof：通过端口获取进程\ngetopts：实现Shell脚本多参数\nnohup：后台启动项目\nShell 运行 sh -n project -p 8080 ",
    "pubDate": "2019-10-16T16:10:45+08:00"
  }, 
  {
    "objectID": 20191012,
    "url": "https://ichochy.com/posts/20191012/",
    "title": "认识 Spring Cloud Alibaba",
    "summary": "个人理解 Spring Cloud Alibaba 就是 Spring Cloud 的微服务规范的一种实现，外加一些阿里云的商业组件",
    "content": "个人理解 Spring Cloud Alibaba 就是 Spring Cloud 的微服务规范的一种实现，外加一些阿里云的商业组件\nSpring Cloud 是什么 Spring Cloud 为开发人员提供一些分布式组件，使其快速构建分布式系统（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话，群集状态）。\n开发人员使用 Spring Cloud 的组件，实现分布式服务系统，让服务可以在任何分布式环境中正常工作。\nSpring Cloud Alibaba 是什么 官方介绍：Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n组件说明： 开源组件    组件 说明     Nacos Config 分布式配置管理   Nacos Discovery 服务注册和发现管理   Sentinel 流量控制和服务降级   RocketMQ 消息事件驱动   Seata 分布式事务解决方案   Dubbo Spring Cloud 服务远程调用    商业化组件    组件 说明     ACM Nacos Config的商业云服务   ANS Nacos Discovery的商业云服务   SMS 阿里云短信服务   OSS 阿里云对象存储服务   SchedulerX 阿里分布式任务调度服务    有段很好的文字总结，分享给大家：\n Spring 通常指 Spring IOC Spring Framework 包含了 Spring IOC，同时包含了 Spring AOP，并实现与其它 J2EE 框架的整合 Spring Boot 是对 Spring Framework 的补充，让框架的集成变得更简单，致力于快速开发 独立的 Spring 应用 Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文 Spring Cloud Alibaba 采用阿里中间件作为原料，实现了 Spring Cloud 的微服务规范  Spring Cloud Alibaba的官方GitHub仓库地址：\nhttps://github.com/alibaba/spring-cloud-alibaba\n",
    "pubDate": "2019-10-12T14:12:45+08:00"
  }, 
  {
    "objectID": 20191008,
    "url": "https://ichochy.com/posts/20191008/",
    "title": "通过Cloudflare开启全站https",
    "summary": "Cloudflare 添加域名后，会自动生成通用证书，快速开启全站HTTPS，服务端不用做任何修改，还可以选择多种开启模式",
    "content": "Cloudflare 添加域名后，会自动生成通用证书，快速开启全站HTTPS，服务端不用做任何修改，还可以选择多种开启模式\n一、注册Cloudflare账号 直接打开网站：https://www.cloudflare.com,就可以注册账号了，然后添加域名，选择Free套餐，没有任何费用\n二、修改DNS 免费套餐只能通过DNS方式配置 Cloudflare，收费套餐或 Partner，可以通过CNAME配置\n查看 Cloudflare 给自己分配的DNS\n打开自己的域名商网站修改DNS，以aliyun为例：\n控制台=\u0026gt;域名=\u0026gt;管理=\u0026gt;修改DNS 修改为 Cloudflare 分配的DNS后，等待生效……………………\n三、配置域名解析 检查生效状态\n配置域名解析，一般会将解析同步过来，打开小云朵表示开启CDN加速\n四、开启 HTTPS 有四种模式可以选择，分别是\n1. Off (not secure) 不开启 2. Flexible 开启 浏览器到\u0026lt;-\u0026gt;Cloudflare 3. Full 开启 浏览器\u0026lt;-\u0026gt;Cloudflare\u0026lt;-\u0026gt;服务器 4. Full (strict) 开启 浏览器\u0026lt;-\u0026gt;Cloudflare\u0026lt;-\u0026gt;服务器 信任证书，更加严格 至此，已经通过 Cloudflare 开启了 DNS、CDN、HTTPS\n但： 免费套餐在国内是没有快速的 CDN 节点，CDN 也就没有加速的效果了\n如果需要国内快速的 CDN ，可以使用企业版，但要不差钱，或使用国内合作商百度云加速\n",
    "pubDate": "2019-10-08T14:22:45+08:00"
  }, 
  {
    "objectID": 20190925,
    "url": "https://ichochy.com/posts/20190925/",
    "title": "jekyll-admin的搭建和使用",
    "summary": "通过jekyll搭建好了自己的博客。写博客成为了日常，经过一段时间的摸索，发现jekyll-admin是个好东西，它是博客的后台管理系统，可以方便的管理和编写自己的博客",
    "content": "通过jekyll搭建好了自己的博客。写博客成为了日常，经过一段时间的摸索，发现jekyll-admin是个好东西，它是博客的后台管理系统，可以方便的管理和编写自己的博客\n安装 运行命令gem install jekyll-admin进行安装\n配置 在_config.yml中添加 - jekyll-admin\nplugins: - jekyll-admin 使用 运行命令jekyll server 启动jekyll\n直接访问http://127.0.0.1:4000/admin就可以看到jekyll-admin的使用界面\n",
    "pubDate": "2019-09-25T15:22:38+08:00"
  }, 
  {
    "objectID": 20190922,
    "url": "https://ichochy.com/posts/20190922/",
    "title": "神奇的不可见空格\u003c200b\u003e导致代码异常",
    "summary": "故事是这样发生的，在做一个JSON对象转化的时候，出现了转化异常；刚开始还是以为是格式错误，后来一步步排除，才发现是不可见空格\u0026lt;200b\u0026gt;导致的解析异常",
    "content": "故事是这样发生的，在做一个JSON对象转化的时候，出现了转化异常；刚开始还是以为是格式错误，后来一步步排除，才发现是不可见空格\u0026lt;200b\u0026gt;导致的解析异常\n出现 使用Typora编写文字时，使用Tab会生成神奇的不可见空格\n发现 通过VIM查看文档，会看到\u0026lt;200b\u0026gt;神奇的存在\n解决 1 . 使用trim()方法可以去除掉神奇的空格 2 . 使用正则表式进行替换replace(/\\t+/g,\u0026quot;\u0026quot;)\n",
    "pubDate": "2019-09-22T18:12:45+08:00"
  }, 
  {
    "objectID": 20190904,
    "url": "https://ichochy.com/posts/20190904/",
    "title": "OC与Swift混编，三种场景的实现方式",
    "summary": "多语言并存时期，混编成为一种必须的方式 ，在多场景中实现OC和Swift语言的并存原来是如此简单",
    "content": "多语言并存时期，混编成为一种必须的方式 ，在多场景中实现OC和Swift语言的并存原来是如此简单\n第一种场景，App中实现混编 1. 创建桥接文件*.h 新建一个桥接文件，New File 选择 Header File 创建\n2. 指定桥接文件 指定刚刚的新建的桥接文件 project-\u0026gt;targets-\u0026gt;Build Setting-\u0026gt;All-\u0026gt;Swift Compilter General-\u0026gt;Objective-C-Bridging-Header 3. 导入OC头文件(*.h)到桥接文件 如：#import \u0026quot;Log.h\u0026quot;\n4. 完成调用，在Swift文件中直接调用 注：在Swift项目中第一次创建OC文件，Xcode会自动提示创建桥接文件\n第二种场景，Framework 中实现混编 1. 创建Famework 创建完成后会生成一个同名头文件*.h\n2. 将OC头文件(*.h)设置为公开头文件 直接拖入 project-\u0026gt;targets-\u0026gt;Build Phases-\u0026gt;Headers-\u0026gt;Public 3. 导入OC头文件(*.h)到同名头文件 如：#import \u0026quot;Log.h\u0026quot;\n4. 完成调用 在对外的Swift文件中直接调用\n注：对外的类和方法必须 public 标示才可访问\n第三种场景，Pod 包中实现混编 在完成第二种场景后，添加*.podspec文件实现 Pod 包\n1. 生成 *.podspec 运行命令 pod spec create [name] 生成 *.podspec 文件\n2. 编辑 *.podspec 在 *.podspec 中将OC头文件(*.h)设置为公开头文件\n如：spec.public_header_files = \u0026quot;Log.h\u0026quot;\n#完整的文件信息 Pod::Spec.new do |spec| spec.name = \u0026#34;OCSwiftFramework\u0026#34; spec.version = \u0026#34;0.0.1\u0026#34; spec.summary = \u0026#34;OCSwiftFramework\u0026#34; spec.description = \u0026lt;\u0026lt;-DESC OCSWiftFramework DESC spec.homepage = \u0026#34;https://www.ichochy.com\u0026#34; spec.license = \u0026#34;MIT\u0026#34; # spec.license = { :type =\u0026gt; \u0026#34;MIT\u0026#34;, :file =\u0026gt; \u0026#34;FILE_LICENSE\u0026#34; } spec.author = { \u0026#34;MLeo\u0026#34; =\u0026gt; \u0026#34;iChochy@qq.com\u0026#34; } spec.platform = :osx spec.osx.deployment_target = \u0026#34;10.10\u0026#34; spec.source = { :git =\u0026gt; \u0026#34;https://github.com/iChochy/HelloWorld.git\u0026#34;, :tag =\u0026gt; \u0026#34;#{spec.version}\u0026#34; } spec.source_files = \u0026#34;**/*.{h,m,swift}\u0026#34; spec.exclude_files = \u0026#34;Info.plist\u0026#34; spec.public_header_files = \u0026#34;Flog.h\u0026#34; spec.swift_version = \u0026#34;4.2\u0026#34; end 3. 验证 *.podspec 运行命令 pod lib lint 完成验证\n4. 完成调用 a. 运行命令 pod trunk push [NAME.podspec] 完成发布\nb. Podfile 中添加 pod \u0026quot;[name]\u0026quot;\nc. 运行命令 pod install 完成 pod 安装\nd. 安装完成后直接调用\n注：可用 pod \u0026quot;[name]\u0026quot;, :path =\u0026gt; \u0026quot;[path]\u0026quot; 本地指定\nGitHub： HelloWorld：https://github.com/iChochy/HelloWorld.git\n",
    "pubDate": "2019-09-04T10:22:33+08:00"
  }, 
  {
    "objectID": 20190901,
    "url": "https://ichochy.com/posts/20190901/",
    "title": "CocoaPods 构建自己的 Pod 库",
    "summary": "构建一个自己的库供其它人使用是不是一件很酷(苦)的事情，通过CocoaPods 可以快捷的构建自己库，并向全世界分享你的成果",
    "content": "构建一个自己的库供其它人使用是不是一件很酷(苦)的事情，通过CocoaPods 可以快捷的构建自己库，并向全世界分享你的成果\n一、创建 Podspec 有两种方式：\n 使用命令 pod lib create mylib 创建一套完整的 Pod 库模版 使用命令 pod spec create mylib 创建 Podspec 的配置文件  二、配置 Podspec 官网说明：https://guides.cocoapods.org/syntax/podspec.html#specification\nPod::Spec.new do |spec| spec.name = \u0026#39;libminipng\u0026#39; spec.version = \u0026#39;0.0.5\u0026#39; spec.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39; } spec.homepage = \u0026#39;https://www.ichochy.com\u0026#39; spec.authors = { \u0026#39;iChochy\u0026#39; =\u0026gt; \u0026#39;iChochy@qq.com\u0026#39; } spec.summary = \u0026#39;Swift library that compresses PNG\u0026#39; spec.source = { :git =\u0026gt; \u0026#39;https://github.com/iChochy/libminipng.git\u0026#39;, :tag =\u0026gt; \u0026#39;v3.1.0\u0026#39; } spec.source_files = \u0026#39;libminipng/Classes/**/*\u0026#39; spec.public_header_files = \u0026#34;libminipng/Classes/libminipng.h\u0026#34;,\u0026#34;libminipng/Classes/minipng.h\u0026#34; end spec.source：检索库的远程地址\n支持指定方式：\n:git =\u0026gt; :tag, :branch, :commit, :submodules :svn =\u0026gt; :folder, :tag, :revision :hg =\u0026gt; :revision :http =\u0026gt; :flatten, :type, :sha256, :sha1, :headers spec.source_files: 库的源代码\n通过正则方式匹配，如：\n\u0026#34;JSONKit.?\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;] \u0026#34;*.[a-z][a-z]\u0026#34; #=\u0026gt; [\u0026#34;CHANGELOG.md\u0026#34;, \u0026#34;README.md\u0026#34;] \u0026#34;*.[^m]*\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;] \u0026#34;*.{h,m}\u0026#34; #=\u0026gt; [\u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;] \u0026#34;*\u0026#34; #=\u0026gt; [\u0026#34;CHANGELOG.md\u0026#34;, \u0026#34;JSONKit.h\u0026#34;, \u0026#34;JSONKit.m\u0026#34;, \u0026#34;README.md\u0026#34;] spec.public_header_files: 公共头文件\n如果OC混编，可以在公共头文件中引入OC文件，如同桥接文件\n注：如果未指定公共头文件，那么source_files中的所有文件将被视为公共头文件\n三、验证 Podspec pod lib lint //本地验证 pod spec lint //在线验证，检查外部仓库和相关标签 如果出现警告(WARN) ，可以添加--allow-warnings忽略警告\n如果出现错误(ERROR)，可以添加 --verbose，查看详情\n四、创建账号  注册账号：\npod trunk register iChochy@qq.com 'iChochy' --description='macbook' 激活账号：\n完成注册后进入邮件点击激活链接进行激活操作 查看账号：\npod trunk me  五、发布 Podspec pod trunk push [NAME.podspec] 将您的Podspec部署到Trunk，并公开发布\npod repo push REPO [NAME.podspec] 将您的Podspec部署到私有仓库\n注：如果出现警告(WARN) ，可以添加--allow-warnings忽略警告\n",
    "pubDate": "2019-09-01T12:32:55+08:00"
  }, 
  {
    "objectID": 20190823,
    "url": "https://ichochy.com/posts/20190823/",
    "title": "Mac 将 App 程序打包成为 dmg",
    "summary": "用最简单的打包方式，将自己开发的App打包成为DMG，实现共享分发，快速安装",
    "content": "用最简单的打包方式，将自己开发的App打包成为DMG，实现共享分发，快速安装\n1. 新建DMG 打开磁盘工具，新建DMG\nFile-\u0026gt;New Image-\u0026gt;Blank Image 创建DMG\n2. 添加文件 在磁盘工上右键打开\n右键-\u0026gt;Show in Finder 创建快捷键\nln -s /Applications Applications 完成文件添加\n3. 排版，添加背景 修改排版\n右键-\u0026gt;Show View Options 自定义背景\n4. 压缩DMG 推出DMG\n转换DMG\n压缩DMG\n压缩后的文件明显小于原文件，也不可再进行编辑\n5. 完成打包 至此，完成了App打包DMG，可以进行共享发布了\n",
    "pubDate": "2019-08-23T08:32:36+08:00"
  }, 
  {
    "objectID": 20190822,
    "url": "https://ichochy.com/posts/20190822/",
    "title": "iUploader 2.0 七牛云上传工具",
    "summary": "iUploader 是一个免费开源的七牛云上传工具，可直接返回上传文件的地址；可以用作图床工具，进行图片的分享，当然不仅仅是图片",
    "content": "iUploader 是一个免费开源的七牛云上传工具，可直接返回上传文件的地址；可以用作图床工具，进行图片的分享，当然不仅仅是图片\n软件介绍： iUploader主要功能将文件上传至七牛云，返回 Markdown 格式的链接到剪贴板\n功能介绍：  图片本地压缩 图片右键上传 图片截取上传 图片复制上传 图片拖拽上传 https加密上传  开发： 继承七牛云SDK，使用Swift开发，App自签上传凭证，自动选择存储区域，通过https加密上传。\n截图： 菜单\n配置\n更新：  剪贴板监控，截图自动上传 引入pngquant， 提高png图片的压缩比，减少流量的损失，快速完成图片的加载 添加历史记录，方便随时查看使用上传文件，保留十条 完善文件上传流程，不限于图片的上传 完善多文件上传，统一完成上传 优化进度加载展示，菜单逻辑调整  下载： iUploader.dmg-GitHub\niUploader.dmg-七牛云\nhttps://github.com/iChochy/iUploader/releases/download/2.0.5/iUploader.dmg\n",
    "pubDate": "2019-08-22T15:22:36+08:00"
  }, 
  {
    "objectID": 20190812,
    "url": "https://ichochy.com/posts/20190812/",
    "title": "libminipng 压缩png的swift-framework",
    "summary": "通过lodepng解析png图片，使用pngquant算法进行压缩的swift-framework，可实现PNG图片的压缩，并很好的保持图片的质量，完美实现其透明效果，支持Cocoapods安装使用",
    "content": "通过lodepng解析png图片，使用pngquant算法进行压缩的swift-framework，可实现PNG图片的压缩，并很好的保持图片的质量，完美实现其透明效果，支持Cocoapods安装使用\n方法说明： /// 通过PNG图片Data压缩 /// /// - Parameters: /// - data: PNG图片Data /// - maximum: 压缩率，0-100,100为最好 /// - Returns: 压缩后的PNG图片Data public static func data2Data(_ data:Data,_ maximum:Int) -\u0026gt; Data? /// 通过PNG图片路径压缩 /// /// - Parameters: /// - path: PNG图片路径 /// - maximum: 压缩率，0-100,100为最好 /// - Returns: 压缩后的PNG图片Data public static func path2Data(_ path:String,_ maximum:Int) -\u0026gt; Data? Cocoapods Podfile 添加 pod \u0026quot;libminipng\u0026quot;\n运行命令 pod install\n使用 引入 import libminipng\n编写代码：\nlet path:String = \u0026#34;https://images.ichochy.com/Cloud.png\u0026#34; let data:Data = try! Data.init(contentsOf: URL.init(string: path)!) let maximum:Int = 100 // 压缩率，0-100,100为最好 let result:Data? = minipng.data2Data(data,maximum) try! result?.write(to: URL.init(fileURLWithPath: \u0026#34;/Users/mleo/minipng.png\u0026#34;)) let path:String = \u0026#34;/Users/mleo/Cloud.png\u0026#34; let maximum:Int = 100 // 压缩率，0-100,100为最好 let result:Data? = minipng.path2Data(path, maximum) try! result?.write(to: URL.init(fileURLWithPath: \u0026#34;/Users/mleo/minipng.png\u0026#34;))  GitHub: libminipng: https://github.com/iChochy/libminipng\npngquant: https://github.com/ImageOptim/libimagequant\nlodepng: https://github.com/lvandeve/lodepng\n",
    "pubDate": "2019-08-12T12:25:36+08:00"
  }, 
  {
    "objectID": 20190412,
    "url": "https://ichochy.com/posts/20190412/",
    "title": "通过端口号关闭当前进程",
    "summary": "使用Shell脚本的方式，通过端口号来关闭当前进程",
    "content": "使用Shell脚本的方式，通过端口号来关闭当前进程\n查看脚本： lsof -i TCP:9100 | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; 使用到三个命令lsof、grep、awk\n lsof 获取端口进程列表\ngrep 精准匹配进程\nawk 获取进程号\n 完整示例： #!/bin/bash  PROCESS=echo | lsof -i TCP:9100 | grep LISTEN | awk \u0026#39;{print $2}\u0026#39; if [ $PROCESS ]; then kill -9 $PROCESS echo kill $PROCESS fi ",
    "pubDate": "2019-04-12T12:25:36+08:00"
  }, 
  {
    "objectID": 20190410,
    "url": "https://ichochy.com/posts/20190410/",
    "title": "持续集成和持续交付工具-jenkins",
    "summary": "打破原有的手动部署方式，实现程序自动化；通过jenkins来解放你的双手",
    "content": "打破原有的手动部署方式，实现程序自动化；通过jenkins来解放你的双手\njenkins说明 jenkins是一款由Java编写的开源的持续集成工具，它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令，可以通过各种手段触发构建，例如提交给版本控制系统时被触发，也可以通过类似Cron的机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。\njenkins安装 官方下载：https://jenkins.io/zh/download/\n有相应系统的安装包和通用包(.war），通过Servlet容器运行\n1､WAR包安装  将最新的稳定Jenkins WAR包 下载到您计算机上的相应目录。\n在下载的目录内打开一个终端/命令提示符窗口。\n运行命令java -jar jenkins.war\n浏览 http://127.0.0.1:8080 ，并等到Unlock Jenkins页面出现。\n 2､brew安装 Mac下执行brew install jenkins-lts 命令安装\nMacBook-Pro:~ mleo$ brew install jenkins-lts Updating Homebrew... ==\u0026gt; Auto-updated Homebrew! Updated 2 taps (homebrew/core and homebrew/cask). ==\u0026gt; New Formulae zabbix-cli ==\u0026gt; Downloading http://mirrors.jenkins.io/war-stable/2.164.1/jenkins.war ==\u0026gt; Downloading from http://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/2.164.1/jenkins.war ######################################################################## 100.0% ==\u0026gt; jar xvf jenkins.war ==\u0026gt; Caveats Note: When using launchctl the port will be 8080. To have launchd start jenkins-lts now and restart at login: brew services start jenkins-lts Or, if you don\u0026#39;t want/need a background service you can just run: jenkins-lts ==\u0026gt; Summary 🍺 /usr/local/Cellar/jenkins-lts/2.164.1: 7 files, 77.3MB, built in 26 seconds ==\u0026gt; `brew cleanup` has not been run in 30 days, running now... Removing: /Users/mleo/Library/Caches/Homebrew/java_cache... (275B) Removing: /Users/mleo/Library/Logs/Homebrew/cocoapods... (64B) 安装完成后可以执行brew services list查看安装服务\nMacBook-Pro:~ mleo$ brew services list Name Status User Plist jenkins-lts stopped 启动jenkins，执行brew services start jenkins-lts 关闭jenkins，执行brew services stop jenkins-lts\nMacBook-Pro:~ mleo$ brew services start jenkins-lts ==\u0026gt; Successfully started `jenkins-lts` (label: homebrew.mxcl.jenkins-lts) 直接访问：http://127.0.0.1:8080\n第一次进行需解锁\n通过cat /Users/mleo/.jenkins/secrets/initialAdminPassword 查看密码\n推荐插件安装中\n创建第一个管理员\n实例配置\n进入系统\njenkins使用 部署项目 一、创建任务 左上角点击新建任务\n选择自由风格项目进入配置\n配置任务主要分下面几步：\n 1､项目说明 2､源代码管理 3､构建触发 4､构建准备 5､构建操作 6､构建完后操作\n 二、执行任务 进入任务，点击立即构建\n三、查看日志 进入构建进程，查看控制台输出 可以查看构建日志\n",
    "pubDate": "2019-04-10T12:20:32+08:00"
  }, 
  {
    "objectID": 20190403,
    "url": "https://ichochy.com/posts/20190403/",
    "title": "七牛云图床上传工具-iUploader",
    "summary": "iUploader主要功能将图片上传至七牛云，返回 Markdown 格式的链接到剪贴板",
    "content": "iUploader主要功能将图片上传至七牛云，返回 Markdown 格式的链接到剪贴板\n功能介绍：\n 图片本地压缩 图片右键上传 图片复制上传 图片拖拽上传 https加密上传  开发：\n继承七牛云SDK，使用swift开发，App自签上传凭证，自动选择存储区域，通过https加密上传。\n下载：\nhttps://github.com/iChochy/iUploader/releases/download/1.0.1/App.dmg\n",
    "pubDate": "2019-04-03T08:20:05+08:00"
  }, 
  {
    "objectID": 20190309,
    "url": "https://ichochy.com/posts/20190309/",
    "title": "加速你的博客永无止境-七牛云存储",
    "summary": "将自己的静态博客直接部署到七牛云存储，由七牛云托管运行，你说快不快，还没有注册七牛云的看这里，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y，哈哈！",
    "content": "将自己的静态博客直接部署到七牛云存储，由七牛云托管运行，你说快不快，还没有注册七牛云的看这里，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y，哈哈！\n一、创建七牛云存储 登录进入管理中心，菜单进入：对象存储=\u0026gt;新建存储空间，设置好空间名称就可以直接创建，完成后会分配一个测试域名，有效期只有30天，当然可以自定义域名，长期使用\n二、静态博客文件构建 我使用的是jekyll管理博客， 通过命令jekyll build构建\nMacBook-Pro:iChochy mleo$ jekyll build Configuration file: /Users/mleo/Develop/GitHub/iChochy/_config.yml Source: /Users/mleo/Develop/GitHub/iChochy Destination: /Users/mleo/Develop/GitHub/iChochy/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 1.121 seconds. Auto-regeneration: disabled. Use --watch to enable. 构建成功后，生成的静态文件都在_site目录中，直接上传到云空间就可以了\n三、同步静态博客文件到云存储 这里使用到七牛云官方工具qshell\n 工具介绍：https://github.com/qiniu/qshell\n工具下载：http://devtools.qiniu.com/qshell-v2.3.6.zip\n 选择安装：\n   文件名 描述     shell_linux_x86 Linux 32位系统   shell_linux_x64 Linux 64位系统   shell_linux_arm Linux ARM CPU   shell_windows_x86.exe Windows 32位系统   shell_windows_x64.exe Windows 64位系统   shell_darwin_x64 Mac 64位系统，主流的系统    1､安装\n以Mac为例，安装shell_darwin_x64\n运行复制命令：cp qshell_darwin_x64 /usr/local/bin/qshell，将shell_darwin_x64复制到 bin目录下，运行qshell -v检测是否安装成功\nMacBook-Pro:qshell-v2.3.6 mleo$ qshell -v qshell version v2.3.6 2､添加账号\n运行命令qshell account\nqshell account \u0026lt;AK\u0026gt; \u0026lt;SK\u0026gt; \u0026lt;Your Name\u0026gt;    参数 说明     \u0026lt;AK\u0026gt;、\u0026lt;SK\u0026gt; 可以到个人中心 =\u0026gt; 密钥管理中查看   \u0026lt;Your Name\u0026gt; 为用户的唯一标识，自定义，如iChochy    3､同步文件\n使用命令qshell qupload \u0026lt;LocalUploadConfig\u0026gt; 其中LocalUploadConfig参数配制文件\n本人的LocalUploadConfig文件信息：\nMacBook-Pro:iChochy mleo$ cat .LocalUploadConfig { \u0026#34;src_dir\u0026#34; : \u0026#34;/Users/mleo/Develop/GitHub/iChochy/_site\u0026#34;, \u0026#34;bucket\u0026#34; : \u0026#34;blog\u0026#34;, \u0026#34;ignore_dir\u0026#34; : false, \u0026#34;overwrite\u0026#34; : true, \u0026#34;check_exists\u0026#34; : true, \u0026#34;check_hash\u0026#34; : true, \u0026#34;check_size\u0026#34; : true, \u0026#34;rescan_local\u0026#34; : true, \u0026#34;skip_file_prefixes\u0026#34; : \u0026#34;test,demo,\u0026#34;, \u0026#34;skip_path_prefixes\u0026#34; : \u0026#34;hello/,temp/\u0026#34;, \u0026#34;skip_fixed_strings\u0026#34; : \u0026#34;.svn,.git,.log\u0026#34;, \u0026#34;skip_suffixes\u0026#34; : \u0026#34;.DS_Store,.exe\u0026#34;, \u0026#34;log_file\u0026#34; : \u0026#34;/Users/mleo/.qshell/upload.log\u0026#34;, \u0026#34;log_level\u0026#34; : \u0026#34;info\u0026#34;, \u0026#34;log_rotate\u0026#34; : 1, \u0026#34;log_stdout\u0026#34; : false, \u0026#34;file_type\u0026#34; : 0 } 主要参数说明：\n   参数 说明     src_dir 本地同步目录   bucket 云空间名称   log_file 日志文件    命令参数详细说明：https://github.com/qiniu/qshell/blob/master/docs/qupload.md\nMacBook-Pro:iChochy mleo$ qshell qupload .LocalUploadConfig Writing upload log to file /Users/mleo/.qshell/upload.log Uploading /Users/mleo/Develop/GitHub/iChochy/_site/404.html =\u0026gt; 404.html [1/67, 1.5%] ... ………… See upload log at path /Users/mleo/.qshell/upload.log 通过日志查看详情\ncat /Users/mleo/.qshell/upload.log 至此：文件已经同步到了云空间，修改文件后再次运行qshell qupload \u0026lt;LocalUploadConfig\u0026gt;命令及可完成同步\n四、自定义域名 1､云空间绑定域名\n菜单进入对象存储=\u0026gt;空间概览=\u0026gt;融合 CDN 加速域名=\u0026gt;立即绑定一个域名 创建域名\n2､域名解析\n创建成功后七牛云会为每个域名分配一个CNAME，如：www.ichochy.com.qiniudns.com\n登录域名商的管理系统，将域名解析到CNAME\n五、设置存储空间 菜单进入对象存储=\u0026gt;空间设置 设置空间信息\n如：开启默认首页index.html，自定义404页面等\n现在可以通过域名直接访问自己的博客了，是不是非常快快快………………\n如：https://www.ichochy.com\n",
    "pubDate": "2019-03-08T16:10:00+08:00"
  }, 
  {
    "objectID": 20190306,
    "url": "https://ichochy.com/posts/20190306/",
    "title": "加速你的博客永无止境-七牛云CDN",
    "summary": "个人的博客是通过jekyll构建，通过GitHub Pages搭建，可是在国内访问速度慢，百度还无法检索，网上找到的就是通CDN来加速博客。于是开始了折腾………………",
    "content": "个人的博客是通过jekyll构建，通过GitHub Pages搭建，可是在国内访问速度慢，百度还无法检索，网上找到的就是通CDN来加速博客。于是开始了折腾………………\n先了解下什么是CDN：\n CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN的关键技术主要有内容存储和分发技术\n个人的简单理解：将源站的内容分散缓存，形成多个接点，当用户访问，将最快的接点返回给用户，达到想要的提速效果\n 1.开启CDN 使用七牛云CDN，个人用户可以免费使用10G的流量；使用七牛云CDN加速有个必要条件，有自己的域名，并通过国家的域名备案，七牛云注册邀请：https://portal.qiniu.com/signup?code=3l7cpouzlru4y\n直接开干，先注册个人用户，并实名(国家的优待)\n菜单进入：融合 CDN =\u0026gt;域名管理=\u0026gt;添加域名\n   标题 填写的内容     加速域名 自己的域名，如：www.ichochy.com   通信协议 http/https，注：https没有免费的流量   源站配置 选择源站域名,写下github pages的地址，如：ichochy.github.io   源站配置 源站测试：添加一个源站能访问的地址，如：index.html，完成源站测试    填写完相关信息后可以直接创建了，创建好后需要等待几分钟，让七牛云完成实例化，七牛云会为每个域名分配一个CNAME，如：www.ichochy.com.qiniudns.com。\n2.修改域名解析 现在还差最后一步，也是最关键的，登录域名商的管理系统，修改域名解析，将域名指向七牛云生成的CNAME，完成解析\n   标题 填写的内容     记录类型 选择CNAME   主机记录 如：www   记录值 如：www.ichochy.com.qiniudns.com    所有的操作完成后，可以看到七牛云上域名状态是成功\n3.测试成果 通过dig命令可以查看到域名解析的过程：\nMacBook-Pro:_posts mleo$ dig www.ichochy.com ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; www.ichochy.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 24019 ;; flags: qr rd ra; QUERY: 1, ANSWER: 11, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;www.ichochy.com.\tIN\tA ;; ANSWER SECTION: www.ichochy.com.\t600\tIN\tCNAME\twww.ichochy.com.qiniudns.com. www.ichochy.com.qiniudns.com. 600\tIN\tCNAME\tdaliupnew.china.qiniudns.com. daliupnew.china.qiniudns.com. 456 IN\tCNAME\ttinychinacdndownload.qiniu.com.w.kunlunea.com. 直此，完成了CDN的加速\n4.问题 快也缓存，慢也缓存，因为有缓存的存在，导致新更新的内容不能及时推送给用户，这里就要手动去刷新\n菜单进入：融合 CDN =\u0026gt;刷新预取=\u0026gt;刷新文件根据自己的情况进行提交，如图：\n",
    "pubDate": "2019-03-06T15:25:00+08:00"
  }, 
  {
    "objectID": 20190213,
    "url": "https://ichochy.com/posts/20190213/",
    "title": "Jekyll+GitHub Pages部署自己的静态Blog",
    "summary": "混了这么久，一直想拥有自己的博客，通过jekyll和GitHub Pages捣腾出了自己的博客(https://www.",
    "content": "混了这么久，一直想拥有自己的博客，通过jekyll和GitHub Pages捣腾出了自己的博客(https://www.ichochy.com)\n一、安装jekyll   首先有安装Ruby的开发环境\n  运行gem install jekyll bundler安装jekyll和bundler\n  运行jekyll new myBlog创建默认的blog\n 文件目录：\n -rw-r--r-- 1 mleo staff 35 2 13 15:02 .gitignore -rw-r--r-- 1 mleo staff 398 2 13 15:02 404.html -rw-r--r-- 1 mleo staff 1039 2 13 15:02 Gemfile -rw-r--r-- 1 mleo staff 1686 2 13 15:03 Gemfile.lock -rw-r--r-- 1 mleo staff 1652 2 13 15:02 _config.yml drwxr-xr-x 3 mleo staff 96 2 13 15:02 _posts -rw-r--r-- 1 mleo staff 539 2 13 15:02 about.md -rw-r--r-- 1 mleo staff 175 2 13 15:02 index.md   运行cd myBlog进入blog目录，运行bundler exec jelly serve启动\nMacBook-Pro:myBlog mleo$ bundler exec jekyll serve Configuration file: /Users/mleo/Develop/Coding/myBlog/_config.yml Source: /Users/mleo/Develop/Coding/myBlog Destination: /Users/mleo/Develop/Coding/myBlog/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 0.862 seconds. Auto-regeneration: enabled for \u0026#39;/Users/mleo/Develop/Coding/myBlog\u0026#39; Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop.   通过http://127.0.0.1:400就可以访问blog了\n 如下图：\n   二、了解jekyll   jekyll目录结构：\n   文件/目录 描述     _config.yml 常量配置信息，网站的基础信息   _drafts 未发布的草稿帖子   _includes 模块化页面，使用： include default.html   _layouts 布局模板页面，使用: layout: default   _posts 发布的blog，固定格式： YEAR-MONTH-DAY-title.MARKUP。   _data 文件数据（.yml、 .yaml、.json、.csv或.tsv格式）   _sass 定义站点使用的样式   _site Jekyll build 后生成的站点静态文件   .jekyll-metadata Jekyll build 日志信息   index.html或index.md其他HTML，Markdown文件 将由Jekyll转换，生成首页   其他文件/文件夹 例如 css、images和favicon.ico文件等      通过Gemfile文件配置 jekyll 主题\n从Jekyll 3.2开始，jekyll new使用Gemfile文件来定义网站的主题，使默认目录结构更简单。默认情况下_layouts，_includes和_sass存储在Ruby中。\nminima 是默认主题，运行 bundle show minima 显示主题文件位置\nMacBook-Pro:myBlog mleo$ bundle show minima /Library/Ruby/Gems/2.3.0/gems/minima-2.5.0   自定义站点信息\n通过自定义_config.yml文件，改变 blog 网站信息，\n   常量 说明     title 标题   email 作者邮箱   description 网站信息   baseurl 网站路径   url 网站地址，如：https://www.ichochy.com   twitter_username 媒体账号，如：iChochy   github_username 媒体账号，如：iChochy    注：修改_config.yml需要重启服务\n  三、书写Blog   进入_post目录，开始你的创作吧，注意文件的格式必须为YEAR-MONTH-DAY-title.MARKUP，如：2019-02-13-blog.md 。\n  开始写作吧，直接使用md语法来书写你的文章\n--- --指定模板 title: \u0026#34;blog\u0026#34; --标题 date: 2019-02-13 15:02:11 +0800 --时间 tags: blog --分类 --- --内容 1. 开始 内空 2. 写作 内容 3. 完成 内容  如下图：\n   四、创建GitHub Pages项目   新建一个项目，项目名必须为\u0026lt;username\u0026gt;.github.io,如：我的用户名为iChochy，项目名为iChochy.github.io\n 如下图：\n   五、将Blog接交到GitHub  将本地写好的的blog pull到github上，在项目设置中打开GitHub Pages   如下图：\n ![WX20190218-102109](https://images.ichochy.com/WX20190218-102109.png)   选择master branch并保存，就完成了部署  六、运行Blog 直接访问项目名(\u0026lt;username\u0026gt;.github.io)就可以看你blog了，如：iChochy.github.io\n七、自定义域名   自定义域名需要有自己的域名，没有可以注册购买个心意的域名：阿里云\n  进入域名配置中心，配置域名解析\n 如下图：\n   进入github项目设置，设置自己的域名并保存，就完成了自定义域名设置\n 如下图：\n   八、开启HTTPS   进入github项目设置，开启Enforce HTTPS就完成了\n 不过，如果是自定义域名，会需要等待几分钟，github需要申请证书并部署\n   完成开启后，如下图：\n  ",
    "pubDate": "2019-02-13T11:45:00+08:00"
  }, 
  {
    "objectID": 20190212,
    "url": "https://ichochy.com/posts/20190212/",
    "title": "通过shell查看SVN的版本信息",
    "summary": "实现原理：通过svn info查看svn信息，使用grep获取版本信息，用awk获取版本号，然后对比版本号是否需要更新",
    "content": "实现原理：通过svn info查看svn信息，使用grep获取版本信息，用awk获取版本号，然后对比版本号是否需要更新\n#!/bin/sh revision=`svn info |grep \u0026quot;Last Changed Rev:\u0026quot; |awk '{print $4}'` echo \u0026quot;the revision is $revision\u0026quot; URL=`svn info |grep ^URL: |awk '{print $2}'` echo \u0026quot;the url is $URL\u0026quot; svnRevision=`svn info $URL |grep \u0026quot;Last Changed Rev:\u0026quot; |awk '{print $4}'` echo \u0026quot;the revision in svn is $svnRevision\u0026quot; if [[ $revision \u0026lt; $svnRevision ]] ; then echo \u0026quot;need svn up\u0026quot; svn up echo \u0026quot;svn up finish\u0026quot; else echo \u0026quot;no need svn up\u0026quot; fi ",
    "pubDate": "2019-02-12T08:20:05+08:00"
  }, 
  {
    "objectID": 20181212,
    "url": "https://ichochy.com/posts/20181212/",
    "title": "倍速音乐",
    "summary": "学习需要，有太多的音频文件要听，可是常用的播放器只能常速播放。所以有了后面的想法，自己开发一款App，来实现倍速播放的需求，加快学习进度，提高效率，节省时间。",
    "content": "学习需要，有太多的音频文件要听，可是常用的播放器只能常速播放。所以有了后面的想法，自己开发一款App，来实现倍速播放的需求，加快学习进度，提高效率，节省时间。\n优点：  简单、便捷、快速 倍速播放，能快也能慢，让您学习随心所欲 支持后台播放，让您不间断学习，加快学习进度  软件截图：   锁屏播放\n  锁屏播放\n  播放界面\n  ",
    "pubDate": "2018-12-12T18:30:00+08:00"
  }, 
  {
    "objectID": 20181202,
    "url": "https://ichochy.com/posts/20181202/",
    "title": "开篇",
    "summary": "说说生活 生活总是有太多的磨炼，让你一步步的成长，可传奇的背后都是些艰辛的故事。",
    "content": "说说生活 生活总是有太多的磨炼，让你一步步的成长，可传奇的背后都是些艰辛的故事。\n我坚信，每个人都有自己的生活方式，但只要认真一点点，再坚持一点点，就会有不一样的生活。\n很多时候，被现实生活所迫，总是难以突破自己，不敢尝试。\n若想改变就必须不断的尝试新事物，越是让自己害怕就越要尝试，熟悉后害怕也就消失了，自己才有新高度，看待问题的方式又改变了。\n",
    "pubDate": "2018-12-02T18:32:03+08:00"
  }
]